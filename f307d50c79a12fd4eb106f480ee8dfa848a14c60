{
  "comments": [
    {
      "key": {
        "uuid": "15a4e085_8f8bf3be",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1073,
      "author": {
        "id": 856
      },
      "writtenOn": "2021-06-04T12:59:20Z",
      "side": 1,
      "message": "just to remind that this method called on dht::ThreadPool.io() threads (through connectDeviceStartIce), meaning, potentially all the pool thread will be registered.",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2b5fb38_fa3d0790",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1073,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-06-09T20:42:33Z",
      "side": 1,
      "message": "This is fine, because checking if a thread is registered for PJSIP is a trivial operation, and there is no limit of thread number in PJSIP. PJSIP internally uses thread_local variables to store thread-specific data.",
      "parentUuid": "15a4e085_8f8bf3be",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a34cbcb_2ae2d4cf",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1073,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-06-10T12:58:29Z",
      "side": 1,
      "message": "I think that this solves the symptom, but not the underlying problem.  There\u0027s an overall problem with registration of threads with PJ.  Do we really need to allow infinite thread to access the PJ ice transport?  Why not have a ScheduledExecutor that does the jobs and other threads wait for it. After all, the ScheduledExecutor acts as a mutex just like now, but now only _one_ thread has to register to PJ per ice transport.  This can even be transformed into an async operation if the caller doesn\u0027t need the result immediately.",
      "parentUuid": "d2b5fb38_fa3d0790",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e92776b5_1710757c",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1073,
      "author": {
        "id": 856
      },
      "writtenOn": "2021-06-10T13:37:09Z",
      "side": 1,
      "message": "furthermore, the thread registration check might be broken as per PJSIP comment (to be honest, I did not check if this comment still holds or applies to us):\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n   /* If a thread descriptor has been registered before, just return it. */\n    if (pj_thread_local_get (thread_tls_id) !\u003d 0) {\n\t// 2006-02-26 bennylp:\n\t//  This wouldn\u0027t work in all cases!.\n\t//  If thread is created by external module (e.g. sound thread),\n\t//  thread may be reused while the pool used for the thread descriptor\n\t//  has been deleted by application.\n\t//*thread_ptr \u003d (pj_thread_t*)pj_thread_local_get (thread_tls_id);\n        //return PJ_SUCCESS;\n    }\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d",
      "parentUuid": "8a34cbcb_2ae2d4cf",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8b594f1_07d35443",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1138,
      "author": {
        "id": 856
      },
      "writtenOn": "2021-06-04T12:59:20Z",
      "side": 1,
      "message": "Shouldn\u0027t this method also register the calling thread?",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40df3b84_30a9b910",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1138,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-06-09T20:43:16Z",
      "side": 1,
      "message": "indeed",
      "parentUuid": "c8b594f1_07d35443",
      "revId": "f307d50c79a12fd4eb106f480ee8dfa848a14c60",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a",
      "unresolved": true
    }
  ]
}