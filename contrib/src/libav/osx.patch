diff --git a/Makefile b/Makefile
index cc016b3..183617e 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,7 @@
 include config.mak

 vpath %.c    $(SRC_PATH)
+vpath %.m    $(SRC_PATH)
 vpath %.h    $(SRC_PATH)
 vpath %.S    $(SRC_PATH)
 vpath %.asm  $(SRC_PATH)
@@ -26,6 +27,8 @@ IFLAGS     := -I. -I$(SRC_PATH)
 CPPFLAGS   := $(IFLAGS) $(CPPFLAGS)
 CFLAGS     += $(ECFLAGS)
 CCFLAGS     = $(CPPFLAGS) $(CFLAGS)
+OBJCFLAGS  += $(EOBJCFLAGS)
+OBJCCFLAGS  = $(CPPFLAGS) $(CFLAGS) $(OBJCFLAGS)
 ASFLAGS    := $(CPPFLAGS) $(ASFLAGS)
 YASMFLAGS  += $(IFLAGS:%=%/) -Pconfig.asm
 HOSTCCFLAGS = $(IFLAGS) $(HOSTCPPFLAGS) $(HOSTCFLAGS)
@@ -38,6 +41,7 @@ endef

 COMPILE_C = $(call COMPILE,CC)
 COMPILE_S = $(call COMPILE,AS)
+COMPILE_M = $(call COMPILE,OBJCC)
 COMPILE_HOSTC = $(call COMPILE,HOSTCC)

 %.o: %.c
@@ -46,6 +50,9 @@ COMPILE_HOSTC = $(call COMPILE,HOSTCC)
 %.o: %.S
    $(COMPILE_S)

+%.o: %.m
+	$(COMPILE_M)
+
 %_host.o: %.c
    $(COMPILE_HOSTC)

diff --git a/configure b/configure
index 13245f7..a293cc0 100755
--- a/configure
+++ b/configure
@@ -238,6 +238,7 @@ Toolchain options:
   --ar=AR                  use archive tool AR [$ar_default]
   --as=AS                  use assembler AS [$as_default]
   --cc=CC                  use C compiler CC [$cc_default]
+  --objcc=OCC              use ObjC compiler OCC [$cc_default]
   --dep-cc=DEPCC           use dependency generator DEPCC [$cc_default]
   --ld=LD                  use linker LD
   --pkg-config=PKGCONFIG   use pkg-config tool PKGCONFIG [$pkg_config_default]
@@ -250,6 +251,7 @@ Toolchain options:
   --host-libs=HLIBS        use libs HLIBS when linking for host
   --host-os=OS             compiler host OS [$target_os]
   --extra-cflags=ECFLAGS   add ECFLAGS to CFLAGS [$CFLAGS]
+  --extra-objcflags=FLAGS  add FLAGS to OBJCFLAGS [$CFLAGS]
   --extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [$LDFLAGS]
   --extra-ldexeflags=ELDFLAGS add ELDFLAGS to LDEXEFLAGS [$LDEXEFLAGS]
   --extra-libs=ELIBS       add ELIBS [$ELIBS]
@@ -683,6 +685,10 @@ add_asflags(){
     append ASFLAGS $($asflags_filter "$@")
 }

+add_objcflags(){
+    append OBJCFLAGS $($objcflags_filter "$@")
+}
+
 add_ldflags(){
     append LDFLAGS $($ldflags_filter "$@")
 }
@@ -737,6 +743,13 @@ check_cc(){
     check_cmd $cc $CPPFLAGS $CFLAGS "$@" $CC_C $(cc_o $TMPO) $TMPC
 }

+check_objcc(){
+    log check_objcc "$@"
+    cat > $TMPC
+    log_file $TMPC
+    check_cmd $objcc $CPPFLAGS $CFLAGS $OBJCFLAGS "$@" $OBJCC_C $(cc_o $TMPO) $TMPC
+}
+
 check_cpp(){
     log check_cpp "$@"
     cat > $TMPC
@@ -835,6 +848,19 @@ check_cflags(){
     test_cflags "$@" && add_cflags "$@"
 }

+test_objcflags(){
+    log test_cflags "$@"
+    set -- $($cflags_filter "$@")
+    check_objcc "$@" <<EOF
+int x;
+EOF
+}
+
+check_objcflags(){
+    log check_cflags "$@"
+    test_objcflags "$@" && add_objcflags "$@"
+}
+
 test_ldflags(){
     log test_ldflags "$@"
     check_ld "$@" <<EOF
@@ -1377,6 +1403,8 @@ HAVE_LIST_PUB="
 "

 HEADERS_LIST="
+    AVFoundation_AVFoundation_h
+    CoreVideo_CoreVideo_h
     alsa_asoundlib_h
     altivec_h
     arpa_inet_h
@@ -1640,6 +1668,7 @@ CMDLINE_SET="
     as
     build_suffix
     cc
+    objcc
     cpu
     cross_prefix
     dep_cc
@@ -1949,7 +1978,7 @@ zmbv_encoder_deps="zlib"
 dxva2_deps="dxva2api_h"
 vaapi_deps="va_va_h"
 vda_deps="VideoDecodeAcceleration_VDADecoder_h pthreads"
-vda_extralibs="-framework CoreFoundation -framework VideoDecodeAcceleration -framework QuartzCore"
+vda_extralibs="-framework CoreFoundation -framework CoreMedia -framework CoreVideo -framework VideoDecodeAcceleration -framework QuartzCore"
 vdpau_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"

 h263_vaapi_hwaccel_deps="vaapi"
@@ -2109,6 +2138,7 @@ xwma_demuxer_select="riffdec"
 # indevs / outdevs
 alsa_indev_deps="alsa_asoundlib_h snd_pcm_htimestamp"
 alsa_outdev_deps="alsa_asoundlib_h"
+avfoundation_indev_deps="AVFoundation_AVFoundation_h CoreVideo_CoreVideo_h"
 bktr_indev_deps_any="dev_bktr_ioctl_bt848_h machine_ioctl_bt848_h dev_video_bktr_ioctl_bt848_h dev_ic_bt8xx_h"
 dv1394_indev_deps="dv1394"
 dv1394_indev_select="dv_demuxer"
@@ -2285,6 +2315,9 @@ AS_O='-o $@'
 CC_C='-c'
 CC_E='-E -o $@'
 CC_O='-o $@'
+OBJCC_C='-c'
+OBJCC_E='-E -o $@'
+OBJCC_O='-o $@'
 LD_O='-o $@'
 LD_LIB='-l%'
 LD_PATH='-L'
@@ -2580,6 +2613,7 @@ esac

 ar_default="${cross_prefix}${ar_default}"
 cc_default="${cross_prefix}${cc_default}"
+occ_default="${cross_prefix}${occ_default}"
 nm_default="${cross_prefix}${nm_default}"
 pkg_config_default="${cross_prefix}${pkg_config_default}"
 ranlib="${cross_prefix}${ranlib}"
@@ -3032,16 +3066,22 @@ test -n "$cc_type" && enable $cc_type ||
     warn "Unknown C compiler $cc, unable to select optimal CFLAGS"

 : ${as_default:=$cc}
+: ${objcc_default:=$cc}
 : ${dep_cc_default:=$cc}
 : ${ld_default:=$cc}
 : ${host_ld_default:=$host_cc}
-set_default ar as dep_cc ld host_ld
+set_default ar as objcc dep_cc ld host_ld

 probe_cc as "$as"
 asflags_filter=$_flags_filter
 add_asflags $_flags $_cflags
 set_ccvars AS

+probe_cc objcc "$objcc"
+objcflags_filter=$_flags_filter
+add_objcflags $_flags $_cflags
+set_ccvars OBJC
+
 probe_cc ld "$ld"
 ldflags_filter=$_flags_filter
 add_ldflags $_flags $_ldflags
@@ -4268,6 +4308,15 @@ check_header linux/fb.h
 check_header linux/videodev2.h
 check_struct linux/videodev2.h "struct v4l2_frmivalenum" discrete

+check_header AVFoundation/AVFoundation.h &&
+    check_objcflags -fobjc-arc &&
+    add_extralibs -framework Foundation -framework AVFoundation || \
+    disable AVFoundation_AVFoundation_h
+
+check_header CoreVideo/CoreVideo.h &&
+    check_objcflags -fobjc-arc &&
+    add_extralibs -framework CoreVideo ||
+
 check_header sys/videoio.h

 check_func_headers "windows.h vfw.h" capCreateCaptureWindow "$vfwcap_indev_extralibs"
@@ -4689,6 +4738,7 @@ ARCH=$arch
 INTRINSICS=$intrinsics
 CC=$cc
 AS=$as
+OBJCC=$objcc
 LD=$ld
 DEPCC=$dep_cc
 DEPCCFLAGS=$DEPCCFLAGS \$(CPPFLAGS)
@@ -4704,9 +4754,13 @@ STRIP=$strip
 LN_S=$ln_s
 CPPFLAGS=$CPPFLAGS
 CFLAGS=$CFLAGS
+OBJCFLAGS=$OBJCFLAGS
 ASFLAGS=$ASFLAGS
 AS_C=$AS_C
 AS_O=$AS_O
+OBJCC_C=$OBJCC_C
+OBJCC_E=$OBJCC_E
+OBJCC_O=$OBJCC_O
 CC_C=$CC_C
 CC_E=$CC_E
 CC_O=$CC_O
diff --git a/libavdevice/Makefile b/libavdevice/Makefile
index 2a21832..682a39a 100644
--- a/libavdevice/Makefile
+++ b/libavdevice/Makefile
@@ -11,6 +11,7 @@ OBJS-$(CONFIG_ALSA_INDEV)                += alsa-audio-common.o \
                                             alsa-audio-dec.o
 OBJS-$(CONFIG_ALSA_OUTDEV)               += alsa-audio-common.o \
                                             alsa-audio-enc.o
+OBJS-$(CONFIG_AVFOUNDATION_INDEV)	 += avfoundation_dec.o
 OBJS-$(CONFIG_BKTR_INDEV)                += bktr.o
 OBJS-$(CONFIG_DV1394_INDEV)              += dv1394.o
 OBJS-$(CONFIG_FBDEV_INDEV)               += fbdev.o
diff --git a/libavdevice/alldevices.c b/libavdevice/alldevices.c
index 5dbe277..8439b5b 100644
--- a/libavdevice/alldevices.c
+++ b/libavdevice/alldevices.c
@@ -48,6 +48,7 @@ void avdevice_register_all(void)

     /* devices */
     REGISTER_INOUTDEV(ALSA,             alsa);
+    REGISTER_INDEV   (AVFOUNDATION,     avfoundation);
     REGISTER_INDEV   (BKTR,             bktr);
     REGISTER_INDEV   (DV1394,           dv1394);
     REGISTER_INDEV   (FBDEV,            fbdev);
diff --git a/libavdevice/avfoundation_dec.m b/libavdevice/avfoundation_dec.m
new file mode 100644
index 0000000..6b60782
--- /dev/null
+++ b/libavdevice/avfoundation_dec.m
@@ -0,0 +1,517 @@
+/*
+ * AVFoundation input device
+ * Copyright (c) 2015 Luca Barbato
+ *                    Alexandre Lision
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#import <AVFoundation/AVFoundation.h>
+#include <pthread.h>
+
+#include "libavformat/avformat.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+#include "libavformat/internal.h"
+#include "libavutil/time.h"
+#include "libavutil/mathematics.h"
+
+#include "avdevice.h"
+
+struct AVFPixelFormatSpec {
+    enum AVPixelFormat ff_id;
+    OSType avf_id;
+};
+
+static const struct AVFPixelFormatSpec avf_pixel_formats[] = {
+    { AV_PIX_FMT_MONOBLACK,    kCVPixelFormatType_1Monochrome },
+    { AV_PIX_FMT_RGB555BE,     kCVPixelFormatType_16BE555 },
+    { AV_PIX_FMT_RGB555LE,     kCVPixelFormatType_16LE555 },
+    { AV_PIX_FMT_RGB565BE,     kCVPixelFormatType_16BE565 },
+    { AV_PIX_FMT_RGB565LE,     kCVPixelFormatType_16LE565 },
+    { AV_PIX_FMT_RGB24,        kCVPixelFormatType_24RGB },
+    { AV_PIX_FMT_BGR24,        kCVPixelFormatType_24BGR },
+    { AV_PIX_FMT_ARGB,         kCVPixelFormatType_32ARGB },
+    { AV_PIX_FMT_BGRA,         kCVPixelFormatType_32BGRA },
+    { AV_PIX_FMT_ABGR,         kCVPixelFormatType_32ABGR },
+    { AV_PIX_FMT_RGBA,         kCVPixelFormatType_32RGBA },
+    { AV_PIX_FMT_BGR48BE,      kCVPixelFormatType_48RGB },
+    { AV_PIX_FMT_UYVY422,      kCVPixelFormatType_422YpCbCr8 },
+    { AV_PIX_FMT_YUVA444P,     kCVPixelFormatType_4444YpCbCrA8R },
+    { AV_PIX_FMT_YUVA444P16LE, kCVPixelFormatType_4444AYpCbCr16 },
+    { AV_PIX_FMT_YUV444P,      kCVPixelFormatType_444YpCbCr8 },
+    { AV_PIX_FMT_YUV422P16,    kCVPixelFormatType_422YpCbCr16 },
+    { AV_PIX_FMT_YUV422P10,    kCVPixelFormatType_422YpCbCr10 },
+    { AV_PIX_FMT_YUV444P10,    kCVPixelFormatType_444YpCbCr10 },
+    { AV_PIX_FMT_YUV420P,      kCVPixelFormatType_420YpCbCr8Planar },
+    { AV_PIX_FMT_NV12,         kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange },
+    { AV_PIX_FMT_YUYV422,      kCVPixelFormatType_422YpCbCr8_yuvs },
+#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
+    { AV_PIX_FMT_GRAY8,        kCVPixelFormatType_OneComponent8 },
+#endif
+    { AV_PIX_FMT_NONE, 0 }
+};
+
+typedef struct AVFoundationCaptureContext {
+    AVClass         *class;
+    int             list_devices;
+    CFTypeRef       session;        /** AVCaptureSession*/
+    char*           video_size;     /**< String describing video size,
+                                        set by a private option. */
+    enum AVPixelFormat pixel_format;   /**< Set by a private option. */
+    int             list_format;    /**< Set by a private option. */
+    char*           framerate;      /**< Set by a private option. */
+
+    int             video_stream_index;
+
+    int64_t         first_pts;
+    int             frames_captured;
+    int             audio_frames_captured;
+    pthread_mutex_t frame_lock;
+    pthread_cond_t  frame_wait_cond;
+
+    CFTypeRef           avf_delegate;   /** AVFFrameReceiver */
+    CFTypeRef           video_output;   /** AVCaptureVideoDataOutput */
+    CVImageBufferRef    current_frame;  /** CVImageBufferRef */
+
+} AVFoundationCaptureContext;
+
+#define AUDIO_DEVICES 1
+#define VIDEO_DEVICES 2
+#define ALL_DEVICES   AUDIO_DEVICES|VIDEO_DEVICES
+
+#define OFFSET(x) offsetof(AVFoundationCaptureContext, x)
+#define DEC AV_OPT_FLAG_DECODING_PARAM
+static const AVOption options[] = {
+    { "list_devices", "List available devices and exit", OFFSET(list_devices),  AV_OPT_TYPE_INT,    {.i64 = 0 },             0, INT_MAX, DEC, "list_devices" },
+    { "all",          "Show all the supported devices",  OFFSET(list_devices),  AV_OPT_TYPE_CONST,  {.i64 = ALL_DEVICES },   0, INT_MAX, DEC, "list_devices" },
+    { "audio",        "Show only the audio devices",     OFFSET(list_devices),  AV_OPT_TYPE_CONST,  {.i64 = AUDIO_DEVICES }, 0, INT_MAX, DEC, "list_devices" },
+    { "video",        "Show only the video devices",     OFFSET(list_devices),  AV_OPT_TYPE_CONST,  {.i64 = VIDEO_DEVICES }, 0, INT_MAX, DEC, "list_devices" },
+    { NULL },
+};
+
+
+static void list_capture_devices_by_type(AVFormatContext *s, NSString *type)
+{
+    NSArray *devices = [AVCaptureDevice devicesWithMediaType:type];
+
+    av_log(s, AV_LOG_INFO, "Type: %s\n", [type UTF8String]);
+    for (AVCaptureDevice *device in devices) {
+
+        av_log(s, AV_LOG_INFO, "uniqueID: %s\nname: %s\nformat:\n",
+               [[device uniqueID] UTF8String],
+               [[device localizedName] UTF8String]);
+
+        for (AVCaptureDeviceFormat *format in device.formats)
+            av_log(s, AV_LOG_INFO, "\t%s\n",
+                   [[NSString stringWithFormat:@"%@", format] UTF8String]);
+    }
+}
+
+static int avfoundation_list_capture_devices(AVFormatContext *s)
+{
+    AVFoundationCaptureContext *ctx = s->priv_data;
+
+    if (ctx->list_devices & AUDIO_DEVICES)
+        list_capture_devices_by_type(s, AVMediaTypeAudio);
+
+    if (ctx->list_devices & VIDEO_DEVICES)
+        list_capture_devices_by_type(s, AVMediaTypeVideo);
+
+    return AVERROR_EXIT;
+}
+
+static void lock_frames(AVFoundationCaptureContext* ctx)
+{
+    pthread_mutex_lock(&ctx->frame_lock);
+}
+
+static void unlock_frames(AVFoundationCaptureContext* ctx)
+{
+    pthread_mutex_unlock(&ctx->frame_lock);
+}
+
+/** FrameReceiver class - delegate for AVCaptureSession
+ */
+@interface AVFFrameReceiver : NSObject <AVCaptureVideoDataOutputSampleBufferDelegate>
+{
+    AVFoundationCaptureContext* _context;
+}
+
+- (id)initWithContext:(AVFoundationCaptureContext*)context;
+
+- (void)  captureOutput:(AVCaptureOutput *)captureOutput
+  didOutputSampleBuffer:(CMSampleBufferRef)videoFrame
+         fromConnection:(AVCaptureConnection *)connection;
+
+@end
+
+@implementation AVFFrameReceiver
+
+- (id)initWithContext:(AVFoundationCaptureContext*)context
+{
+    if (self = [super init]) {
+        _context = context;
+    }
+    return self;
+}
+
+- (void)  captureOutput:(AVCaptureOutput *)captureOutput
+  didOutputSampleBuffer:(CMSampleBufferRef)videoFrame
+         fromConnection:(AVCaptureConnection *)connection
+{
+    lock_frames(_context);
+
+    if (_context->current_frame != nil) {
+        CFRelease(_context->current_frame);
+    }
+
+    _context->current_frame = CFRetain(CMSampleBufferGetImageBuffer(videoFrame));
+
+    pthread_cond_signal(&_context->frame_wait_cond);
+
+    unlock_frames(_context);
+
+    ++_context->frames_captured;
+}
+
+@end
+
+NSString *pat = @"\\[[^\\].]*\\]";
+
+static int setup_stream(AVFormatContext *s, AVCaptureDevice *device)
+{
+    NSLog(@"setting up stream for device %@ ID\n", [device uniqueID]);
+
+    AVFoundationCaptureContext *ctx = s->priv_data;
+    NSError *__autoreleasing error = nil;
+    AVCaptureDeviceInput *input;
+    AVCaptureSession *session = (__bridge AVCaptureSession*)ctx->session;
+    input = [AVCaptureDeviceInput deviceInputWithDevice:device
+                                                  error:&error];
+    // add the input devices
+    if (!input) {
+        av_log(s, AV_LOG_ERROR, "%s\n",
+               [[error localizedDescription] UTF8String]);
+        return AVERROR_UNKNOWN;
+    }
+
+    if ([session canAddInput:input]) {
+        [session addInput:input];
+    } else {
+        av_log(s, AV_LOG_ERROR, "can't add video input to capture session\n");
+        return -1;
+    }
+
+    // add the output devices
+    if ([device hasMediaType:AVMediaTypeVideo]) {
+
+        AVCaptureVideoDataOutput* out = [[AVCaptureVideoDataOutput alloc] init];
+        if (!out) {
+            av_log(s, AV_LOG_ERROR, "Failed to init AV video output\n");
+            return -1;
+        }
+
+        [out setAlwaysDiscardsLateVideoFrames:YES];
+
+
+        // select pixel format
+        struct AVFPixelFormatSpec pxl_fmt_spec;
+        pxl_fmt_spec.ff_id = AV_PIX_FMT_NONE;
+
+        av_log(s, AV_LOG_ERROR, "Supported pixel formats:\n");
+        for (NSNumber *pxl_fmt in [out availableVideoCVPixelFormatTypes]) {
+            struct AVFPixelFormatSpec pxl_fmt_dummy;
+            pxl_fmt_dummy.ff_id = AV_PIX_FMT_NONE;
+            for (int i = 0; avf_pixel_formats[i].ff_id != AV_PIX_FMT_NONE; i++) {
+                if ([pxl_fmt intValue] == avf_pixel_formats[i].avf_id) {
+                    pxl_fmt_dummy = avf_pixel_formats[i];
+                    break;
+                }
+            }
+
+            if (pxl_fmt_dummy.ff_id != AV_PIX_FMT_NONE) {
+                av_log(s, AV_LOG_ERROR, "  %s: %d \n", av_get_pix_fmt_name(pxl_fmt_dummy.ff_id),
+                                                    pxl_fmt_dummy.avf_id);
+
+                // select first supported pixel format instead of user selected (or default) pixel format
+                if (pxl_fmt_spec.ff_id == AV_PIX_FMT_NONE) {
+                    pxl_fmt_spec = pxl_fmt_dummy;
+                }
+            }
+        }
+
+        // fail if there is no appropriate pixel format or print a warning about overriding the pixel format
+        if (pxl_fmt_spec.ff_id == AV_PIX_FMT_NONE) {
+            return 1;
+        } else {
+            av_log(s, AV_LOG_WARNING, "Overriding selected pixel format to use %s instead.\n",
+                   av_get_pix_fmt_name(pxl_fmt_spec.ff_id));
+        }
+        ctx->pixel_format          = pxl_fmt_spec.ff_id;
+        NSNumber     *pixel_format = [NSNumber numberWithUnsignedInt:pxl_fmt_spec.avf_id];
+        NSDictionary *capture_dict = [NSDictionary dictionaryWithObject:pixel_format
+                                                   forKey:(id)kCVPixelBufferPixelFormatTypeKey];
+        [out setVideoSettings:capture_dict];
+
+        AVFFrameReceiver* delegate = [[AVFFrameReceiver alloc] initWithContext:ctx];
+
+        dispatch_queue_t queue = dispatch_queue_create("avf_queue", NULL);
+        [out setSampleBufferDelegate:delegate queue:queue];
+
+        ctx->avf_delegate = (__bridge_retained CFTypeRef) delegate;
+
+        if ([session canAddOutput:out]) {
+            [session addOutput:out];
+            ctx->video_output = (__bridge_retained CFTypeRef) out;
+        } else {
+            av_log(s, AV_LOG_ERROR, "can't add video output to capture session\n");
+            return -1;
+        }
+        NSLog(@"%@", device);
+    }
+
+/**    if ([device hasMediaType:AVMediaTypeAudio]) {
+        AVCaptureAudioDataOutput *out =
+            [[AVCaptureAudioDataOutput alloc] init];
+
+        out.audioSettings = nil;
+        [session addOutput:out];
+
+        NSLog(@"%@ %@", device, out.audioSettings);
+    }
+*/
+    return 0;
+}
+
+static int get_video_config(AVFormatContext *s)
+{
+    AVFoundationCaptureContext *ctx = (AVFoundationCaptureContext*)s->priv_data;
+    CVImageBufferRef image_buffer;
+    CGSize image_buffer_size;
+    AVStream* stream = avformat_new_stream(s, NULL);
+
+    if (!stream) {
+        av_log(s, AV_LOG_ERROR, "Failed to create AVStream\n");
+        return -1;
+    }
+
+    // Take stream info from the first frame.
+    while (ctx->frames_captured < 1) {
+        CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, YES);
+    }
+
+    lock_frames(ctx);
+
+    ctx->video_stream_index = stream->index;
+
+    avpriv_set_pts_info(stream, 64, 1, 1000000);
+
+    image_buffer = ctx->current_frame;
+    image_buffer_size = CVImageBufferGetEncodedSize(image_buffer);
+
+    av_log(s, AV_LOG_ERROR, "Update stream info...\n");
+    stream->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;
+    stream->codec->codec_type = AVMEDIA_TYPE_VIDEO;
+    stream->codec->width      = (int)image_buffer_size.width;
+    stream->codec->height     = (int)image_buffer_size.height;
+    stream->codec->pix_fmt    = ctx->pixel_format;
+
+    CFRelease(ctx->current_frame);
+    ctx->current_frame = nil;
+
+    unlock_frames(ctx);
+
+    return 0;
+}
+
+static void destroy_context(AVFoundationCaptureContext* ctx)
+{
+    NSLog(@"Destroying context");
+
+    AVCaptureSession *session = (__bridge AVCaptureSession*)ctx->session;
+    [session stopRunning];
+
+    ctx->session = NULL;
+
+    pthread_mutex_destroy(&ctx->frame_lock);
+    pthread_cond_destroy(&ctx->frame_wait_cond);
+
+    if (ctx->current_frame) {
+        CFRelease(ctx->current_frame);
+    }
+}
+
+static int setup_default_stream(AVFormatContext *s)
+{
+    AVCaptureDevice *device;
+    for (NSString *type in @[AVMediaTypeVideo]) {
+        device = [AVCaptureDevice defaultDeviceWithMediaType:type];
+        if (device)
+            return setup_stream(s, device);
+    }
+
+    return -1;
+}
+
+static int setup_streams(AVFormatContext *s)
+{
+    NSLog(@"setting streams");
+    AVFoundationCaptureContext *ctx = s->priv_data;
+    int ret;
+    NSError *__autoreleasing error = nil;
+    NSArray *matches;
+    NSString *filename;
+    AVCaptureDevice *device;
+    NSRegularExpression *exp;
+
+    pthread_mutex_init(&ctx->frame_lock, NULL);
+    pthread_cond_init(&ctx->frame_wait_cond, NULL);
+
+    ctx->session = (__bridge_retained CFTypeRef)[[AVCaptureSession alloc] init];
+
+    if (s->filename[0] != '[') {
+        ret = setup_default_stream(s);
+    } else {
+        exp = [NSRegularExpression regularExpressionWithPattern:pat
+                                                        options:0
+                                                          error:&error];
+        if (!exp) {
+            av_log(s, AV_LOG_ERROR, "%s\n",
+                   [[error localizedDescription] UTF8String]);
+            return AVERROR(ENOMEM);
+        }
+
+        filename = [NSString stringWithFormat:@"%s", s->filename];
+        av_log(s, AV_LOG_INFO, "device name: %s\n",[filename UTF8String]);
+
+        matches = [exp matchesInString:filename options:0
+                                 range:NSMakeRange(0, [filename length])];
+
+        if (matches.count > 0) {
+            for (NSTextCheckingResult *match in matches) {
+                NSRange range = [match rangeAtIndex:0];
+                NSString *uniqueID = [filename substringWithRange:NSMakeRange(range.location + 1, range.length-2)];
+                av_log(s, AV_LOG_INFO, "opening device with ID: %s\n",[uniqueID UTF8String]);
+                if (!(device = [AVCaptureDevice deviceWithUniqueID:uniqueID])) {
+                    // report error
+                    av_log(s, AV_LOG_ERROR, "Device with name %s not found",[filename UTF8String]);
+                    return AVERROR(EINVAL);
+                }
+                ret = setup_stream(s, device);
+                if (ret < 0) {
+                    // avfoundation_close
+                    return ret;
+                }
+            }
+        } else {
+            av_log(s, AV_LOG_ERROR, "No matches for %s",[filename UTF8String]);
+            ret = setup_default_stream(s);
+        }
+    }
+
+    if (ret < 0) {
+        av_log(s, AV_LOG_ERROR, "No device could be added");
+        return ret;
+    }
+
+    av_log(s, AV_LOG_INFO, "Starting session!\n");
+    [(__bridge AVCaptureSession*)ctx->session startRunning];
+
+    av_log(s, AV_LOG_INFO, "Checking video config\n");
+    if (get_video_config(s)) {
+        destroy_context(ctx);
+        return AVERROR(EIO);
+    }
+
+    return 0;
+}
+
+
+static int avfoundation_read_header(AVFormatContext *s)
+{
+    AVFoundationCaptureContext *ctx = s->priv_data;
+    ctx->first_pts = av_gettime();
+    if (ctx->list_devices)
+        return avfoundation_list_capture_devices(s);
+
+    return setup_streams(s);
+}
+
+static int avfoundation_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    AVFoundationCaptureContext* ctx = (AVFoundationCaptureContext*)s->priv_data;
+
+    do {
+        lock_frames(ctx);
+
+        if (ctx->current_frame != nil) {
+            if (av_new_packet(pkt, (int)CVPixelBufferGetDataSize(ctx->current_frame)) < 0) {
+                return AVERROR(EIO);
+            }
+
+            pkt->pts = pkt->dts = av_rescale_q(av_gettime() - ctx->first_pts,
+                                               AV_TIME_BASE_Q,
+                                               (AVRational){1, 1000000});
+            pkt->stream_index  = ctx->video_stream_index;
+            pkt->flags        |= AV_PKT_FLAG_KEY;
+
+            CVPixelBufferLockBaseAddress(ctx->current_frame, 0);
+
+            void* data = CVPixelBufferGetBaseAddress(ctx->current_frame);
+            memcpy(pkt->data, data, pkt->size);
+
+            CVPixelBufferUnlockBaseAddress(ctx->current_frame, 0);
+            CFRelease(ctx->current_frame);
+            ctx->current_frame = nil;
+        } else {
+            pkt->data = NULL;
+            pthread_cond_wait(&ctx->frame_wait_cond, &ctx->frame_lock);
+        }
+
+        unlock_frames(ctx);
+    } while (!pkt->data);
+
+    return 0;
+}
+
+static int avfoundation_read_close(AVFormatContext *s)
+{
+    NSLog(@"Closing session...");
+    AVFoundationCaptureContext *ctx = s->priv_data;
+    destroy_context(ctx);
+    return 0;
+}
+
+static const AVClass avfoundation_class = {
+    .class_name = "AVFoundation AVCaptureDevice indev",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVInputFormat ff_avfoundation_demuxer = {
+    .name           = "avfoundation",
+    .long_name      = NULL_IF_CONFIG_SMALL("AVFoundation AVCaptureDevice grab"),
+    .priv_data_size = sizeof(AVFoundationCaptureContext),
+    .read_header    = avfoundation_read_header,
+    .read_packet    = avfoundation_read_packet,
+    .read_close     = avfoundation_read_close,
+    .flags          = AVFMT_NOFILE,
+    .priv_class     = &avfoundation_class,
+};
