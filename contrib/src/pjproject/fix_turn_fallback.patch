--- a/pjnath/src/pjnath/turn_session.c	2016-09-19 18:21:09.073614574 -0400
+++ b/pjnath/src/pjnath/turn_session.c	2016-09-19 18:21:30.648631620 -0400
@@ -653,3 +653,3 @@
 
-	cnt = PJ_TURN_MAX_DNS_SRV_CNT;
+	cnt = 1;
 	ai = (pj_addrinfo*)
--- a/pjnath/src/pjnath/ice_strans.c	2016-09-19 18:36:04.180104330 -0400
+++ b/pjnath/src/pjnath/ice_strans.c	2016-09-19 18:37:10.614136809 -0400
@@ -1304,2 +1304,5 @@
 
+		if (!comp->turn[n].sock)
+			continue;
+
 	    /* Gather remote addresses for this component */
@@ -2013,4 +2016,21 @@
 	    if (comp->ice_st->state < PJ_ICE_STRANS_STATE_READY) {
-		sess_fail(comp->ice_st, PJ_ICE_STRANS_OP_INIT,
-			  "TURN allocation failed", info.last_status);
+			PJ_LOG(4,(comp->ice_st->obj_name,
+					  "TURN allocation failed, disable the associated candidate"));
+			pj_ice_sess_cand *cand = NULL;
+			unsigned i;
+			/* Wait until initialization completes */
+			pj_grp_lock_acquire(comp->ice_st->grp_lock);
+			/* Find relayed candidate in the component */
+			for (i=0; i<comp->cand_cnt; ++i) {
+				if (comp->cand_list[i].type == PJ_ICE_CAND_TYPE_RELAYED &&
+					comp->cand_list[i].transport_id == data->transport_id) {
+					cand = &comp->cand_list[i];
+					break;
+				}
+			}
+			pj_grp_lock_release(comp->ice_st->grp_lock);
+			pj_assert(cand != NULL);
+			// Make session init succeed but disable this TURN server to be used
+			cand->status = PJNATH_ESTUNTIMEDOUT;
+			sess_init_update(comp->ice_st);
 	    } else if (comp->turn[tp_idx].err_cnt > 1) {
