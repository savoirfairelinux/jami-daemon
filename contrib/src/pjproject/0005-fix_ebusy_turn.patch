From a9a8cc6b62dc08e34ed4f7893a822809dd051572 Mon Sep 17 00:00:00 2001
From: jrun <darwinskernel@gmail.com>
Date: Wed, 19 Feb 2020 15:17:38 -0500
Subject: [PATCH] fix_ebusy_turn

---
 pjnath/include/pjnath/turn_session.h | 65 +++++++++++++++++++
 pjnath/include/pjnath/turn_sock.h    | 27 ++++++++
 pjnath/src/pjnath/turn_session.c     | 24 +++++--
 pjnath/src/pjnath/turn_sock.c        | 96 ++++++++++++++++++++++++++++
 4 files changed, 207 insertions(+), 5 deletions(-)

diff --git a/pjnath/include/pjnath/turn_session.h b/pjnath/include/pjnath/turn_session.h
index 956f57bf0..f546d7e18 100644
--- a/pjnath/include/pjnath/turn_session.h
+++ b/pjnath/include/pjnath/turn_session.h
@@ -254,6 +254,35 @@ typedef struct pj_turn_session_cb
 			       const pj_sockaddr_t *dst_addr,
 			       unsigned addr_len);
 
+    /**
+     * This callback will be called by the TURN session whenever it
+     * needs to send outgoing message. Since the TURN session doesn't
+     * have a socket on its own, this callback must be implemented.
+     *
+     * The difference with on_send_pkt is that this function returns
+     * the size of the packet actually sent to predict when a busy will
+     * occurs. Indeed, activesock send the data asynchronously. When the
+     * data are actually sent, on_data_sent will be triggered.
+     *
+     * @param sess		The TURN session.
+     * @param pkt		The packet/data to be sent.
+     * @param pkt_len		Length of the packet/data.
+     * @param dst_addr		Destination address of the packet.
+     * @param addr_len		Length of the destination address.
+     * @param send_size		Length sent.
+     * @param original_size	The length of the packet without the HEADER
+     *
+     * @return			The callback should return the status of the
+     *				send operation.
+     */
+    pj_status_t (*on_send_pkt2)(pj_turn_session *sess,
+                                const pj_uint8_t *pkt,
+                                unsigned pkt_len,
+                                const pj_sockaddr_t *dst_addr,
+                                unsigned addr_len,
+                                unsigned* sent_size,
+                                unsigned original_size);
+
     /**
      * This callback will be called by the TURN session whenever it
      * needs to send outgoing STUN requests/messages for TURN signalling
@@ -798,6 +827,42 @@ PJ_DECL(pj_status_t) pj_turn_session_sendto(pj_turn_session *sess,
 					    const pj_sockaddr_t *peer_addr,
 					    unsigned addr_len);
 
+/**
+ * Send a data to the specified peer address via the TURN relay. This
+ * function will encapsulate the data as STUN Send Indication or TURN
+ * ChannelData packet and send the message to the TURN server. The TURN
+ * server then will send the data to the peer.
+ *
+ * The allocation (pj_turn_session_alloc()) must have been successfully
+ * created before application can relay any data.
+ *
+ * Since TURN session is transport independent, this function will
+ * ultimately call \a on_send_pkt() callback to request the application
+ * to actually send the packet containing the data to the TURN server.
+ *
+ * The difference with pj_turn_session_sendto is that this function returns
+ * the size of the packet actually sent to predict when a busy will
+ * occurs. Indeed, activesock send the data asynchronously. When the
+ * data are actually sent, on_data_sent will be triggered.
+ *
+ * @param sess		The TURN client session.
+ * @param pkt		The data/packet to be sent to peer.
+ * @param pkt_len	Length of the data.
+ * @param peer_addr	The remote peer address (the ultimate destination
+ *			of the data, and not the TURN server address).
+ * @param addr_len	Length of the address.
+ * @param sent		The size of the packet actually sent
+ *
+ * @return		PJ_SUCCESS if the operation has been successful,
+ *			or the appropriate error code on failure.
+ */
+PJ_DECL(pj_status_t) pj_turn_session_sendto2(pj_turn_session *sess,
+                                             const pj_uint8_t *pkt,
+                                             unsigned pkt_len,
+                                             const pj_sockaddr_t *peer_addr,
+                                             unsigned addr_len,
+                                             unsigned *sent);
+
 /**
  * Optionally establish channel binding for the specified a peer address.
  * This function will assign a unique channel number for the peer address
diff --git a/pjnath/include/pjnath/turn_sock.h b/pjnath/include/pjnath/turn_sock.h
index 35388809f..05b5cafbe 100644
--- a/pjnath/include/pjnath/turn_sock.h
+++ b/pjnath/include/pjnath/turn_sock.h
@@ -623,6 +623,33 @@ PJ_DECL(pj_status_t) pj_turn_sock_bind_channel(pj_turn_sock *turn_sock,
 					       const pj_sockaddr_t *peer,
 					       unsigned addr_len);
 
+/**
+ * Send a data to the specified peer address via the TURN relay. This
+ * function will encapsulate the data as STUN Send Indication or TURN
+ * ChannelData packet and send the message to the TURN server. The TURN
+ * server then will send the data to the peer.
+ *
+ * The allocation (pj_turn_sock_alloc()) must have been successfully
+ * created before application can relay any data.
+ *
+ * @param turn_sock	The TURN transport instance.
+ * @param pkt		The data/packet to be sent to peer.
+ * @param pkt_len	Length of the data.
+ * @param peer_addr	The remote peer address (the ultimate destination
+ *			of the data, and not the TURN server address).
+ * @param addr_len	Length of the address.
+ * @param sent	    Size actually sent.
+ *
+ * @return		PJ_SUCCESS if the operation has been successful,
+ *			or the appropriate error code on failure.
+ */
+PJ_DECL(pj_status_t) pj_turn_sock_sendto2(pj_turn_sock *turn_sock,
+                                          const pj_uint8_t *pkt,
+                                          unsigned pkt_len,
+                                          const pj_sockaddr_t *peer_addr,
+                                          unsigned addr_len,
+                                          unsigned* sent);
+
 /**
  *  Check if peer is a dataconn
  *
diff --git a/pjnath/src/pjnath/turn_session.c b/pjnath/src/pjnath/turn_session.c
index 3a7df799a..374b70b59 100644
--- a/pjnath/src/pjnath/turn_session.c
+++ b/pjnath/src/pjnath/turn_session.c
@@ -975,11 +975,23 @@ on_error:
 /**
  * Relay data to the specified peer through the session.
  */
+
 PJ_DEF(pj_status_t) pj_turn_session_sendto( pj_turn_session *sess,
 					    const pj_uint8_t *pkt,
 					    unsigned pkt_len,
 					    const pj_sockaddr_t *addr,
 					    unsigned addr_len)
+{
+	unsigned sent;
+	return pj_turn_session_sendto2(sess, pkt, pkt_len, addr, addr_len, &sent);
+}
+
+PJ_DEF(pj_status_t) pj_turn_session_sendto2(pj_turn_session *sess,
+                                            const pj_uint8_t *pkt,
+                                            unsigned pkt_len,
+                                            const pj_sockaddr_t *addr,
+                                            unsigned addr_len,
+                                            unsigned *sent)
 {
     struct ch_t *ch;
     struct perm_t *perm;
@@ -1016,7 +1028,7 @@ PJ_DEF(pj_status_t) pj_turn_session_sendto( pj_turn_session *sess,
 
     /* If peer connection is TCP (RFC 6062), send it directly */
     if (sess->alloc_param.peer_conn_type == PJ_TURN_TP_TCP) {
-	status = sess->cb.on_send_pkt(sess, pkt, pkt_len, addr, addr_len);
+	status = sess->cb.on_send_pkt2(sess, pkt, pkt_len, addr, addr_len, sent, pkt_len);
 	goto on_return;
     }
 
@@ -1044,9 +1056,10 @@ PJ_DEF(pj_status_t) pj_turn_session_sendto( pj_turn_session *sess,
 
 	pj_assert(sess->srv_addr != NULL);
 
-	status = sess->cb.on_send_pkt(sess, sess->tx_pkt, total_len,
+	status = sess->cb.on_send_pkt2(sess, sess->tx_pkt, total_len,
 				      sess->srv_addr,
-				      pj_sockaddr_get_len(sess->srv_addr));
+				      pj_sockaddr_get_len(sess->srv_addr),
+					  sent, pkt_len);
 
     } else {
 	/* Use Send Indication. */
@@ -1084,10 +1097,11 @@ PJ_DEF(pj_status_t) pj_turn_session_sendto( pj_turn_session *sess,
 	    goto on_return;
 
 	/* Send the Send Indication */
-	status = sess->cb.on_send_pkt(sess, sess->tx_pkt, 
+	status = sess->cb.on_send_pkt2(sess, sess->tx_pkt, 
 				      (unsigned)send_ind_len,
 				      sess->srv_addr,
-				      pj_sockaddr_get_len(sess->srv_addr));
+				      pj_sockaddr_get_len(sess->srv_addr),
+					  sent, pkt_len);
     }
 
 on_return:
diff --git a/pjnath/src/pjnath/turn_sock.c b/pjnath/src/pjnath/turn_sock.c
index a6e192e9f..88f61b7e2 100644
--- a/pjnath/src/pjnath/turn_sock.c
+++ b/pjnath/src/pjnath/turn_sock.c
@@ -100,6 +100,10 @@ struct pj_turn_sock
     /* Data connection, when peer_conn_type==PJ_TURN_TP_TCP (RFC 6062) */
     unsigned		 data_conn_cnt;
     tcp_data_conn_t	 data_conn[PJ_TURN_MAX_TCP_CONN_CNT];
+
+    /* The following variables are used by the on_data_sent callback */
+    unsigned current_pkt_len;
+    unsigned current_body_len;
 };
 
 
@@ -116,6 +120,13 @@ static pj_status_t turn_on_stun_send_pkt(pj_turn_session *sess,
 				    	 unsigned pkt_len,
 				    	 const pj_sockaddr_t *dst_addr,
 				    	 unsigned dst_addr_len);
+static pj_status_t turn_on_send_pkt2(pj_turn_session *sess,
+                                     const pj_uint8_t *pkt,
+                                     unsigned pkt_len,
+                                     const pj_sockaddr_t *dst_addr,
+                                     unsigned dst_addr_len,
+                                     unsigned *sent,
+                                     unsigned body_len);
 static void turn_on_channel_bound(pj_turn_session *sess,
 				  const pj_sockaddr_t *peer_addr,
 				  unsigned addr_len,
@@ -345,6 +356,7 @@ PJ_DEF(pj_status_t) pj_turn_sock_create(pj_stun_config *cfg,
     pj_bzero(&sess_cb, sizeof(sess_cb));
     sess_cb.on_send_pkt = &turn_on_send_pkt;
     sess_cb.on_stun_send_pkt = &turn_on_stun_send_pkt;
+	sess_cb.on_send_pkt2 = &turn_on_send_pkt2;
     sess_cb.on_channel_bound = &turn_on_channel_bound;
     sess_cb.on_rx_data = &turn_on_rx_data;
     sess_cb.on_state = &turn_on_state;
@@ -653,6 +665,22 @@ PJ_DEF(pj_status_t) pj_turn_sock_sendto( pj_turn_sock *turn_sock,
 				  addr, addr_len);
 }
 
+PJ_DEF(pj_status_t) pj_turn_sock_sendto2( pj_turn_sock *turn_sock,
+                                          const pj_uint8_t *pkt,
+                                          unsigned pkt_len,
+                                          const pj_sockaddr_t *addr,
+                                          unsigned addr_len,
+                                          unsigned *sent)
+{
+    PJ_ASSERT_RETURN(turn_sock && addr && addr_len, PJ_EINVAL);
+
+    if (turn_sock->sess == NULL)
+        return PJ_EINVALIDOP;
+
+    return pj_turn_session_sendto2(turn_sock->sess, pkt, pkt_len,
+                                   addr, addr_len, sent);
+}
+
 /*
  * Bind a peer address to a channel number.
  */
@@ -1041,6 +1069,74 @@ static pj_status_t turn_on_send_pkt(pj_turn_session *sess,
     		    dst_addr, dst_addr_len);
 }
 
+static pj_status_t turn_on_send_pkt2(pj_turn_session *sess,
+                                     const pj_uint8_t *pkt,
+                                     unsigned pkt_len,
+                                     const pj_sockaddr_t *dst_addr,
+                                     unsigned dst_addr_len,
+                                     unsigned *sent,
+                                     unsigned body_len)
+{
+    *sent = pkt_len;
+    pj_turn_sock *turn_sock = (pj_turn_sock*)pj_turn_session_get_user_data(sess);
+    pj_status_t status = PJ_SUCCESS;
+
+    pj_ssize_t len = pkt_len;
+    turn_sock->current_body_len = body_len;
+    turn_sock->current_pkt_len = pkt_len;
+
+    if (turn_sock == NULL || turn_sock->is_destroying) {
+        /* We've been destroyed */
+        // https://trac.pjsip.org/repos/ticket/1316
+        //pj_assert(!"We should shutdown gracefully");
+        return PJ_EINVALIDOP;
+    }
+
+    if (turn_sock->conn_type == PJ_TURN_TP_UDP) {
+        status = pj_activesock_sendto(turn_sock->active_sock,
+                                      &turn_sock->send_key, pkt, &len, 0,
+                                      dst_addr, dst_addr_len);
+    } else if (turn_sock->alloc_param.peer_conn_type == PJ_TURN_TP_TCP) {
+        pj_turn_session_info info;
+        pj_turn_session_get_info(turn_sock->sess, &info);
+        if (pj_sockaddr_cmp(&info.server, dst_addr) == 0) {
+            /* Destination address is TURN server */
+            status = pj_activesock_send(turn_sock->active_sock,
+                                        &turn_sock->send_key, pkt, &len, 0);
+        } else {
+            /* Destination address is peer, lookup data connection */
+            unsigned i;
+
+            status = PJ_ENOTFOUND;
+            for (i=0; i < PJ_TURN_MAX_TCP_CONN_CNT; ++i) {
+                tcp_data_conn_t *conn = &turn_sock->data_conn[i];
+                if (conn->state < DATACONN_STATE_CONN_BINDING)
+                    continue;
+                if (pj_sockaddr_cmp(&conn->peer_addr, dst_addr) == 0) {
+                    status = pj_activesock_send(conn->asock,
+                                                &conn->send_key,
+                                                pkt, &len, 0);
+                    break;
+                }
+            }
+        }
+    } else {
+        status = pj_activesock_send(turn_sock->active_sock,
+                                    &turn_sock->send_key, pkt, &len, 0);
+    }
+
+    if (status != PJ_SUCCESS && status != PJ_EPENDING) {
+        show_err(turn_sock, "socket send()", status);
+    }
+
+    // Remove header from sent size.
+    // The application only wants to know if the packet is actually sent.
+    unsigned header_len = pkt_len - body_len;
+    *sent = (len > header_len)? (len - header_len) : 0;
+
+    return status;
+ }
+
 static pj_status_t turn_on_stun_send_pkt(pj_turn_session *sess,
 				    	 const pj_uint8_t *pkt,
 				    	 unsigned pkt_len,
-- 
2.30.2

