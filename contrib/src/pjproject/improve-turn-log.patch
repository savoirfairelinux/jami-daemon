 pjnath/src/pjnath/ice_session.c | 64 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------
 pjnath/src/pjnath/ice_strans.c  |  9 ++++++---
 2 files changed, 64 insertions(+), 9 deletions(-)

diff --git a/pjnath/src/pjnath/ice_session.c b/pjnath/src/pjnath/ice_session.c
index ba10d42ed..15ad99b19 100644
--- a/pjnath/src/pjnath/ice_session.c
+++ b/pjnath/src/pjnath/ice_session.c
@@ -1718,9 +1718,17 @@ static void on_tcp_connect_timeout(pj_ice_sess* ice)
 		first_found = PJ_TRUE;
 		if (*ice->cb.close_tcp_connection)
 		    (*ice->cb.close_tcp_connection)(ice, &ice->clist, i);
-
-		check_set_state(ice, check,
-		    PJ_ICE_SESS_CHECK_STATE_FAILED, PJ_ECANCELLED);
+		if (check->rcand->type == PJ_ICE_CAND_TYPE_RELAYED) {
+			char raddr[PJ_INET6_ADDRSTRLEN + 10];
+			PJ_LOG(1, (ice->obj_name,
+				  "=> Connection to TURN (%s) timeout",
+				  pj_sockaddr_print(&check->rcand->addr, raddr, sizeof(raddr), 3)));
+			check_set_state(ice, check,
+				PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY, PJ_ECANCELLED);
+		} else {
+			check_set_state(ice, check,
+				PJ_ICE_SESS_CHECK_STATE_FAILED, PJ_ECANCELLED);
+		}
 		on_check_complete(ice, check);
 	    }
 	}
@@ -1730,7 +1738,7 @@ static void on_tcp_connect_timeout(pj_ice_sess* ice)
 	/* Reschedule */
 	pj_time_val delay = {
 	    .sec  = 0,
-	    .msec = 1500
+	    .msec = 3000
 	};
 	pj_time_val_normalize(&delay);
 	pj_timer_heap_schedule_w_grp_lock(ice->stun_cfg.timer_heap,
@@ -2032,7 +2040,7 @@ static pj_status_t perform_check(pj_ice_sess *ice,
             } else {
                 pj_time_val delay = {
                     .sec  = 0,
-                    .msec = 1500,
+                    .msec = 3000,
                 };
                 pj_time_val_normalize(&delay);
                 pj_timer_heap_schedule_w_grp_lock(ice->stun_cfg.timer_heap,
@@ -2514,11 +2522,22 @@ void ice_sess_on_peer_connection(pj_ice_sess *ice,
 	 * In this case, we can try to reconnect a bit after and this until the check
 	 * reached its timeout.
 	 */
+
+	char raddr[PJ_INET6_ADDRSTRLEN + 10];
+	PJ_LOG(1, (ice->obj_name,
+			"=> Connection to TURN (%s) needs retry (status %u)",
+			pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 3), status));
 	check->state = PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY;
 	check_set_state(ice, check,PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY,
 			status);
 		return;
     } else if (status != PJ_SUCCESS) {
+	if (rcand->type == PJ_ICE_CAND_TYPE_RELAYED) {
+		char raddr[PJ_INET6_ADDRSTRLEN + 10];
+		PJ_LOG(1, (ice->obj_name,
+				"=> Connection to TURN (%s) needs retry (status %u)",
+				pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 3), status));
+	}
 	check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED, status);
 	on_check_complete(ice, check);
 	return;
@@ -2564,12 +2583,23 @@ void ice_sess_on_peer_connection(pj_ice_sess *ice,
 		 * In this case, we can try to reconnect a bit after and this until the check
 		 * reached its timeout.
 		 */
+		char raddr[PJ_INET6_ADDRSTRLEN + 10];
+		PJ_LOG(1, (ice->obj_name,
+				"=> STUN send message to TURN (%s) needs retry (status %u)",
+				pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 3), status));
 		check_set_state(ice, check,PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY,
 				status_send_msg);
     } else if (status_send_msg == PJ_EBUSY /* EBUSY */) {
 		check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_NEEDS_FIRST_PACKET,
 				status_send_msg);
     } else if (status_send_msg != PJ_SUCCESS) {
+
+		if (rcand->type == PJ_ICE_CAND_TYPE_RELAYED) {
+			char raddr[PJ_INET6_ADDRSTRLEN + 10];
+			PJ_LOG(1, (ice->obj_name,
+					"=> STUN send message to TURN (%s) failed with status %u",
+					pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 3), status));
+		}
 		check->tdata = NULL;
 		pjnath_perror(ice->obj_name, "Error sending STUN request", status_send_msg);
 		pj_log_pop_indent();
@@ -2602,6 +2632,11 @@ void ice_sess_on_peer_reset_connection(pj_ice_sess *ice,
 
     const pj_ice_sess_cand *rcand = check->rcand;
     if (rcand->type == PJ_ICE_CAND_TYPE_RELAYED) {
+	char raddr[PJ_INET6_ADDRSTRLEN + 10];
+	PJ_LOG(1, (ice->obj_name,
+			"=> Connection to TURN (%s) is reseted",
+			pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 3)));
+
 	check->state = PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY;
 	check_set_state(ice, check,
 			PJ_ICE_SESS_CHECK_STATE_NEEDS_RETRY, 120104);
@@ -2658,6 +2693,8 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
     clist = msg_data->data.req.clist;
     check = &clist->checks[msg_data->data.req.ckid];
     
+	PJ_LOG(1, (ice->obj_name,
+			"=> on_stun_request_complete check %u with status %u", msg_data->data.req.ckid, status));
 
     /* Mark STUN transaction as complete */
     pj_assert(tdata == check->tdata);
@@ -2668,6 +2705,8 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
     if (ice->is_destroying) {
 	/* Not sure if this is possible but just in case */
 	pj_grp_lock_release(ice->grp_lock);
+	PJ_LOG(1, (ice->obj_name,
+			"=> on_stun_request_complete is destroying"));
 	return;
     }
 
@@ -2954,6 +2993,9 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
     const pj_sockaddr_t *source_addr = src_addr;
     unsigned source_addr_len = src_addr_len;
     pj_status_t status;
+	
+	PJ_LOG(1, (ice->obj_name,
+			"=> on_stun_rx_request, start"));
 
     PJ_UNUSED_ARG(pkt);
     PJ_UNUSED_ARG(pkt_len);
@@ -3156,6 +3198,10 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
 	pj_list_push_back(&ice->early_check, rcheck);
     } else {
 	/* Handle this check */
+	
+	PJ_LOG(1, (ice->obj_name,
+			"=> on_stun_rx_request, before handle incoming check"));
+
 	handle_incoming_check(ice, rcheck);
     }
 
@@ -3294,6 +3340,12 @@ static void handle_incoming_check(pj_ice_sess *ice,
     if (i != ice->clist.count) {
 	pj_ice_sess_check *c = &ice->clist.checks[i];
 
+
+	char raddr[PJ_INET6_ADDRSTRLEN + 10];
+	PJ_LOG(1, (ice->obj_name,
+			"=> Check incoming cand %d (%s) timeout. state: %u", i,
+			pj_sockaddr_print(&c->rcand->addr, raddr, sizeof(raddr), 3), c->state));
+
 	/* If USE-CANDIDATE is present, set nominated flag 
 	 * Note: DO NOT overwrite nominated flag if one is already set.
 	 */
@@ -3342,7 +3394,7 @@ static void handle_incoming_check(pj_ice_sess *ice,
 			/* Update valid check and nominated check for the component */
 			update_comp_check(ice, vc->lcand->comp_id, vc);
 
-			LOG5((ice->obj_name, "Valid check %s is nominated", 
+			LOG5((ice->obj_name, "Valid check %s is nominated",
 			      dump_check(ice->tmp.txt, sizeof(ice->tmp.txt), 
 					 &ice->valid_list, vc)));
 		    }
diff --git a/pjnath/src/pjnath/ice_strans.c b/pjnath/src/pjnath/ice_strans.c
index 82175e9e8..08e9216d0 100644
--- a/pjnath/src/pjnath/ice_strans.c
+++ b/pjnath/src/pjnath/ice_strans.c
@@ -407,6 +407,9 @@ static pj_status_t add_update_turn(pj_ice_strans *ice_st,
 	}
     }
 
+
+    PJ_LOG(1,(ice_st->obj_name, "add_update_turn"));
+
     /* If candidate is found, invalidate it first */
     if (cand) {
 	cand->status = PJ_EPENDING;
@@ -506,7 +509,7 @@ static pj_status_t add_update_turn(pj_ice_strans *ice_st,
 	comp->cand_cnt++;
     }
 
-    PJ_LOG(4,(ice_st->obj_name,
+    PJ_LOG(1,(ice_st->obj_name,
 		  "Comp %d/%d: TURN relay candidate (tpid=%d) "
 		  "waiting for allocation",
 		  comp->comp_id, comp->cand_cnt-1, cand->transport_id));
@@ -2890,7 +2893,7 @@ static void turn_on_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state,
     comp = data->comp;
     tp_idx = GET_TP_IDX(data->transport_id);
 
-    PJ_LOG(5,(comp->ice_st->obj_name, "TURN client state changed %s --> %s",
+    PJ_LOG(1,(comp->ice_st->obj_name, "TURN client state changed %s --> %s",
 	      pj_turn_state_name(old_state), pj_turn_state_name(new_state)));
     pj_log_push_indent();
 
@@ -2959,7 +2962,7 @@ static void turn_on_state(pj_turn_sock *turn_sock, pj_turn_state_t old_state,
 	}
 	*/
 
-	PJ_LOG(4,(comp->ice_st->obj_name,
+	PJ_LOG(1,(comp->ice_st->obj_name,
 		  "Comp %d/%d: TURN allocation (tpid=%d) complete, "
 		  "relay address is %s",
 		  comp->comp_id, cand_idx, cand->transport_id,
