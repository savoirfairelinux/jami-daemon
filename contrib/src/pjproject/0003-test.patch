 pjnath/include/pjnath/config.h  |  32 ++--
 pjnath/src/pjnath/ice_session.c | 512 ++++++++++++++++++++++++++++-----------------------
 2 files changed, 293 insertions(+), 251 deletions(-)

diff --git a/pjnath/include/pjnath/config.h b/pjnath/include/pjnath/config.h
index 76a7f793..548a7cce 100644
--- a/pjnath/include/pjnath/config.h
+++ b/pjnath/include/pjnath/config.h
@@ -1,5 +1,5 @@
 /* $Id$ */
-/*
+/*
  * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)
  * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
  *
@@ -15,7 +15,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef __PJNATH_CONFIG_H__
 #define __PJNATH_CONFIG_H__
@@ -66,9 +66,9 @@

 /**
  * The default initial STUN round-trip time estimation (the RTO value
- * in RFC 3489-bis), in miliseconds.
- * This value is used to control the STUN request
- * retransmit time. The initial value of retransmission interval
+ * in RFC 3489-bis), in miliseconds.
+ * This value is used to control the STUN request
+ * retransmit time. The initial value of retransmission interval
  * would be set to this value, and will be doubled after each
  * retransmission.
  */
@@ -79,7 +79,7 @@

 /**
  * The STUN transaction timeout value, in miliseconds.
- * After the last retransmission is sent and if no response is received
+ * After the last retransmission is sent and if no response is received
  * after this time, the STUN transaction will be considered to have failed.
  *
  * The default value is 16x RTO (as per RFC 3489-bis).
@@ -202,8 +202,8 @@


 /**
- * Number of seconds to refresh the permission/channel binding before the
- * permission/channel binding expires. This value should be greater than
+ * Number of seconds to refresh the permission/channel binding before the
+ * permission/channel binding expires. This value should be greater than
  * PJ_TURN_PERM_TIMEOUT setting.
  */
 #ifndef PJ_TURN_REFRESH_SEC_BEFORE
@@ -212,7 +212,7 @@


 /**
- * The TURN session timer heart beat interval. When this timer occurs, the
+ * The TURN session timer heart beat interval. When this timer occurs, the
  * TURN session will scan all the permissions/channel bindings to see which
  * need to be refreshed.
  */
@@ -279,7 +279,7 @@
  * the maximum number of components (PJ_ICE_MAX_COMP) value.
  */
 #ifndef PJ_ICE_COMP_BITS
-#   define PJ_ICE_COMP_BITS			    2
+#   define PJ_ICE_COMP_BITS			    4
 #endif


@@ -311,10 +311,10 @@
 /**
  * The number of bits to represent ICE candidate's local preference. The
  * local preference is used to specify preference among candidates with
- * the same type, and ICE draft suggests 65535 as the default local
- * preference, which means we need 16 bits to represent the value. But
+ * the same type, and ICE draft suggests 65535 as the default local
+ * preference, which means we need 16 bits to represent the value. But
  * since we don't have the facility to specify local preference, we'll
- * just disable this feature and let the preference sorted by the
+ * just disable this feature and let the preference sorted by the
  * type only.
  *
  * Default: 0
@@ -345,15 +345,15 @@


 /**
- * According to ICE Section 8.2. Updating States, if an In-Progress pair in
- * the check list is for the same component as a nominated pair, the agent
+ * According to ICE Section 8.2. Updating States, if an In-Progress pair in
+ * the check list is for the same component as a nominated pair, the agent
  * SHOULD cease retransmissions for its check if its pair priority is lower
  * than the lowest priority nominated pair for that component.
  *
  * If a higher priority check is In Progress, this rule would cause that
  * check to be performed even when it most likely will fail.
  *
- * The macro here controls if ICE session should cancel all In Progress
+ * The macro here controls if ICE session should cancel all In Progress
  * checks for the same component regardless of its priority.
  *
  * Default: 1 (yes, cancel all)
diff --git a/pjnath/src/pjnath/ice_session.c b/pjnath/src/pjnath/ice_session.c
index 80681e5a..e5af1594 100644
--- a/pjnath/src/pjnath/ice_session.c
+++ b/pjnath/src/pjnath/ice_session.c
@@ -1,5 +1,5 @@
 /* $Id$ */
-/*
+/*
  * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)
  * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
  *
@@ -15,7 +15,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <pjnath/ice_session.h>
 #include <pjnath/stun_session.h>
@@ -57,7 +57,7 @@ static const char *cand_type_names[] =

 /* String names for pj_ice_sess_check_state */
 #if PJ_LOG_MAX_LEVEL >= 4
-static const char *check_state_name[] =
+static const char *check_state_name[] =
 {
     "Frozen",
     "Needs Retry",
@@ -77,7 +77,7 @@ static const char *clist_state_name[] =
 };
 #endif	/* PJ_LOG_MAX_LEVEL >= 4 */

-static const char *role_names[] =
+static const char *role_names[] =
 {
     "Unknown",
     "Controlled",
@@ -89,7 +89,7 @@ enum timer_type
     TIMER_NONE,			/**< Timer not active			*/
     TIMER_COMPLETION_CALLBACK,	/**< Call on_ice_complete() callback    */
 	TIMER_CONTROLLING_TCP_PASSIVE_TIMEOUT, /** < Controlling agent is waiting for passive TCP connection timeout **/
-    TIMER_CONTROLLED_WAIT_NOM,	/**< Controlled agent is waiting for
+    TIMER_CONTROLLED_WAIT_NOM,	/**< Controlled agent is waiting for
 				     controlling agent to send connectivity
 				     check with nominated flag after it has
 				     valid check for every components.	*/
@@ -162,10 +162,10 @@ static void ice_keep_alive(pj_ice_sess *ice, pj_bool_t send_now);
 static void ice_on_destroy(void *obj);
 static void destroy_ice(pj_ice_sess *ice,
 			pj_status_t reason);
-static pj_status_t start_periodic_check(pj_timer_heap_t *th,
+static pj_status_t start_periodic_check(pj_timer_heap_t *th,
 					pj_timer_entry *te);
 static void start_nominated_check(pj_ice_sess *ice);
-static void periodic_timer(pj_timer_heap_t *th,
+static void periodic_timer(pj_timer_heap_t *th,
 			  pj_timer_entry *te);
 static void handle_incoming_check(pj_ice_sess *ice,
 				  const pj_ice_rx_check *rcheck);
@@ -215,7 +215,7 @@ static pj_status_t stun_auth_get_cred(const pj_stun_msg *msg,
 				      pj_stun_passwd_type *data_type,
 				      pj_str_t *data);
 static pj_status_t stun_auth_get_password(const pj_stun_msg *msg,
-					  void *user_data,
+					  void *user_data,
 					  const pj_str_t *realm,
 					  const pj_str_t *username,
 					  pj_pool_t *pool,
@@ -314,7 +314,7 @@ static pj_status_t init_comp(pj_ice_sess *ice,
     sess_cb.on_send_msg = &on_stun_send_msg;

     /* Create STUN session for this candidate */
-    status = pj_stun_session_create(&ice->stun_cfg, NULL,
+    status = pj_stun_session_create(&ice->stun_cfg, NULL,
 			            &sess_cb, PJ_TRUE,
 			            ice->grp_lock,
 			            &comp->stun_sess,
@@ -348,7 +348,7 @@ PJ_DEF(void) pj_ice_sess_options_default(pj_ice_sess_options *opt)
 {
     opt->aggressive = PJ_TRUE;
     opt->nominated_check_delay = PJ_ICE_NOMINATED_CHECK_DELAY;
-    opt->controlled_agent_want_nom_timeout =
+    opt->controlled_agent_want_nom_timeout =
 	ICE_CONTROLLED_AGENT_WAIT_NOMINATION_TIMEOUT;
     opt->trickle = PJ_ICE_SESS_TRICKLE_DISABLED;
 	opt->controlling_agent_passive_timeout = ICE_CONTROLLING_PASSIVE_TIMEOUT;
@@ -377,7 +377,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_create(pj_stun_config *stun_cfg,
     if (name == NULL)
 	name = "icess%p";

-    pool = pj_pool_create(stun_cfg->pf, name, PJNATH_POOL_LEN_ICE_SESS,
+    pool = pj_pool_create(stun_cfg->pf, name, PJNATH_POOL_LEN_ICE_SESS,
 			  PJNATH_POOL_INC_ICE_SESS, NULL);
     ice = PJ_POOL_ZALLOC_T(pool, pj_ice_sess);
     ice->pool = pool;
@@ -453,7 +453,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_create(pj_stun_config *stun_cfg,
     /* Done */
     *p_ice = ice;

-    LOG4((ice->obj_name,
+    LOG4((ice->obj_name,
 	 "ICE session created, comp_cnt=%d, role is %s agent",
 	 comp_cnt, role_names[ice->role]));

@@ -566,7 +566,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_destroy(pj_ice_sess *ice)


 /*
- * Change session role.
+ * Change session role.
  */
 PJ_DEF(pj_status_t) pj_ice_sess_change_role(pj_ice_sess *ice,
 					    pj_ice_sess_role new_role)
@@ -666,7 +666,7 @@ static pj_status_t stun_auth_get_cred(const pj_stun_msg *msg,

 /* Get password to be used to authenticate incoming message */
 static pj_status_t stun_auth_get_password(const pj_stun_msg *msg,
-					  void *user_data,
+					  void *user_data,
 					  const pj_str_t *realm,
 					  const pj_str_t *username,
 					  pj_pool_t *pool,
@@ -695,8 +695,8 @@ static pj_status_t stun_auth_get_password(const pj_stun_msg *msg,
 	/* The agent MUST accept a credential if the username consists
 	 * of two values separated by a colon, where the first value is
 	 * equal to the username fragment generated by the agent in an offer
-	 * or answer for a session in-progress, and the MESSAGE-INTEGRITY
-	 * is the output of a hash of the password and the STUN packet's
+	 * or answer for a session in-progress, and the MESSAGE-INTEGRITY
+	 * is the output of a hash of the password and the STUN packet's
 	 * contents.
 	 */
 	const char *pos;
@@ -727,7 +727,7 @@ static pj_uint32_t CALC_CAND_PRIO(pj_ice_sess *ice,
 				  pj_uint32_t comp_id)
 {
 #if PJNATH_ICE_PRIO_STD
-    return ((ice->prefs[type] & 0xFF) << 24) +
+    return ((ice->prefs[type] & 0xFF) << 24) +
 	   ((local_pref & 0xFFFF)    << 8) +
 	   (((256 - comp_id) & 0xFF) << 0);
 #else
@@ -743,7 +743,7 @@ static pj_uint32_t CALC_CAND_PRIO(pj_ice_sess *ice,
 	max_comp    = (2<<PJ_ICE_COMP_BITS),
     };

-    return ((ice->prefs[type] & type_mask) << type_shift) +
+    return ((ice->prefs[type] & type_mask) << type_shift) +
 	   ((local_pref & local_mask) << local_shift) +
 	   (((max_comp - comp_id) & comp_mask) << comp_shift);
 #endif
@@ -932,7 +932,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_add_cand(pj_ice_sess *ice,
     char address[PJ_INET6_ADDRSTRLEN];
     unsigned i;

-    PJ_ASSERT_RETURN(ice && comp_id &&
+    PJ_ASSERT_RETURN(ice && comp_id &&
 		     foundation && addr && base_addr && addr_len,
 		     PJ_EINVAL);
     PJ_ASSERT_RETURN(comp_id <= ice->comp_cnt, PJ_EINVAL);
@@ -998,15 +998,15 @@ PJ_DEF(pj_status_t) pj_ice_sess_add_cand(pj_ice_sess *ice,

     pj_ansi_strcpy(ice->tmp.txt, pj_sockaddr_print(&lcand->addr, address,
                                                    sizeof(address), 2));
-    LOG4((ice->obj_name,
+    LOG4((ice->obj_name,
 	 "Candidate %d added: comp_id=%d, type=%s, foundation=%.*s, "
 	 "addr=%s:%d, base=%s:%d, prio=0x%x (%u)",
 	 lcand->id,
-	 lcand->comp_id,
+	 lcand->comp_id,
 	 cand_type_names[lcand->type],
 	 (int)lcand->foundation.slen,
 	 lcand->foundation.ptr,
-	 ice->tmp.txt,
+	 ice->tmp.txt,
 	  pj_sockaddr_get_port(&lcand->addr),
 	  pj_sockaddr_print(&lcand->base_addr, address, sizeof(address), 2),
 	  pj_sockaddr_get_port(&lcand->base_addr),
@@ -1040,7 +1040,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_find_default_cand(pj_ice_sess *ice,
     /* First find in valid list if we have nominated pair */
     for (i=0; i<ice->valid_list.count; ++i) {
 	pj_ice_sess_check *check = &ice->valid_list.checks[i];
-
+
 	if (check->lcand->comp_id == comp_id) {
 	    *cand_id = GET_LCAND_ID(check->lcand);
 	    pj_grp_lock_release(ice->grp_lock);
@@ -1052,7 +1052,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_find_default_cand(pj_ice_sess *ice,
     for (i=0; i<ice->lcand_cnt; ++i) {
 	pj_ice_sess_cand *lcand = &ice->lcand[i];
 	if (lcand->comp_id==comp_id &&
-	    lcand->type == PJ_ICE_CAND_TYPE_RELAYED)
+	    lcand->type == PJ_ICE_CAND_TYPE_RELAYED)
 	{
 	    *cand_id = GET_LCAND_ID(lcand);
 	    pj_grp_lock_release(ice->grp_lock);
@@ -1065,7 +1065,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_find_default_cand(pj_ice_sess *ice,
 	pj_ice_sess_cand *lcand = &ice->lcand[i];
 	if (lcand->comp_id==comp_id &&
 	    (lcand->type == PJ_ICE_CAND_TYPE_SRFLX ||
-	     lcand->type == PJ_ICE_CAND_TYPE_PRFLX))
+	     lcand->type == PJ_ICE_CAND_TYPE_PRFLX))
 	{
 	    *cand_id = GET_LCAND_ID(lcand);
 	    pj_grp_lock_release(ice->grp_lock);
@@ -1077,7 +1077,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_find_default_cand(pj_ice_sess *ice,
     for (i=0; i<ice->lcand_cnt; ++i) {
 	pj_ice_sess_cand *lcand = &ice->lcand[i];
 	if (lcand->comp_id==comp_id &&
-	    lcand->type == PJ_ICE_CAND_TYPE_HOST)
+	    lcand->type == PJ_ICE_CAND_TYPE_HOST)
 	{
 	    *cand_id = GET_LCAND_ID(lcand);
 	    pj_grp_lock_release(ice->grp_lock);
@@ -1101,7 +1101,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_find_default_cand(pj_ice_sess *ice,
 #   define MAX(a,b) (a > b ? a : b)
 #endif

-static pj_timestamp CALC_CHECK_PRIO(const pj_ice_sess *ice,
+static pj_timestamp CALC_CHECK_PRIO(const pj_ice_sess *ice,
 				    const pj_ice_sess_cand *lcand,
 				    const pj_ice_sess_cand *rcand)
 {
@@ -1113,7 +1113,7 @@ static pj_timestamp CALC_CHECK_PRIO(const pj_ice_sess *ice,
      */

     if (ice->role == PJ_ICE_SESS_ROLE_CONTROLLING) {
-	O = lcand->prio;
+	O = lcand->prio;
 	A = rcand->prio;
     } else {
 	O = rcand->prio;
@@ -1190,7 +1190,7 @@ static const char *dump_check(char *buffer, unsigned bufsize,
     return buffer;
 }

-static void dump_checklist(const char *title, pj_ice_sess *ice,
+static void dump_checklist(const char *title, pj_ice_sess *ice,
 			   const pj_ice_sess_checklist *clist)
 {
     unsigned i;
@@ -1200,7 +1200,7 @@ static void dump_checklist(const char *title, pj_ice_sess *ice,
 	const pj_ice_sess_check *c = &clist->checks[i];
 	LOG4((ice->obj_name, " %s (%s, state=%s)",
 	     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt), clist, c),
-	     (c->nominated ? "nominated" : "not nominated"),
+	     (c->nominated ? "nominated" : "not nominated"),
 	     check_state_name[c->state]));
     }
 }
@@ -1210,7 +1210,7 @@ static void dump_checklist(const char *title, pj_ice_sess *ice,
 #endif

 static void check_set_state(pj_ice_sess *ice, pj_ice_sess_check *check,
-			    pj_ice_sess_check_state st,
+			    pj_ice_sess_check_state st,
 			    pj_status_t err_code)
 {
     if (check->state >= PJ_ICE_SESS_CHECK_STATE_SUCCEEDED)
@@ -1282,9 +1282,9 @@ static void sort_checklist(pj_ice_sess *ice, pj_ice_sess_checklist *clist)
 	    unsigned k;

 	    pj_memcpy(&tmp, &clist->checks[i], sizeof(pj_ice_sess_check));
-	    pj_memcpy(&clist->checks[i], &clist->checks[highest],
+	    pj_memcpy(&clist->checks[i], &clist->checks[highest],
 		      sizeof(pj_ice_sess_check));
-	    pj_memcpy(&clist->checks[highest], &tmp,
+	    pj_memcpy(&clist->checks[highest], &tmp,
 		      sizeof(pj_ice_sess_check));

 	    /* Update valid and nominated check pointers, since we're moving
@@ -1318,7 +1318,7 @@ static void remove_check(pj_ice_sess *ice, pj_ice_sess_checklist *clist,
 /* Prune checklist, this must have been done after the checklist
  * is sorted.
  */
-static pj_status_t prune_checklist(pj_ice_sess *ice,
+static pj_status_t prune_checklist(pj_ice_sess *ice,
 				   pj_ice_sess_checklist *clist)
 {
     unsigned i;
@@ -1331,7 +1331,7 @@ static pj_status_t prune_checklist(pj_ice_sess *ice,
      * the list.  This is done by removing a pair if its local and remote
      * candidates are identical to the local and remote candidates of a pair
      * higher up on the priority list.  The result is a sequence of ordered
-     * candidate pairs, called the check list for that media stream.
+     * candidate pairs, called the check list for that media stream.
      */
     /* First replace SRFLX candidates with their base */
     for (i=0; i<clist->count; ++i) {
@@ -1358,7 +1358,7 @@ static pj_status_t prune_checklist(pj_ice_sess *ice,
 	    if (j==ice->lcand_cnt) {
 		char baddr[PJ_INET6_ADDRSTRLEN];
 		/* Host candidate not found this this srflx! */
-		LOG4((ice->obj_name,
+		LOG4((ice->obj_name,
 		      "Base candidate %s:%d not found for srflx candidate %d",
 		      pj_sockaddr_print(&srflx->base_addr, baddr,
 		                        sizeof(baddr), 2),
@@ -1407,8 +1407,8 @@ static pj_status_t prune_checklist(pj_ice_sess *ice,
 	    if ((licand == ljcand) && (ricand == rjcand)) {
 		reason = "duplicate found";
 	    } else if ((rjcand == ricand) &&
-		       (pj_sockaddr_cmp(&ljcand->base_addr,
-				     &licand->base_addr)==0))
+		       (pj_sockaddr_cmp(&ljcand->base_addr,
+				     &licand->base_addr)==0))
 	    {
 		reason = "equal base";
 	    }
@@ -1446,12 +1446,12 @@ static void on_timer(pj_timer_heap_t *th, pj_timer_entry *te)

     switch (type) {
 	case TIMER_CONTROLLING_TCP_PASSIVE_TIMEOUT:
-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	      "Controlling agent timed-out while waiting for incoming TCP checks. Set state to failed!"));
 	on_ice_complete(ice, PJNATH_EICEFAILED);
 	break;
     case TIMER_CONTROLLED_WAIT_NOM:
-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	      "Controlled agent timed-out while waiting for nomination controlling agent"));
 	on_ice_complete(ice, PJNATH_EICENOMTIMEOUT);
 	break;
@@ -1511,7 +1511,7 @@ static void ice_keep_alive(pj_ice_sess *ice, pj_bool_t send_now)
 	the_check = comp->nominated_check;

 	/* Create the Binding Indication */
-	status = pj_stun_session_create_ind(comp->stun_sess,
+	status = pj_stun_session_create_ind(comp->stun_sess,
 					    PJ_STUN_BINDING_INDICATION,
 					    &tdata);
 	if (status != PJ_SUCCESS)
@@ -1531,8 +1531,8 @@ static void ice_keep_alive(pj_ice_sess *ice, pj_bool_t send_now)
 	/* Send to session */
 	addr_len = pj_sockaddr_get_len(&the_check->rcand->addr);
 	status = pj_stun_session_send_msg(comp->stun_sess, msg_data,
-					  PJ_FALSE, PJ_FALSE,
-					  &the_check->rcand->addr,
+					  PJ_FALSE, PJ_FALSE,
+					  &the_check->rcand->addr,
 					  addr_len, tdata);
 	if (status != PJ_SUCCESS && status != PJ_EPENDING && status != PJ_EBUSY) {
 	    if (ice->cb.on_ice_destroy) {
@@ -1551,8 +1551,8 @@ done:
     if (ice->timer.id == TIMER_NONE) {
 	pj_time_val delay = { 0, 0 };

-	delay.msec = (PJ_ICE_SESS_KEEP_ALIVE_MIN +
-		      (pj_rand() % PJ_ICE_SESS_KEEP_ALIVE_MAX_RAND)) * 1000 /
+	delay.msec = (PJ_ICE_SESS_KEEP_ALIVE_MIN +
+		      (pj_rand() % PJ_ICE_SESS_KEEP_ALIVE_MAX_RAND)) * 1000 /
 		     ice->comp_cnt;
 	pj_time_val_normalize(&delay);

@@ -1572,13 +1572,13 @@ static void on_ice_complete(pj_ice_sess *ice, pj_status_t status)
     if (!ice->is_complete) {
 	ice->is_complete = PJ_TRUE;
 	ice->ice_status = status;
-
+
 	pj_timer_heap_cancel_if_active(ice->stun_cfg.timer_heap, &ice->timer,
 	                               TIMER_NONE);

 	/* Log message */
-	LOG4((ice->obj_name, "ICE process complete, status=%s",
-	     pj_strerror(status, ice->tmp.errmsg,
+	LOG4((ice->obj_name, "ICE process complete, status=%s",
+	     pj_strerror(status, ice->tmp.errmsg,
 			 sizeof(ice->tmp.errmsg)).ptr));

 	dump_checklist("Valid list", ice, &ice->valid_list);
@@ -1596,7 +1596,7 @@ static void on_ice_complete(pj_ice_sess *ice, pj_status_t status)
 }

 /* Update valid check and nominated check for the candidate */
-static void update_comp_check(pj_ice_sess *ice, unsigned comp_id,
+static void update_comp_check(pj_ice_sess *ice, unsigned comp_id,
 			      pj_ice_sess_check *check)
 {
     pj_ice_sess_comp *comp;
@@ -1643,18 +1643,18 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
     pj_bool_t no_pending_check = PJ_FALSE;

     /* Still in 8.2.  Updating States
-     *
+     *
      * o  Once there is at least one nominated pair in the valid list for
      *    every component of at least one media stream and the state of the
      *    check list is Running:
-     *
+     *
      *    *  The agent MUST change the state of processing for its check
      *       list for that media stream to Completed.
-     *
+     *
      *    *  The agent MUST continue to respond to any checks it may still
      *       receive for that media stream, and MUST perform triggered
      *       checks if required by the processing of Section 7.2.
-     *
+     *
      *    *  The agent MAY begin transmitting media for this media stream as
      *       described in Section 11.1
      */
@@ -1674,38 +1674,38 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)

     /* Note: this is the stuffs that we don't do in 7.1.2.2.2, since our
      *       ICE session only supports one media stream for now:
-     *
+     *
      * 7.1.2.2.2.  Updating Pair States
      *
      * 2.  If there is a pair in the valid list for every component of this
      *     media stream (where this is the actual number of components being
      *     used, in cases where the number of components signaled in the SDP
      *     differs from offerer to answerer), the success of this check may
-     *     unfreeze checks for other media streams.
+     *     unfreeze checks for other media streams.
      */

     /* 7.1.2.3.  Check List and Timer State Updates
      * Regardless of whether the check was successful or failed, the
      * completion of the transaction may require updating of check list and
      * timer states.
-     *
+     *
      * If all of the pairs in the check list are now either in the Failed or
      * Succeeded state, and there is not a pair in the valid list for each
      * component of the media stream, the state of the check list is set to
-     * Failed.
+     * Failed.
      */

-    /*
+    /*
      * See if all checks in the checklist have completed. If we do,
      * then mark ICE processing as failed.
      */
-#if PJ_HAS_TCP
+#if PJ_HAS_TCP
 	pj_bool_t hasTCP = PJ_FALSE;
 #endif
     for (i=0; i<ice->clist.count; ++i) {
 	pj_ice_sess_check *c = &ice->clist.checks[i];

-#if PJ_HAS_TCP
+#if PJ_HAS_TCP
 	if (c && c->lcand &&
 		(
 			c->lcand->transport == PJ_CAND_TCP_ACTIVE
@@ -1736,7 +1736,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)

 	    if (i < ice->comp_cnt) {
 		/* This component ID doesn't have valid pair.
-		* Mark ICE as failed.
+		* Mark ICE as failed.
 		*/
 		on_ice_complete(ice, PJNATH_EICEFAILED);
 		return PJ_TRUE;
@@ -1745,7 +1745,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 		 * We should wait until we receive nominated checks.
 		 */
 		if (ice->timer.id == TIMER_NONE &&
-		    ice->opt.controlled_agent_want_nom_timeout >= 0)
+		    ice->opt.controlled_agent_want_nom_timeout >= 0)
 		{
 		    pj_time_val delay;

@@ -1759,7 +1759,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 		                        TIMER_CONTROLLED_WAIT_NOM,
 		                        ice->grp_lock);

-		    LOG5((ice->obj_name,
+		    LOG5((ice->obj_name,
 			  "All checks have completed. Controlled agent now "
 			  "waits for nomination from controlling agent "
 			  "(timeout=%d msec)",
@@ -1782,7 +1782,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 			// In that case, allowing ICE to run a little longer might produce
 			// better results.
 			if (ice->timer.id == TIMER_NONE &&
-				ice->opt.controlling_agent_passive_timeout >= 0)
+				ice->opt.controlling_agent_passive_timeout >= 0)
 			{
 				pj_time_val delay;

@@ -1796,7 +1796,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 									TIMER_CONTROLLING_TCP_PASSIVE_TIMEOUT,
 									ice->grp_lock);

-				LOG5((ice->obj_name,
+				LOG5((ice->obj_name,
 				"All checks have completed but failed. Just "
 				"wait for passive connections to timeout "
 				"(timeout=%d msec)",
@@ -1833,10 +1833,10 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 		return PJ_TRUE;
 	    }

-	    /* Now it's time to send connectivity check with nomination
+	    /* Now it's time to send connectivity check with nomination
 	     * flag set.
 	     */
-	    LOG4((ice->obj_name,
+	    LOG4((ice->obj_name,
 		  "All checks have completed, starting nominated checks now"));
 	    start_nominated_check(ice);
 	    return PJ_FALSE;
@@ -1851,7 +1851,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
     if (/*check->err_code == PJ_SUCCESS && */
 	ice->role==PJ_ICE_SESS_ROLE_CONTROLLING &&
 	!ice->is_nominating &&
-	ice->timer.id == TIMER_NONE)
+	ice->timer.id == TIMER_NONE)
     {
 	pj_time_val delay;

@@ -1867,7 +1867,7 @@ static pj_bool_t check_ice_complete(pj_ice_sess *ice)
 	    return PJ_FALSE;
 	}

-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	      "Scheduling nominated check in %d ms",
 	      ice->opt.nominated_check_delay));

@@ -1904,12 +1904,12 @@ static pj_bool_t on_check_complete(pj_ice_sess *ice,
     comp = find_comp(ice, check->lcand->comp_id);

     /* 7.1.2.2.2.  Updating Pair States
-     *
+     *
      * The agent sets the state of the pair that generated the check to
      * Succeeded.  The success of this check might also cause the state of
      * other checks to change as well.  The agent MUST perform the following
      * two steps:
-     *
+     *
      * 1.  The agent changes the states for all other Frozen pairs for the
      *     same media stream and same foundation to Waiting.  Typically
      *     these other pairs will have different component IDs but not
@@ -1941,7 +1941,7 @@ static pj_bool_t on_check_complete(pj_ice_sess *ice,
     }

     /* 8.2.  Updating States
-     *
+     *
      * For both controlling and controlled agents, the state of ICE
      * processing depends on the presence of nominated candidate pairs in
      * the valid list and on the state of the check list:
@@ -1972,10 +1972,10 @@ static pj_bool_t on_check_complete(pj_ice_sess *ice,
 		if (c->state < PJ_ICE_SESS_CHECK_STATE_IN_PROGRESS) {

 		    /* Just fail Frozen/Waiting check */
-		    LOG5((ice->obj_name,
+		    LOG5((ice->obj_name,
 			 "Check %s to be failed because state is %s",
-			 dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
-				    &ice->clist, c),
+			 dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+				    &ice->clist, c),
 			 check_state_name[c->state]));
 		    check_set_state(ice, c, PJ_ICE_SESS_CHECK_STATE_FAILED,
 				    PJ_ECANCELLED);
@@ -1986,11 +1986,11 @@ static pj_bool_t on_check_complete(pj_ice_sess *ice,

 		    /* State is IN_PROGRESS, cancel transaction */
 		    if (c->tdata) {
-			LOG5((ice->obj_name,
+			LOG5((ice->obj_name,
 			     "Cancelling check %s (In Progress)",
-			     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+			     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
 					&ice->clist, c)));
-			pj_stun_session_cancel_req(comp->stun_sess,
+			pj_stun_session_cancel_req(comp->stun_sess,
 						   c->tdata, PJ_FALSE, 0);
 			c->tdata = NULL;
 			check_set_state(ice, c, PJ_ICE_SESS_CHECK_STATE_FAILED,
@@ -2163,7 +2163,7 @@ static pj_status_t add_rcand_and_update_checklist(
 	    if (j < ice->rcand_cnt)
 		continue;
 	}
-
+
 	/* Available cand slot? */
 	if (ice->rcand_cnt >= PJ_ICE_MAX_CAND) {
 	    char tmp[PJ_INET6_ADDRSTRLEN + 10];
@@ -2199,10 +2199,10 @@ static pj_status_t add_rcand_and_update_checklist(
 		if (discard_check(ice, clist, &max_prio) == 0)
 		    continue;
 	    }
-
+
 	    /* A local candidate is paired with a remote candidate if
-	     * and only if the two candidates have the same component ID
-	     * and have the same IP address version.
+	     * and only if the two candidates have the same component ID
+	     * and have the same IP address version.
 	     */
 	    if ((lcand->comp_id != rcand->comp_id) ||
 		(lcand->addr.addr.sa_family != rcand->addr.addr.sa_family))
@@ -2509,7 +2509,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_update_check_list(
 	pj_grp_lock_release(ice->grp_lock);
 	return PJ_SUCCESS;
     }
-
+
     /* Verify remote ufrag & passwd, if remote candidate specified */
     if (rem_cand_cnt && (pj_strcmp(&ice->tx_ufrag, rem_ufrag) ||
 			 pj_strcmp(&ice->tx_pass, rem_passwd)))
@@ -2571,7 +2571,7 @@ static pj_status_t send_connectivity_check(pj_ice_sess *ice,
 }

 /* Perform check on the specified candidate pair. */
-static pj_status_t perform_check(pj_ice_sess *ice,
+static pj_status_t perform_check(pj_ice_sess *ice,
 				 pj_ice_sess_checklist *clist,
 				 unsigned check_id,
 				 pj_bool_t nominate)
@@ -2588,12 +2588,12 @@ static pj_status_t perform_check(pj_ice_sess *ice,
     comp = find_comp(ice, lcand->comp_id);

     pj_log_push_indent();
-    LOG5((ice->obj_name,
-	 "Sending connectivity check for check %s",
+    LOG5((ice->obj_name,
+	 "Sending connectivity check for check %s",
 	 dump_check(ice->tmp.txt, sizeof(ice->tmp.txt), clist, check)));

     /* Create request */
-    status = pj_stun_session_create_req(comp->stun_sess,
+    status = pj_stun_session_create_req(comp->stun_sess,
 					PJ_STUN_BINDING_REQUEST, PJ_STUN_MAGIC,
 					NULL, &check->tdata);
     if (status != PJ_SUCCESS) {
@@ -2623,7 +2623,7 @@ static pj_status_t perform_check(pj_ice_sess *ice,
 			  ((1 << PJ_ICE_LOCAL_PREF_BITS) - 1) - lcand->id,
 			  lcand->comp_id);
 #endif
-    pj_stun_msg_add_uint_attr(check->tdata->pool, check->tdata->msg,
+    pj_stun_msg_add_uint_attr(check->tdata->pool, check->tdata->msg,
 			      PJ_STUN_ATTR_PRIORITY, prio);

     /* Add USE-CANDIDATE and set this check to nominated.
@@ -2636,7 +2636,7 @@ static pj_status_t perform_check(pj_ice_sess *ice,
 	    check->nominated = PJ_TRUE;
 	}

-	pj_stun_msg_add_uint64_attr(check->tdata->pool, check->tdata->msg,
+	pj_stun_msg_add_uint64_attr(check->tdata->pool, check->tdata->msg,
 				    PJ_STUN_ATTR_ICE_CONTROLLING,
 				    &ice->tie_breaker);

@@ -2644,7 +2644,7 @@ static pj_status_t perform_check(pj_ice_sess *ice,
 	if (nominate) {
 	    check->nominated = PJ_TRUE;
 	}
-	pj_stun_msg_add_uint64_attr(check->tdata->pool, check->tdata->msg,
+	pj_stun_msg_add_uint64_attr(check->tdata->pool, check->tdata->msg,
 				    PJ_STUN_ATTR_ICE_CONTROLLED,
 				    &ice->tie_breaker);
     }
@@ -2667,8 +2667,8 @@ static pj_status_t perform_check(pj_ice_sess *ice,
             if (ice->timer_connect.id != TIMER_NONE) {
                 pj_assert(!"Not expected any timer active");
             } else {
-                LOG5((ice->obj_name,
-                    "Scheduling connection time-out for check %s",
+                LOG5((ice->obj_name,
+                    "Scheduling connection time-out for check %s",
                     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt), clist, check)));

                 pj_time_val delay = {
@@ -2715,7 +2715,7 @@ static pj_status_t perform_check(pj_ice_sess *ice,
 /* Start periodic check for the specified checklist.
  * This callback is called by timer on every Ta
  */
-static pj_status_t start_periodic_check(pj_timer_heap_t *th,
+static pj_status_t start_periodic_check(pj_timer_heap_t *th,
 					pj_timer_entry *te)
 {
     timer_data *td;
@@ -2914,7 +2914,7 @@ static void start_nominated_check(pj_ice_sess *ice)
 	    {
 		pj_assert(c->err_code == PJ_SUCCESS);
 		c->state = PJ_ICE_SESS_CHECK_STATE_FROZEN;
-		check_set_state(ice, c, PJ_ICE_SESS_CHECK_STATE_WAITING,
+		check_set_state(ice, c, PJ_ICE_SESS_CHECK_STATE_WAITING,
 			        PJ_SUCCESS);
 		break;
 	    }
@@ -2939,7 +2939,7 @@ static void start_nominated_check(pj_ice_sess *ice)
 }

 /* Timer callback to perform periodic check */
-static void periodic_timer(pj_timer_heap_t *th,
+static void periodic_timer(pj_timer_heap_t *th,
 			   pj_timer_entry *te)
 {
     start_periodic_check(th, te);
@@ -2978,9 +2978,9 @@ PJ_DEF(pj_status_t) pj_ice_sess_start_check(pj_ice_sess *ice)
      * media stream is the first media stream when it is described by
      * the first m-line in the SDP offer and answer).  For that media
      * stream, it:
-     *
+     *
      * -  Groups together all of the pairs with the same foundation,
-     *
+     *
      * -  For each group, sets the state of the pair with the lowest
      *    component ID to Waiting.  If there is more than one such pair,
      *    the one with the highest priority is used.
@@ -3028,7 +3028,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_start_check(pj_ice_sess *ice)
     /* First, perform all pending triggered checks, simultaneously. */
     rcheck = ice->early_check.next;
     while (rcheck != &ice->early_check) {
-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	      "Performing delayed triggerred check for component %d",
 	      rcheck->comp_id));
 	pj_log_push_indent();
@@ -3039,7 +3039,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_start_check(pj_ice_sess *ice)
     pj_list_init(&ice->early_check);

     /* Start periodic check */
-    /* We could start it immediately like below, but lets schedule timer
+    /* We could start it immediately like below, but lets schedule timer
      * instead to reduce stack usage:
      * return start_periodic_check(ice->stun_cfg.timer_heap, &clist->timer);
      */
@@ -3091,7 +3091,7 @@ static pj_status_t on_stun_send_msg(pj_stun_session *sess,
     pj_ice_sess *ice = sd->ice;
     pj_ice_msg_data *msg_data = (pj_ice_msg_data*) token;
     pj_status_t status;
-
+
     pj_grp_lock_acquire(ice->grp_lock);

     if (ice->is_destroying) {
@@ -3371,41 +3371,45 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,

     pj_assert(msg_data->has_req_data);

-    ice = msg_data->data.req.ice;
-    clist = msg_data->data.req.clist;
-    ckid = msg_data->data.req.ckid;
-    check = &clist->checks[ckid];
-
-    pj_grp_lock_acquire(ice->grp_lock);
+	ice = msg_data->data.req.ice;
+	clist = msg_data->data.req.clist;
+	ckid = msg_data->data.req.ckid;
+	check = &clist->checks[ckid];

-    if (ice->is_destroying) {
-	/* Not sure if this is possible but just in case */
-	pj_grp_lock_release(ice->grp_lock);
-	return;
-    }
+	pj_grp_lock_acquire(ice->grp_lock);

-    /* Verify check (check ID may change as trickle ICE re-sort the list */
-    if (tdata != check->tdata) {
-	/* Okay, it was re-sorted, lookup using lcand & rcand */
-	for (i = 0; i < clist->count; ++i) {
-	    if (clist->checks[i].lcand == msg_data->data.req.lcand &&
-		clist->checks[i].rcand == msg_data->data.req.rcand)
-	    {
-		check = &clist->checks[i];
-		ckid = i;
-		break;
-	    }
+	if (ice->is_destroying)
+	{
+		/* Not sure if this is possible but just in case */
+		pj_grp_lock_release(ice->grp_lock);
+		return;
 	}
-	if (i == clist->count) {
-	    /* The check may have been pruned (due to low prio) */
-	    check->tdata = NULL;
-	    pj_grp_lock_release(ice->grp_lock);
-	    return;
+
+	/* Verify check (check ID may change as trickle ICE re-sort the list */
+	if (tdata != check->tdata)
+	{
+		/* Okay, it was re-sorted, lookup using lcand & rcand */
+		for (i = 0; i < clist->count; ++i)
+		{
+			if (clist->checks[i].lcand == msg_data->data.req.lcand &&
+				clist->checks[i].rcand == msg_data->data.req.rcand)
+			{
+				check = &clist->checks[i];
+				ckid = i;
+				break;
+			}
+		}
+		if (i == clist->count)
+		{
+			/* The check may have been pruned (due to low prio) */
+			check->tdata = NULL;
+			pj_grp_lock_release(ice->grp_lock);
+			return;
+		}
 	}
-    }

-    /* Mark STUN transaction as complete */
-    // Find 'corner case ...'.
+	/* Mark STUN transaction as complete */
+	// Find 'corner case ...'.
     //pj_assert(tdata == check->tdata);
     check->tdata = NULL;

@@ -3423,13 +3427,13 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	     *
 	     * 7.1.2.1.  Failure Cases:
 	     *
-	     * If the request had contained the ICE-CONTROLLED attribute,
+	     * If the request had contained the ICE-CONTROLLED attribute,
 	     * the agent MUST switch to the controlling role if it has not
-	     * already done so.  If the request had contained the
-	     * ICE-CONTROLLING attribute, the agent MUST switch to the
+	     * already done so.  If the request had contained the
+	     * ICE-CONTROLLING attribute, the agent MUST switch to the
 	     * controlled role if it has not already done so.  Once it has
 	     * switched, the agent MUST immediately retry the request with
-	     * the ICE-CONTROLLING or ICE-CONTROLLED attribute reflecting
+	     * the ICE-CONTROLLING or ICE-CONTROLLED attribute reflecting
 	     * its new role.
 	     */
 	    pj_ice_sess_role new_role = PJ_ICE_SESS_ROLE_UNKNOWN;
@@ -3437,7 +3441,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,

 	    if (pj_stun_msg_find_attr(req, PJ_STUN_ATTR_ICE_CONTROLLING, 0)) {
 		new_role = PJ_ICE_SESS_ROLE_CONTROLLED;
-	    } else if (pj_stun_msg_find_attr(req, PJ_STUN_ATTR_ICE_CONTROLLED,
+	    } else if (pj_stun_msg_find_attr(req, PJ_STUN_ATTR_ICE_CONTROLLED,
 					     0)) {
 		new_role = PJ_ICE_SESS_ROLE_CONTROLLING;
 	    } else {
@@ -3446,7 +3450,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	    }

 	    if (new_role != ice->role) {
-		LOG4((ice->obj_name,
+		LOG4((ice->obj_name,
 		      "Changing role because of role conflict response"));
 		pj_ice_sess_change_role(ice, new_role);
 	    }
@@ -3463,9 +3467,9 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	}

 	pj_strerror(status, errmsg, sizeof(errmsg));
-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	     "Check %s%s: connectivity check FAILED: %s",
-	     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+	     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
 			&ice->clist, check),
 	     (check->nominated ? " (nominated)" : " (not nominated)"),
 	     errmsg));
@@ -3477,8 +3481,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	return;
     }

-
-    /* 7.1.2.1.  Failure Cases
+	/* 7.1.2.1.  Failure Cases
      *
      * The agent MUST check that the source IP address and port of the
      * response equals the destination IP address and port that the Binding
@@ -3486,7 +3489,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
      * the response match the source IP address and port that the Binding
      * Request was sent from.
      */
-    if (check->rcand->addr.addr.sa_family == pj_AF_INET() &&
+	if (check->rcand->addr.addr.sa_family == pj_AF_INET() &&
         ((pj_sockaddr *)src_addr)->addr.sa_family == pj_AF_INET6())
     {
         /* If the address family is different, we need to check
@@ -3494,7 +3497,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
          * is synthesized from IPv4).
          */
         pj_sockaddr synth_addr;
-
+
     	status = pj_sockaddr_synthesize(pj_AF_INET6(), &synth_addr,
     					&check->rcand->addr);
     	if (status == PJ_SUCCESS &&
@@ -3504,40 +3507,40 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
     	}
     }

-    if (pj_sockaddr_cmp(&check->rcand->addr, source_addr) != 0) {
-	status = PJNATH_EICEINSRCADDR;
-	LOG4((ice->obj_name,
-	     "Check %s%s: connectivity check FAILED: source address mismatch",
-	     dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
-			&ice->clist, check),
-	     (check->nominated ? " (nominated)" : " (not nominated)")));
-	pj_log_push_indent();
-	check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED, status);
-	on_check_complete(ice, check);
-	pj_log_pop_indent();
-	pj_grp_lock_release(ice->grp_lock);
-	return;
-    }
+	if (pj_sockaddr_cmp(&check->rcand->addr, source_addr) != 0)
+	{
+		status = PJNATH_EICEINSRCADDR;
+		LOG4((ice->obj_name,
+			  "Check %s%s: connectivity check FAILED: source address mismatch",
+			  dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+						 &ice->clist, check),
+			  (check->nominated ? " (nominated)" : " (not nominated)")));
+		pj_log_push_indent();
+		check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED, status);
+		on_check_complete(ice, check);
+		pj_log_pop_indent();
+		pj_grp_lock_release(ice->grp_lock);
+		return;
+	}

-    /* 7.1.2.2.  Success Cases
-     *
+	/* 7.1.2.2.  Success Cases
+     *
      * A check is considered to be a success if all of the following are
      * true:
-     *
+     *
      * o  the STUN transaction generated a success response
-     *
+     *
      * o  the source IP address and port of the response equals the
      *    destination IP address and port that the Binding Request was sent
      *    to
-     *
+     *
      * o  the destination IP address and port of the response match the
      *    source IP address and port that the Binding Request was sent from
      */

-
-    LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	 "Check %s%s: connectivity check SUCCESS",
-	 dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+	 dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
 		    &ice->clist, check),
 	 (check->nominated ? " (nominated)" : " (not nominated)")));

@@ -3545,15 +3548,15 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
     xaddr = (pj_stun_xor_mapped_addr_attr*)
 	    pj_stun_msg_find_attr(response, PJ_STUN_ATTR_XOR_MAPPED_ADDR,0);
     if (!xaddr) {
-	check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED,
+	check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED,
 			PJNATH_ESTUNNOMAPPEDADDR);
 	on_check_complete(ice, check);
 	pj_grp_lock_release(ice->grp_lock);
 	return;
     }

-    /* Find local candidate that matches the XOR-MAPPED-ADDRESS */
-    pj_assert(lcand == NULL);
+	/* Find local candidate that matches the XOR-MAPPED-ADDRESS */
+	pj_assert(lcand == NULL);
     for (i=0; i<ice->lcand_cnt; ++i) {
 	/* Ticket #1891: apply additional check as there may be a shared
 	 * mapped address for different base/local addresses.
@@ -3616,12 +3619,12 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	}
     }

-    /* 7.1.2.2.1.  Discovering Peer Reflexive Candidates
+	/* 7.1.2.2.1.  Discovering Peer Reflexive Candidates
      * If the transport address returned in XOR-MAPPED-ADDRESS does not match
-     * any of the local candidates that the agent knows about, the mapped
+     * any of the local candidates that the agent knows about, the mapped
      * address represents a new candidate - a peer reflexive candidate.
      */
-    if (lcand == NULL) {
+	if (lcand == NULL) {
 	unsigned cand_id;
 	pj_str_t foundation;

@@ -3638,7 +3641,7 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	 */

 	/* Add new peer reflexive candidate */
-	status = pj_ice_sess_add_cand(ice, check->lcand->comp_id,
+	status = pj_ice_sess_add_cand(ice, check->lcand->comp_id,
 				      msg_data->transport_id,
 				      PJ_ICE_CAND_TYPE_PRFLX,
 #if PJNATH_ICE_PRIO_STD
@@ -3648,15 +3651,20 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 				      ice->lcand_cnt,
 #endif
 				      &foundation,
-				      &xaddr->sockaddr,
-				      &check->lcand->base_addr,
+				      &xaddr->sockaddr,
+				      &check->lcand->base_addr,
 				      &check->lcand->base_addr,
 				      pj_sockaddr_get_len(&xaddr->sockaddr),
 				      &cand_id,
 				      check->rcand->transport == PJ_CAND_UDP ?
 				      PJ_CAND_UDP : PJ_CAND_TCP_PASSIVE);
-	if (status != PJ_SUCCESS) {
-	    check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED,
+	if (status != PJ_SUCCESS || cand_id == ice->lcand_cnt) {
+		// If cand_id == ice->lcand_cnt, this means that no candidate
+		// was added (probably an ipv6 deprecated)
+		if (cand_id == ice->lcand_cnt) {
+			printf("@@@ YEAY!!!!\n");
+		}
+	    check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_FAILED,
 			    status);
 	    on_check_complete(ice, check);
 	    pj_grp_lock_release(ice->grp_lock);
@@ -3667,13 +3675,14 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	lcand = &ice->lcand[cand_id];
     }

-    /* 7.1.2.2.3.  Constructing a Valid Pair
+	printf("@@@16\n");
+	/* 7.1.2.2.3.  Constructing a Valid Pair
      * Next, the agent constructs a candidate pair whose local candidate
      * equals the mapped address of the response, and whose remote candidate
-     * equals the destination address to which the request was sent.
+     * equals the destination address to which the request was sent.
      */

-    /* Add pair to valid list, if it's not there, otherwise just update
+	/* Add pair to valid list, if it's not there, otherwise just update
      * nominated flag
      */
     for (i=0; i<ice->valid_list.count; ++i) {
@@ -3682,25 +3691,56 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
 	    break;
     }

-    if (i==ice->valid_list.count) {
-	pj_assert(ice->valid_list.count < PJ_ICE_MAX_CHECKS);
-	new_check = &ice->valid_list.checks[ice->valid_list.count++];
-	new_check->lcand = lcand;
-	new_check->rcand = check->rcand;
-	new_check->prio = CALC_CHECK_PRIO(ice, lcand, check->rcand);
-	new_check->state = PJ_ICE_SESS_CHECK_STATE_SUCCEEDED;
-	new_check->nominated = check->nominated;
-	new_check->err_code = PJ_SUCCESS;
+	printf("@@@16.1\n");
+	if (i == ice->valid_list.count)
+	{
+		printf("@@@16.2 %u vs %u\n", ice->valid_list.count, PJ_ICE_MAX_CHECKS);
+		pj_assert(ice->valid_list.count < PJ_ICE_MAX_CHECKS);
+		new_check = &ice->valid_list.checks[ice->valid_list.count++];
+		if (!new_check)
+			printf("@@@NOOOOO!\n");
+		printf("@@@16.3\n");
+		new_check->lcand = lcand;
+		printf("@@@16.31\n");
+		if (!check)
+			printf("@@@NOOOOO2!\n");
+		new_check->rcand = check->rcand;
+		if (!check->rcand)
+			printf("@@@NOOOOO rcand!\n");
+		if (!lcand)
+			printf("@@@NOOOOO lcand!\n");
+		printf("@@@16.32\n");
+
+
+		char raddr[PJ_INET6_ADDRSTRLEN + 10];
+		printf("@@@ rcand %s:%d\n", pj_sockaddr_print(&check->rcand->addr, raddr, sizeof(raddr), 2),
+	      pj_sockaddr_get_port(&check->rcand->addr));
+		printf("@@@ ocand %s:%d\n", pj_sockaddr_print(&lcand->addr, raddr, sizeof(raddr), 2),
+	      pj_sockaddr_get_port(&lcand->addr));
+
+		new_check->prio = CALC_CHECK_PRIO(ice, lcand, check->rcand);
+		printf("@@@16.33\n");
+		new_check->state = PJ_ICE_SESS_CHECK_STATE_SUCCEEDED;
+		new_check->nominated = check->nominated;
+		printf("@@@16.34\n");
+		new_check->err_code = PJ_SUCCESS;
 #if PJ_HAS_TCP
-	new_check->reconnect_count = 0;
+		printf("@@@16.4\n");
+		new_check->reconnect_count = 0;
 #endif
-    } else {
-	new_check = &ice->valid_list.checks[i];
-	ice->valid_list.checks[i].nominated = check->nominated;
-    }
+	}
+	else
+	{
+	printf("@@@16.20\n");
+		new_check = &ice->valid_list.checks[i];
+	printf("@@@16.21\n");
+		ice->valid_list.checks[i].nominated = check->nominated;
+	printf("@@@16.22\n");
+	}

-    /* Update valid check and nominated check for the component */
-    update_comp_check(ice, new_check->lcand->comp_id, new_check);
+	printf("@@@17\n");
+	/* Update valid check and nominated check for the component */
+	update_comp_check(ice, new_check->lcand->comp_id, new_check);

     /* Sort valid_list (must do so after update_comp_check(), otherwise
      * new_check will point to something else (#953)
@@ -3708,20 +3748,22 @@ static void on_stun_request_complete(pj_stun_session *stun_sess,
     sort_checklist(ice, &ice->valid_list);

     /* 7.1.2.2.2.  Updating Pair States
-     *
+     *
      * The agent sets the state of the pair that generated the check to
      * Succeeded.  The success of this check might also cause the state of
      * other checks to change as well.
      */
-    check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_SUCCEEDED,
-		    PJ_SUCCESS);
+	printf("@@@18\n");
+	check_set_state(ice, check, PJ_ICE_SESS_CHECK_STATE_SUCCEEDED,
+					PJ_SUCCESS);

-    /* Perform 7.1.2.2.2.  Updating Pair States.
+	/* Perform 7.1.2.2.2.  Updating Pair States.
      * This may terminate ICE processing.
      */
 	on_check_complete(ice, check);

-    pj_grp_lock_release(ice->grp_lock);
+	printf("@@@19\n");
+	pj_grp_lock_release(ice->grp_lock);
 }


@@ -3751,11 +3793,11 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,

     PJ_UNUSED_ARG(pkt);
     PJ_UNUSED_ARG(pkt_len);
-
+
     /* Reject any requests except Binding request */
     if (msg->hdr.type != PJ_STUN_BINDING_REQUEST) {
-	pj_stun_session_respond(sess, rdata, PJ_STUN_SC_BAD_REQUEST,
-				NULL, token, PJ_TRUE,
+	pj_stun_session_respond(sess, rdata, PJ_STUN_SC_BAD_REQUEST,
+				NULL, token, PJ_TRUE,
 				src_addr, src_addr_len);
 	return PJ_SUCCESS;
     }
@@ -3821,13 +3863,13 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
     {
 	if (pj_cmp_timestamp(&ice->tie_breaker, &role_attr->value) < 0) {
 	    /* Switch role to controlled */
-	    LOG4((ice->obj_name,
+	    LOG4((ice->obj_name,
 		  "Changing role because of ICE-CONTROLLING attribute"));
 	    pj_ice_sess_change_role(ice, PJ_ICE_SESS_ROLE_CONTROLLED);
 	} else {
 	    /* Generate 487 response */
-	    pj_stun_session_respond(sess, rdata, PJ_STUN_SC_ROLE_CONFLICT,
-				    NULL, token, PJ_TRUE,
+	    pj_stun_session_respond(sess, rdata, PJ_STUN_SC_ROLE_CONFLICT,
+				    NULL, token, PJ_TRUE,
 				    src_addr, src_addr_len);
 	    pj_grp_lock_release(ice->grp_lock);
 	    return PJ_SUCCESS;
@@ -3838,21 +3880,21 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
     {
 	if (pj_cmp_timestamp(&ice->tie_breaker, &role_attr->value) < 0) {
 	    /* Generate 487 response */
-	    pj_stun_session_respond(sess, rdata, PJ_STUN_SC_ROLE_CONFLICT,
-				    NULL, token, PJ_TRUE,
+	    pj_stun_session_respond(sess, rdata, PJ_STUN_SC_ROLE_CONFLICT,
+				    NULL, token, PJ_TRUE,
 				    src_addr, src_addr_len);
 	    pj_grp_lock_release(ice->grp_lock);
 	    return PJ_SUCCESS;
 	} else {
 	    /* Switch role to controlled */
-	    LOG4((ice->obj_name,
+	    LOG4((ice->obj_name,
 		  "Changing role because of ICE-CONTROLLED attribute"));
 	    pj_ice_sess_change_role(ice, PJ_ICE_SESS_ROLE_CONTROLLING);
 	}
     }

-    /*
-     * First send response to this request
+    /*
+     * First send response to this request
      */
     status = pj_stun_session_create_res(sess, rdata, 0, NULL, &tdata);
     if (status != PJ_SUCCESS) {
@@ -3868,7 +3910,7 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
     	for (i = 0; i < ice->clist.count; ++i) {
 	    pj_ice_sess_check *c = &ice->clist.checks[i];
 	    if (c->lcand->comp_id == sd->comp_id &&
-	        c->lcand->transport_id == transport_id)
+	        c->lcand->transport_id == transport_id)
 	    {
 	    	lcand = c->lcand;
 	    	break;
@@ -3883,7 +3925,7 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
              */
             for (i = 0; i < ice->rcand_cnt; ++i) {
             	pj_sockaddr synth_addr;
-
+
             	if (ice->rcand[i].addr.addr.sa_family != pj_AF_INET())
                     continue;

@@ -3903,7 +3945,7 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,


     /* Add XOR-MAPPED-ADDRESS attribute */
-    status = pj_stun_msg_add_sockaddr_attr(tdata->pool, tdata->msg,
+    status = pj_stun_msg_add_sockaddr_attr(tdata->pool, tdata->msg,
 					   PJ_STUN_ATTR_XOR_MAPPED_ADDR,
 					   PJ_TRUE, source_addr,
 					   source_addr_len);
@@ -3922,7 +3964,7 @@ static pj_status_t on_stun_rx_request(pj_stun_session *sess,
 		PJ_LOG(5, (ice->obj_name, "on_stun_rx_request, PJ_EBUSY"));
 	}

-    /*
+    /*
      * Handling early check.
      *
      * It's possible that we receive this request before we receive SDP
@@ -3974,7 +4016,7 @@ static void handle_incoming_check(pj_ice_sess *ice,

     comp = find_comp(ice, rcheck->comp_id);

-    /* Find remote candidate based on the source transport address of
+    /* Find remote candidate based on the source transport address of
      * the request.
      */
     for (i=0; i<ice->rcand_cnt; ++i) {
@@ -3992,7 +4034,7 @@ static void handle_incoming_check(pj_ice_sess *ice,
 	void *p;

 	if (ice->rcand_cnt >= PJ_ICE_MAX_CAND) {
-	    LOG4((ice->obj_name,
+	    LOG4((ice->obj_name,
 	          "Unable to add new peer reflexive candidate: too many "
 		  "candidates already (%d)", PJ_ICE_MAX_CAND));
 	    return;
@@ -4009,7 +4051,7 @@ static void handle_incoming_check(pj_ice_sess *ice,
 	rcand->foundation.slen = pj_ansi_snprintf(rcand->foundation.ptr, 36,
 						  "f%p", p);

-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	      "Added new remote candidate from the request: %s:%d",
 	      pj_sockaddr_print(&rcand->addr, raddr, sizeof(raddr), 2),
 	      pj_sockaddr_get_port(&rcand->addr)));
@@ -4052,17 +4094,17 @@ static void handle_incoming_check(pj_ice_sess *ice,
 	/* Should not happen, but just in case remote is sending a
 	 * Binding request for a component which it doesn't have.
 	 */
-	LOG4((ice->obj_name,
+	LOG4((ice->obj_name,
 	     "Received Binding request but no local candidate is found!"));
 	return;
     }
 #endif

-    /*
-     * Create candidate pair for this request.
+    /*
+     * Create candidate pair for this request.
      */

-    /*
+    /*
      * 7.2.1.4.  Triggered Checks
      *
      * Now that we have local and remote candidate, check if we already
@@ -4083,14 +4125,14 @@ static void handle_incoming_check(pj_ice_sess *ice,
      *   generate an immediate retransmit of the Binding Request for the
      *   check in progress.  This is to facilitate rapid completion of
      *   ICE when both agents are behind NAT.
-     *
+     *
      * - If the state of that pair is Failed or Succeeded, no triggered
      *   check is sent.
      */
     if (i != ice->clist.count) {
 	pj_ice_sess_check *c = &ice->clist.checks[i];

-	/* If USE-CANDIDATE is present, set nominated flag
+	/* If USE-CANDIDATE is present, set nominated flag
 	 * Note: DO NOT overwrite nominated flag if one is already set.
 	 */
 	c->nominated = ((rcheck->use_candidate) || c->nominated);
@@ -4131,14 +4173,14 @@ static void handle_incoming_check(pj_ice_sess *ice,
 	    unsigned j;

 	    /* If this check is nominated, scan the valid_list for the
-	     * same check and update the nominated flag. A controlled
+	     * same check and update the nominated flag. A controlled
 	     * agent might have finished the check earlier.
 	     */
 	    if (rcheck->use_candidate) {
 		for (j=0; j<ice->valid_list.count; ++j) {
 		    pj_ice_sess_check *vc = &ice->valid_list.checks[j];
-		    if (vc->lcand->transport_id == c->lcand->transport_id &&
-			vc->rcand == c->rcand)
+		    if (vc->lcand->transport_id == c->lcand->transport_id &&
+			vc->rcand == c->rcand)
 		    {
 			/* Set nominated flag */
 			vc->nominated = PJ_TRUE;
@@ -4146,8 +4188,8 @@ static void handle_incoming_check(pj_ice_sess *ice,
 			/* Update valid check and nominated check for the component */
 			update_comp_check(ice, vc->lcand->comp_id, vc);

-			LOG5((ice->obj_name, "Valid check %s is nominated",
-			      dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
+			LOG5((ice->obj_name, "Valid check %s is nominated",
+			      dump_check(ice->tmp.txt, sizeof(ice->tmp.txt),
 					 &ice->valid_list, vc)));
 		    }
 		}
@@ -4247,7 +4289,7 @@ static pj_status_t on_stun_rx_indication(pj_stun_session *sess,
 	      "for component %d", sd->comp_id));
     } else {
 	LOG4((sd->ice->obj_name, "Received unexpected %s indication "
-	      "for component %d", pj_stun_get_method_name(msg->hdr.type),
+	      "for component %d", pj_stun_get_method_name(msg->hdr.type),
 	      sd->comp_id));
     }

@@ -4269,7 +4311,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_send_data(pj_ice_sess *ice,
     pj_sockaddr addr;

     PJ_ASSERT_RETURN(ice && comp_id, PJ_EINVAL);
-
+
     /* It is possible that comp_cnt is less than comp_id, when remote
      * doesn't support all the components that we have.
      */
@@ -4306,9 +4348,9 @@ PJ_DEF(pj_status_t) pj_ice_sess_send_data(pj_ice_sess *ice,

     PJ_RACE_ME(5);

-    status = (*ice->cb.on_tx_pkt)(ice, comp_id, transport_id,
-				  data, data_len,
-				  &addr,
+    status = (*ice->cb.on_tx_pkt)(ice, comp_id, transport_id,
+				  data, data_len,
+				  &addr,
 				  pj_sockaddr_get_len(&addr));

 on_return:
@@ -4361,7 +4403,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_on_rx_pkt(pj_ice_sess *ice,
      * packets. We don't need to verify the STUN packet too rigorously, that
      * will be done by the user.
      */
-    status = pj_stun_msg_check((const pj_uint8_t*)pkt, pkt_size,
+    status = pj_stun_msg_check((const pj_uint8_t*)pkt, pkt_size,
     			       PJ_STUN_IS_DATAGRAM |
     			         PJ_STUN_NO_FINGERPRINT_CHECK);
     if (status == PJ_SUCCESS) {
@@ -4382,7 +4424,7 @@ PJ_DEF(pj_status_t) pj_ice_sess_on_rx_pkt(pj_ice_sess *ice,

 	PJ_RACE_ME(5);

-	(*ice->cb.on_rx_data)(ice, comp_id, transport_id, pkt, pkt_size,
+	(*ice->cb.on_rx_data)(ice, comp_id, transport_id, pkt, pkt_size,
 			      src_addr, src_addr_len);
 	status = PJ_SUCCESS;
     }
