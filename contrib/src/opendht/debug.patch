 include/opendht/dht_proxy_server.h |  1 +
 src/dht.cpp                        | 74 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 src/dht_proxy_client.cpp           |  6 ++++--
 src/search.h                       |  5 +++++
 4 files changed, 80 insertions(+), 6 deletions(-)

diff --git a/include/opendht/dht_proxy_server.h b/include/opendht/dht_proxy_server.h
index 5977129..f3cb64c 100644
--- a/include/opendht/dht_proxy_server.h
+++ b/include/opendht/dht_proxy_server.h
@@ -444,6 +444,7 @@ private:
     };
     std::mutex lockPushListeners_;
     std::map<std::string, PushListener> pushListeners_;
+    std::map<InfoHash, int> totalListeners_;
     proxy::ListenToken tokenPushNotif_ {0};
 #endif //OPENDHT_PUSH_NOTIFICATIONS
 };
diff --git a/src/dht.cpp b/src/dht.cpp
index 49ff12e..781695a 100644
--- a/src/dht.cpp
+++ b/src/dht.cpp
@@ -28,6 +28,7 @@
 #include <algorithm>
 #include <random>
 #include <sstream>
+#include <ios>
 #include <fstream>

 namespace dht {
@@ -451,16 +452,29 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
         const auto& now = scheduler.time();
         sr->insertNode(req.node, scheduler.time(), answer.ntoken);
         auto sn = sr->getNode(req.node);
-        if (not sn) return;
+        if (not sn) {
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ onSelectDone: return\n");
+            }
+            return;
+        }

         if (not sn->isSynced(now)) {
             /* Search is now unsynced. Let's call searchStep to sync again. */
             scheduler.edit(sr->nextSearchStep, now);
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ onSelectDone: return because unsynced\n");
+            }
             return;
         }
         for (auto& a : sr->announce) {
-            if (sn->getAnnounceTime(a.value->id) > now)
+            if (sn->getAnnounceTime(a.value->id) > now) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    printf("@@@ No need to announce value: %u (expiration: %zu vs %zu)\n",
+                        a.value->id, now.time_since_epoch().count(), sn->getAnnounceTime(a.value->id).time_since_epoch().count());
+                }
                 continue;
+            }
             bool hasValue {false};
             uint16_t seq_no = 0;
             try {
@@ -474,6 +488,13 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                 }
             } catch (std::out_of_range&) { }

+
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                std::stringstream oss;
+                oss << std::hex << a.value->id;
+                printf("@@@ For value %s - permanent(%u) - hasValue(%u)\n", oss.str().c_str(), a.permanent, hasValue);
+            }
+
             auto next_refresh_time = now + getType(a.value->type).expiration;
             /* only put the value if the node doesn't already have it */
             if (not hasValue or seq_no < a.value->seq) {
@@ -486,6 +507,11 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                     next_refresh_time
                 };
             } else if (hasValue and a.permanent) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    std::stringstream oss;
+                    oss << std::hex << a.value->id;
+                    printf("@@@ %zu SENDING PRESENCE REFRESH: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                }
                 if (logger_)
                     logger_->w(sr->id, sn->node->id, "[search %s] [node %s] sending 'refresh' (vid: %d)",
                         sr->id.toString().c_str(), sn->node->toString().c_str(), a.value->id);
@@ -517,10 +543,14 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
     static const auto PROBE_QUERY = std::make_shared<Query>(Select {}.field(Value::Field::Id).field(Value::Field::SeqNum));

     const auto& now = scheduler.time();
+    if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+        printf("@@@ %zu searchSendAnnounceValue for 529e3a6708878bf57c1aa99e563f2a26f63a41e4\n", now.time_since_epoch().count());
+    }
     for (auto& np : sr->nodes) {
         auto& n = *np;
-        if (not n.isSynced(now))
+        if (not n.isSynced(now)) {
             continue;
+        }

         auto gs = n.probe_query ? n.getStatus.find(n.probe_query) : n.getStatus.end();
         if (gs != n.getStatus.end() and gs->second and gs->second->pending()) {
@@ -530,6 +560,11 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
         bool sendQuery = false;
         for (auto& a : sr->announce) {
             if (n.getAnnounceTime(a.value->id) <= now) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    std::stringstream oss;
+                    oss << std::hex << a.value->id;
+                    printf("@@@ %zu For value %s, send: %u \n", now.time_since_epoch().count(), oss.str().c_str(), a.permanent);
+                }
                 if (a.permanent) {
                     sendQuery = true;
                 } else {
@@ -541,6 +576,10 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                         now + getType(a.value->type).expiration
                     };
                 }
+            } else if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                std::stringstream oss;
+                oss << std::hex << a.value->id;
+                printf("@@@ %zu For value %s, getAnnounceTime: %zu \n", now.time_since_epoch().count(), oss.str().c_str(), n.getAnnounceTime(a.value->id).time_since_epoch().count());
             }
         }

@@ -599,6 +638,10 @@ Dht::searchSynchedNodeListen(const Sp<Search>& sr, SearchNode& n)
             r->second.cacheExpirationJob = scheduler.add(time_point::max(), [this,ws,query,node=n.node]{
                 if (auto sr = ws.lock()) {
                     if (auto sn = sr->getNode(node)) {
+                        if (sn->node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+                            || sn->node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+                                printf("@@@ Expire for %s\n", sn->node->getId().toString().c_str());
+                            }
                         sn->expireValues(query, scheduler);
                     }
                 }
@@ -628,10 +671,28 @@ Dht::searchSynchedNodeListen(const Sp<Search>& sr, SearchNode& n)
             },
             [this,ws,query](const Sp<Node>& node, net::RequestAnswer&& answer) mutable
             { /* on new values */
+                auto now = scheduler.time();
                 if (auto sr = ws.lock()) {
                     scheduler.edit(sr->nextSearchStep, scheduler.time());
                     sr->insertNode(node, scheduler.time(), answer.ntoken);
                     if (auto sn = sr->getNode(node)) {
+                        if (sn->node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+                            || sn->node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+                            for (const auto& value: answer.values) {
+                                if (value->isSigned())
+                                    printf("@@@ %zu Received Value: %s\n", now.time_since_epoch().count(), value->toString().c_str());
+                            }
+                            for (const auto& vid: answer.expired_values) {
+                                std::stringstream oss;
+                                oss << std::hex << vid;
+                                printf("@@@ %zu Received expired vid: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                            }
+                            for (const auto& vid: answer.refreshed_values) {
+                                std::stringstream oss;
+                                oss << std::hex << vid;
+                                printf("@@@ %zu Received refresh for vid: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                            }
+                        }
                         sn->onValues(query, std::move(answer), types, scheduler);
                     }
                 }
@@ -717,7 +778,7 @@ Dht::searchStep(Sp<Search> sr)

     while (sr->currentlySolicitedNodeCount() < MAX_REQUESTED_SEARCH_NODES and searchSendGetValues(sr));

-
+
     if (sr->getNumberOfConsecutiveBadNodes() >= std::min<size_t>(sr->nodes.size(), SEARCH_MAX_BAD_NODES))
     {
         if (logger_)
@@ -825,6 +886,11 @@ Dht::announce(const InfoHash& id,
 {
     auto& srs = searches(af);
     auto srp = srs.find(id);
+    if (permanent && id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+        std::stringstream oss;
+        oss << std::hex << value->id;
+        printf("@@@ ANNOUNCE PRESENCE FOR id: %s\n", oss.str().c_str());
+    }
     if (auto sr = srp == srs.end() ? search(id, af) : srp->second) {
         sr->put(value, callback, created, permanent);
         scheduler.edit(sr->nextSearchStep, scheduler.time());
diff --git a/src/dht_proxy_client.cpp b/src/dht_proxy_client.cpp
index 18f9c52..0399d79 100644
--- a/src/dht_proxy_client.cpp
+++ b/src/dht_proxy_client.cpp
@@ -119,6 +119,7 @@ DhtProxyClient::DhtProxyClient(
     jsonBuilder_["commentStyle"] = "None";
     jsonBuilder_["indentation"] = "";
     if (logger_) {
+        logger_->e("@@@ Will use pushSessionId_ %s with %s", pushSessionId_.c_str(), proxyUrl_.c_str());
         if (serverCertificate_)
             logger_->d("[proxy:client] using ca certificate for ssl:\n%s",
                        serverCertificate_->toString(false/*chain*/).c_str());
@@ -1156,8 +1157,9 @@ DhtProxyClient::pushNotificationReceived(const std::map<std::string, std::string
     try {
         auto sessionId = notification.find("s");
         if (sessionId != notification.end() and sessionId->second != pushSessionId_) {
-            if (logger_)
-                logger_->d("[proxy:client] [push] ignoring push for other session");
+            if (logger_) {
+                logger_->d("[proxy:client] [push] ignoring push for other session (%s vs %s)", pushSessionId_.c_str(), sessionId->second.c_str());
+            }
             return;
         }
         std::lock_guard<std::mutex> lock(searchLock_);
diff --git a/src/search.h b/src/search.h
index b02f2a7..6b28a2d 100644
--- a/src/search.h
+++ b/src/search.h
@@ -233,6 +233,11 @@ struct Dht::SearchNode {
     }

     void expireValues(const Sp<Query>& q, Scheduler& scheduler) {
+        if (node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+         || node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+            printf("@@@ Expire values for %s\n", node->getId().toString().c_str());
+        }
+
         auto l = listenStatus.find(q);
         if (l != listenStatus.end()) {
             auto next = l->second.cache.expireValues(scheduler.time());
