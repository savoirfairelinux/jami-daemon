 include/opendht/dht_proxy_server.h |  1 +
 src/dht.cpp                        | 83 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 src/dht_proxy_client.cpp           |  6 ++++--
 src/dht_proxy_server.cpp           | 43 ++++++++++++++++++++++++++++++++++++++++---
 src/search.h                       |  5 +++++
 5 files changed, 129 insertions(+), 9 deletions(-)

diff --git a/include/opendht/dht_proxy_server.h b/include/opendht/dht_proxy_server.h
index a3720d1..639fbda 100644
--- a/include/opendht/dht_proxy_server.h
+++ b/include/opendht/dht_proxy_server.h
@@ -379,6 +379,7 @@ private:
     };
     std::mutex lockPushListeners_;
     std::map<std::string, PushListener> pushListeners_;
+    std::map<InfoHash, int> totalListeners_;
     proxy::ListenToken tokenPushNotif_ {0};
 #endif //OPENDHT_PUSH_NOTIFICATIONS
 };
diff --git a/src/dht.cpp b/src/dht.cpp
index 49ff12e..a662cdf 100644
--- a/src/dht.cpp
+++ b/src/dht.cpp
@@ -28,6 +28,7 @@
 #include <algorithm>
 #include <random>
 #include <sstream>
+#include <ios>
 #include <fstream>

 namespace dht {
@@ -451,16 +452,29 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
         const auto& now = scheduler.time();
         sr->insertNode(req.node, scheduler.time(), answer.ntoken);
         auto sn = sr->getNode(req.node);
-        if (not sn) return;
+        if (not sn) {
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ onSelectDone: return\n");
+            }
+            return;
+        }

         if (not sn->isSynced(now)) {
             /* Search is now unsynced. Let's call searchStep to sync again. */
             scheduler.edit(sr->nextSearchStep, now);
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ onSelectDone: return because unsynced\n");
+            }
             return;
         }
         for (auto& a : sr->announce) {
-            if (sn->getAnnounceTime(a.value->id) > now)
+            if (sn->getAnnounceTime(a.value->id) > now) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    printf("@@@ No need to announce value: %u (expiration: %u vs %u)\n",
+                        a.value->id, now.time_since_epoch().count(), sn->getAnnounceTime(a.value->id).time_since_epoch().count());
+                }
                 continue;
+            }
             bool hasValue {false};
             uint16_t seq_no = 0;
             try {
@@ -474,6 +488,13 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                 }
             } catch (std::out_of_range&) { }

+
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                std::stringstream oss;
+                oss << std::hex << a.value->id;
+                printf("@@@ For value %s - permanent(%u) - hasValue(%u)\n", oss.str().c_str(), a.permanent, hasValue);
+            }
+
             auto next_refresh_time = now + getType(a.value->type).expiration;
             /* only put the value if the node doesn't already have it */
             if (not hasValue or seq_no < a.value->seq) {
@@ -486,6 +507,11 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                     next_refresh_time
                 };
             } else if (hasValue and a.permanent) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    std::stringstream oss;
+                    oss << std::hex << a.value->id;
+                    printf("@@@ %u SENDING PRESENCE REFRESH: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                }
                 if (logger_)
                     logger_->w(sr->id, sn->node->id, "[search %s] [node %s] sending 'refresh' (vid: %d)",
                         sr->id.toString().c_str(), sn->node->toString().c_str(), a.value->id);
@@ -517,19 +543,34 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
     static const auto PROBE_QUERY = std::make_shared<Query>(Select {}.field(Value::Field::Id).field(Value::Field::SeqNum));

     const auto& now = scheduler.time();
+    if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+        printf("@@@ %u searchSendAnnounceValue for 529e3a6708878bf57c1aa99e563f2a26f63a41e4\n", now.time_since_epoch().count());
+    }
     for (auto& np : sr->nodes) {
         auto& n = *np;
-        if (not n.isSynced(now))
+        if (not n.isSynced(now)) {
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ %u not synced, continue\n", now.time_since_epoch().count());
+            }
             continue;
+        }

         auto gs = n.probe_query ? n.getStatus.find(n.probe_query) : n.getStatus.end();
         if (gs != n.getStatus.end() and gs->second and gs->second->pending()) {
+            if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                printf("@@@ %u continue at gs != n.getStatus.end()...\n", now.time_since_epoch().count());
+            }
             continue;
         }

         bool sendQuery = false;
         for (auto& a : sr->announce) {
             if (n.getAnnounceTime(a.value->id) <= now) {
+                if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                    std::stringstream oss;
+                    oss << std::hex << a.value->id;
+                    printf("@@@ %u For value %s, send: %u \n", now.time_since_epoch().count(), oss.str().c_str(), a.permanent);
+                }
                 if (a.permanent) {
                     sendQuery = true;
                 } else {
@@ -541,8 +582,15 @@ void Dht::searchSendAnnounceValue(const Sp<Search>& sr) {
                         now + getType(a.value->type).expiration
                     };
                 }
+            } else if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+                std::stringstream oss;
+                oss << std::hex << a.value->id;
+                printf("@@@ %u For value %s, getAnnounceTime: %u \n", now.time_since_epoch().count(), oss.str().c_str(), n.getAnnounceTime(a.value->id).time_since_epoch().count());
             }
         }
+        if (sr->id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+            printf("@@@ %u sendQuery = %u\n", now.time_since_epoch().count(), sendQuery);
+        }

         if (sendQuery) {
             n.probe_query = PROBE_QUERY;
@@ -599,6 +647,10 @@ Dht::searchSynchedNodeListen(const Sp<Search>& sr, SearchNode& n)
             r->second.cacheExpirationJob = scheduler.add(time_point::max(), [this,ws,query,node=n.node]{
                 if (auto sr = ws.lock()) {
                     if (auto sn = sr->getNode(node)) {
+                        if (sn->node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+                            || sn->node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+                                printf("@@@ Expire for %s\n", sn->node->getId().toString().c_str());
+                            }
                         sn->expireValues(query, scheduler);
                     }
                 }
@@ -628,10 +680,28 @@ Dht::searchSynchedNodeListen(const Sp<Search>& sr, SearchNode& n)
             },
             [this,ws,query](const Sp<Node>& node, net::RequestAnswer&& answer) mutable
             { /* on new values */
+                auto now = scheduler.time();
                 if (auto sr = ws.lock()) {
                     scheduler.edit(sr->nextSearchStep, scheduler.time());
                     sr->insertNode(node, scheduler.time(), answer.ntoken);
                     if (auto sn = sr->getNode(node)) {
+                        if (sn->node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+                            || sn->node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+                            for (const auto& value: answer.values) {
+                                if (value->isSigned())
+                                    printf("@@@ %u Received Value: %s\n", now.time_since_epoch().count(), value->toString().c_str());
+                            }
+                            for (const auto& vid: answer.expired_values) {
+                                std::stringstream oss;
+                                oss << std::hex << vid;
+                                printf("@@@ %u Received expired vid: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                            }
+                            for (const auto& vid: answer.refreshed_values) {
+                                std::stringstream oss;
+                                oss << std::hex << vid;
+                                printf("@@@ %u Received refresh for vid: %s\n", now.time_since_epoch().count(), oss.str().c_str());
+                            }
+                        }
                         sn->onValues(query, std::move(answer), types, scheduler);
                     }
                 }
@@ -717,7 +787,7 @@ Dht::searchStep(Sp<Search> sr)

     while (sr->currentlySolicitedNodeCount() < MAX_REQUESTED_SEARCH_NODES and searchSendGetValues(sr));

-
+
     if (sr->getNumberOfConsecutiveBadNodes() >= std::min<size_t>(sr->nodes.size(), SEARCH_MAX_BAD_NODES))
     {
         if (logger_)
@@ -825,6 +895,11 @@ Dht::announce(const InfoHash& id,
 {
     auto& srs = searches(af);
     auto srp = srs.find(id);
+    if (permanent && id.toString() == "529e3a6708878bf57c1aa99e563f2a26f63a41e4") {
+        std::stringstream oss;
+        oss << std::hex << value->id;
+        printf("@@@ ANNOUNCE PRESENCE FOR id: %s\n", oss.str().c_str());
+    }
     if (auto sr = srp == srs.end() ? search(id, af) : srp->second) {
         sr->put(value, callback, created, permanent);
         scheduler.edit(sr->nextSearchStep, scheduler.time());
diff --git a/src/dht_proxy_client.cpp b/src/dht_proxy_client.cpp
index 3406f46..1f82503 100644
--- a/src/dht_proxy_client.cpp
+++ b/src/dht_proxy_client.cpp
@@ -119,6 +119,7 @@ DhtProxyClient::DhtProxyClient(
     jsonBuilder_["commentStyle"] = "None";
     jsonBuilder_["indentation"] = "";
     if (logger_) {
+        logger_->e("@@@ Will use pushSessionId_ %s with %s", pushSessionId_.c_str(), proxyUrl_.c_str());
         if (serverCertificate_)
             logger_->d("[proxy:client] using ca certificate for ssl:\n%s",
                        serverCertificate_->toString(false/*chain*/).c_str());
@@ -1156,8 +1157,9 @@ DhtProxyClient::pushNotificationReceived(const std::map<std::string, std::string
     try {
         auto sessionId = notification.find("s");
         if (sessionId != notification.end() and sessionId->second != pushSessionId_) {
-            if (logger_)
-                logger_->d("[proxy:client] [push] ignoring push for other session");
+            if (logger_) {
+                logger_->d("[proxy:client] [push] ignoring push for other session (%s vs %s)", pushSessionId_.c_str(), sessionId->second.c_str());
+            }
             return;
         }
         std::lock_guard<std::mutex> lock(searchLock_);
diff --git a/src/dht_proxy_server.cpp b/src/dht_proxy_server.cpp
index ebc6b6f..3523a7c 100644
--- a/src/dht_proxy_server.cpp
+++ b/src/dht_proxy_server.cpp
@@ -145,6 +145,14 @@ DhtProxyServer::onConnectionClosed(restinio::connection_id_t id)
     std::lock_guard<std::mutex> lock(lockListener_);
     auto it = listeners_.find(id);
     if (it != listeners_.end()) {
+        auto itTL = totalListeners_.find(it->second.hash);
+        if (itTL != totalListeners_.end()) {
+            if (itTL->second == 1) {
+                totalListeners_.erase(itTL);
+            } else {
+                itTL->second -= 1;
+            }
+        }
         dht_->cancelListen(it->second.hash, std::move(it->second.token));
         listeners_.erase(it);
         if (logger_)
@@ -501,7 +509,18 @@ DhtProxyServer::getStats(restinio::request_handle_t request,
     try {
         if (auto stats = stats_) {
             auto response = initHttpResponse(request->create_response());
-            response.append_body(Json::writeString(jsonBuilder_, stats->toJson()) + "\n");
+            auto json = stats->toJson();
+            Json::Value puts;
+            for (const auto& put: puts_) {
+                puts[put.first.toString()] = std::to_string(put.second.puts.size());
+            }
+            json["puts"] = puts;
+            Json::Value listeners;
+            for (const auto& l: totalListeners_) {
+                listeners[l.first.toString()] = l.second;
+            }
+            json["listeners"] = listeners;
+            response.append_body(Json::writeString(jsonBuilder_, json) + "\n");
             return response.done();
         } else {
             auto response = initHttpResponse(request->create_response(restinio::status_service_unavailable()));
@@ -561,6 +580,11 @@ DhtProxyServer::listen(restinio::request_handle_t request,
         auto &session = listeners_[request->connection_id()];
         session.hash = infoHash;
         session.response = response;
+        auto it = totalListeners_.find(infoHash);
+        if (it == totalListeners_.end())
+            it->second = 0;
+        it->second += 1;
+
         session.token = dht_->listen(infoHash, [this, response]
                 (const std::vector<Sp<Value>>& values, bool expired){
             for (const auto& value: values){
@@ -666,6 +690,11 @@ DhtProxyServer::subscribe(restinio::request_handle_t request,
         listener.sessionCtx->sessionId = sessionId;

         // Add listen on dht
+        auto it = totalListeners_.find(infoHash);
+        if (it == totalListeners_.end())
+            it->second = 0;
+        it->second += 1;
+
         listener.internalToken = dht_->listen(infoHash,
             [this, infoHash, pushToken, isAndroid, clientId, sessionCtx = listener.sessionCtx]
             (const std::vector<std::shared_ptr<Value>>& values, bool expired){
@@ -804,6 +833,14 @@ DhtProxyServer::handleCancelPushListen(const asio::error_code &ec, const std::st

     for (auto listener = listeners->second.begin(); listener != listeners->second.end();){
         if (listener->clientId == clientId){
+            auto it = totalListeners_.find(key);
+            if (it != totalListeners_.end()) {
+                if (it->second == 1) {
+                    totalListeners_.erase(it);
+                } else {
+                    it->second -= 1;
+                }
+            }
             if (dht_)
                 dht_->cancelListen(key, std::move(listener->internalToken));
             listener = listeners->second.erase(listener);
@@ -946,8 +983,8 @@ DhtProxyServer::put(restinio::request_handle_t request,
                 auto& sPuts = puts_[infoHash];
                 if (value->id == Value::INVALID_ID) {
                     for (auto& pp : sPuts.puts) {
-                        if (pp.second.pushToken == pushToken
-                            and pp.second.clientId == clientId
+                        if (pp.second.pushToken == pushToken
+                            and pp.second.clientId == clientId
                             and pp.second.value->contentEquals(*value))
                         {
                             pp.second.expireTimer->expires_at(timeout);
diff --git a/src/search.h b/src/search.h
index b02f2a7..6b28a2d 100644
--- a/src/search.h
+++ b/src/search.h
@@ -233,6 +233,11 @@ struct Dht::SearchNode {
     }

     void expireValues(const Sp<Query>& q, Scheduler& scheduler) {
+        if (node->getId().toString() == "1bcc64b384455b31dca5e9ba55e2752b326333e7"
+         || node->getId().toString() == "52d7f158d97563ad0e0644ae25eeceed5a92c865") {
+            printf("@@@ Expire values for %s\n", node->getId().toString().c_str());
+        }
+
         auto l = listenStatus.find(q);
         if (l != listenStatus.end()) {
             auto next = l->second.cache.expireValues(scheduler.time());
