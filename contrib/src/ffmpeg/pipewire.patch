From 9bae1f51e43a49d7ac8b9a2998010d772af52b67 Mon Sep 17 00:00:00 2001
From: Firas Ashkar <firas.ashkar@savoirfairelinux.com>
Date: Mon, 20 Dec 2021 15:48:21 -0500
Subject: [PATCH] libavdevice: add pipewire based grab

1. add gdbus/pipewire logic, this is based on obs-xdg, gstpipewire and
   pipewire examples, and
2. add initial pipewire grab logic, this is based on libavdevice/xcbgrab
   and libavdevice/v4l2

Change-Id: I896ccfa4df2ab69a88c5d1897832068afa5ccd51
---

diff --git a/configure b/configure
index 0ccd3bd..b4eaaad 100755
--- a/configure
+++ b/configure
@@ -295,6 +295,7 @@
   --enable-libxcb-shm      enable X11 grabbing shm communication [autodetect]
   --enable-libxcb-xfixes   enable X11 grabbing mouse rendering [autodetect]
   --enable-libxcb-shape    enable X11 grabbing shape rendering [autodetect]
+  --enable-libpipewire     enable screen grabbing using pipewire [autodetect]
   --enable-libxvid         enable Xvid encoding via xvidcore,
                            native MPEG-4/Xvid encoder exists [no]
   --enable-libxml2         enable XML parsing using the C library libxml2, needed
@@ -1756,6 +1757,8 @@
     libxcb_shm
     libxcb_shape
     libxcb_xfixes
+    libpipewire
+    libgio_unix
     lzma
     mediafoundation
     metal
@@ -3524,6 +3527,7 @@
 vfwcap_indev_deps="vfw32 vfwcap_defines"
 xcbgrab_indev_deps="libxcb"
 xcbgrab_indev_suggest="libxcb_shm libxcb_shape libxcb_xfixes"
+pipewiregrab_indev_deps="libpipewire libgio_unix pthreads"
 xv_outdev_deps="xlib_xv xlib_x11 xlib_xext"
 
 # protocols
@@ -6836,6 +6840,11 @@
     enabled libxcb_xfixes && check_pkg_config libxcb_xfixes xcb-xfixes xcb/xfixes.h xcb_xfixes_get_cursor_image
 fi
 
+enabled libpipewire && check_pkg_config libpipewire "libpipewire-0.3 >= 0.3.40" pipewire/pipewire.h pw_init
+if enabled libpipewire; then
+    enabled libgio_unix && check_pkg_config libgio_unix gio-unix-2.0 gio/gio.h g_main_loop_new
+fi
+
 check_func_headers "windows.h" CreateDIBSection "$gdigrab_indev_extralibs"
 
 # d3d11va requires linking directly to dxgi and d3d11 if not building for
diff --git a/libavdevice/Makefile b/libavdevice/Makefile
index 0dfe47a..cc50820 100644
--- a/libavdevice/Makefile
+++ b/libavdevice/Makefile
@@ -48,6 +48,7 @@
 OBJS-$(CONFIG_V4L2_OUTDEV)               += v4l2enc.o v4l2-common.o
 OBJS-$(CONFIG_VFWCAP_INDEV)              += vfwcap.o
 OBJS-$(CONFIG_XCBGRAB_INDEV)             += xcbgrab.o
+OBJS-$(CONFIG_PIPEWIREGRAB_INDEV)        += pipewiregrab.o
 OBJS-$(CONFIG_XV_OUTDEV)                 += xv.o
 
 # external libraries
diff --git a/libavdevice/alldevices.c b/libavdevice/alldevices.c
index fbbe187..25afdac 100644
--- a/libavdevice/alldevices.c
+++ b/libavdevice/alldevices.c
@@ -54,6 +54,7 @@
 extern const AVOutputFormat ff_v4l2_muxer;
 extern const AVInputFormat  ff_vfwcap_demuxer;
 extern const AVInputFormat  ff_xcbgrab_demuxer;
+extern const AVInputFormat  ff_pipewiregrab_demuxer;
 extern const AVOutputFormat ff_xv_muxer;
 
 /* external libraries */
diff --git a/libavdevice/pipewiregrab.c b/libavdevice/pipewiregrab.c
new file mode 100644
index 0000000..068f0dd
--- /dev/null
+++ b/libavdevice/pipewiregrab.c
@@ -0,0 +1,1808 @@
+/*
+ * PipeWire input grabber (ScreenCast)
+ * Copyright (C) 2022 Savoir-faire Linux, Inc. <support@savoirfairelinux.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include <fcntl.h>
+#include <linux/dma-buf.h>
+#include <math.h>
+#include <pthread.h>
+#include <stdatomic.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/queue.h>
+
+#include "libavutil/internal.h"
+#include "libavutil/mathematics.h"
+#include "libavutil/opt.h"
+#include "libavutil/parseutils.h"
+#include "libavutil/time.h"
+
+#include "libavformat/avformat.h"
+#include "libavformat/internal.h"
+
+#include <pipewire/pipewire.h>
+#include <pipewire/thread-loop.h>
+#include <spa/debug/types.h>
+#include <spa/param/video/format-utils.h>
+#include <spa/param/video/type-info.h>
+
+#include <gio/gio.h>
+#include <gio/gunixfdlist.h>
+
+#ifndef __USE_XOPEN2K8
+#define F_DUPFD_CLOEXEC                                                        \
+    1030                        /* Duplicate file descriptor with close-on-exit set.  */
+#endif
+
+#define BYTES_PER_PIXEL 4       /* currently all formats assume 4 bytes per pixel */
+#define REQUEST_PATH "/org/freedesktop/portal/desktop/request/%s/obs%u"
+#define SESSION_PATH "/org/freedesktop/portal/desktop/session/%s/obs%u"
+
+typedef enum {
+    DESKTOP_CAPTURE = 1,
+    WINDOW_CAPTURE = 2,
+} pw_capture_type;
+
+#define CQ_MAX_SIZE 10
+
+/**
+ * CircularQueue instance
+ * This instance contains the dynamically allocated AVPacket struct
+ */
+struct avpacket_entry {
+    AVPacket *cq_pkt;
+     CIRCLEQ_ENTRY(avpacket_entry)
+     entries;                   /* Queue */
+};
+
+CIRCLEQ_HEAD(circularqueue, avpacket_entry);
+
+/**
+ * PipeWire Grab main structure
+ * Contains all necessary data that hold current state
+ * Initial state of this struct is allocated by libavdevice
+ * logic when declaring the AVInputFormat ff_pipewiregrab_demuxer.
+ * This structure is priv_data of AVFormatContext instance.
+ */
+typedef struct PipewireGrabContext {
+    /** thread used to intialize/start pipewire logic */
+    pthread_t pipewire_pthread;
+
+    /** conditional synchronization logic elecments between pipewire
+     * thread and libavdevice thread.
+     */
+    pthread_cond_t avstream_codec_cond_var;
+    pthread_cond_t read_packet_cond_var;
+    pthread_mutex_t avstream_codec_mutex;
+    pthread_mutex_t read_packet_mutex;
+    atomic_int avstream_codec_flag;
+
+    GDBusConnection *connection;
+    GDBusProxy *proxy;
+    GCancellable *cancellable;
+
+    char *sender_name;
+    char *session_handle;
+
+    uint32_t pipewire_node;
+    int pipewire_fd;
+
+    GMainLoop *glib_main_loop;
+    struct pw_thread_loop *thread_loop;
+    struct pw_context *context;
+
+    struct pw_core *core;
+    struct spa_hook core_listener;
+
+    struct pw_stream *stream;
+    struct spa_hook stream_listener;
+    struct spa_video_info format;
+    struct pw_buffer *current_pw_buffer;
+
+    pw_capture_type capture_type;
+    bool negotiated;
+
+    uint32_t width, height;
+    uint32_t frame_size;
+    uint8_t Bpp;
+    enum AVPixelFormat av_pxl_format;
+    AVRational user_frame_rate;
+
+    int64_t time_frame;
+    AVRational time_base;
+    int64_t frame_duration;
+
+    const AVClass *class;
+    const char *framerate;
+
+    struct circularqueue circular_queue_head;   /* CircularQueue head */
+    atomic_uint_fast8_t circular_queue_size;
+
+} PipewireGrabContext;
+
+/**
+ * dbus's method/event marshalling structure
+ */
+struct dbus_call_data {
+    AVFormatContext *ctx;
+    char *request_path;
+    guint signal_id;
+    gulong cancelled_id;
+};
+
+#define FOLLOW_CENTER -1
+
+#define OFFSET(x) offsetof(PipewireGrabContext, x)
+#define D AV_OPT_FLAG_DECODING_PARAM
+static const AVOption options[] = {
+    { "framerate",
+     "",
+     OFFSET(framerate),
+     AV_OPT_TYPE_STRING,
+     {.str = "ntsc"},
+     0,
+     0,
+     D },
+    { NULL },
+};
+
+/**
+ * AVStream creator
+ * This function creates a valid AVStream based on pipewire's negotiated
+ * params, then signal the blocked @ref pipewiregrab_read_header
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ * @return 0 on success, AVERROR on failure
+ */
+static int create_ffmpeg_stream(AVFormatContext * ctx)
+{
+    int ret = 0;
+    int64_t frame_size_bits;
+    AVStream *avstream = avformat_new_stream(ctx, NULL);
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (!avstream) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] avformat_new_stream failed!\n");
+        return AVERROR(ENOMEM);
+    }
+
+    avstream->avg_frame_rate.num = pw_ctx->user_frame_rate.num;
+    avstream->avg_frame_rate.den = pw_ctx->user_frame_rate.den;
+
+    avpriv_set_pts_info(avstream, 64, 1, 1000000);
+
+    pw_ctx->time_base = (AVRational) {
+    avstream->avg_frame_rate.den, avstream->avg_frame_rate.num};
+    pw_ctx->frame_duration =
+        av_rescale_q(1, pw_ctx->time_base, AV_TIME_BASE_Q);
+    pw_ctx->time_frame = av_gettime_relative();
+
+    frame_size_bits =
+        (int64_t) pw_ctx->width * pw_ctx->height * pw_ctx->Bpp * 8;
+    avstream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
+    avstream->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;
+    avstream->codecpar->width = pw_ctx->width;
+    avstream->codecpar->height = pw_ctx->height;
+    avstream->codecpar->bit_rate =
+        av_rescale(frame_size_bits, avstream->avg_frame_rate.num,
+                   avstream->avg_frame_rate.den);
+    avstream->codecpar->format = pw_ctx->av_pxl_format;
+
+    atomic_store(&pw_ctx->avstream_codec_flag, 1);
+    pthread_cond_signal(&pw_ctx->avstream_codec_cond_var);
+
+    return ret;
+}
+
+/**
+ * Pipewire manual abort
+ *
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ */
+
+static void pipewiregrab_abort(void *user_data, const char *message)
+{
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = NULL;
+    if (!ctx) {
+        return;
+    }
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    atomic_store(&pw_ctx->avstream_codec_flag, 1);
+    pthread_cond_signal(&pw_ctx->avstream_codec_cond_var);
+
+    atomic_store(&pw_ctx->circular_queue_size, 1);
+    pthread_cond_signal(&pw_ctx->read_packet_cond_var);
+
+    av_log(ctx, AV_LOG_ERROR, "[pipewiregrab] Aborting: %s\n", message);
+
+    if (pw_ctx->thread_loop != NULL)
+        pw_thread_loop_signal(pw_ctx->thread_loop, false);
+
+    if (pw_ctx->glib_main_loop != NULL &&
+        g_main_loop_is_running(pw_ctx->glib_main_loop)) {
+        g_main_loop_quit(pw_ctx->glib_main_loop);
+    }
+}
+
+/**
+ * Asynchronous pipewire core completion event
+ *
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ * @id pipewire object id of calling
+ * @seq pipewire object sequence
+ */
+static void on_core_done_callback(void *user_data, uint32_t id, int seq)
+{
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = NULL;
+    if (!ctx) {
+        return;
+    }
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    (void) seq;
+
+    if (id == PW_ID_CORE) {
+        pw_thread_loop_signal(pw_ctx->thread_loop, false);
+        g_main_loop_quit(pw_ctx->glib_main_loop);
+    }
+}
+
+/**
+ * Asynchronous pipewire core error event
+ *
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ * @id pipewire object id of calling
+ * @seq pipewire object sequence
+ * @res error number
+ * @message error message
+ */
+static void on_core_error_callback(void *user_data, uint32_t id, int seq,
+                                   int res, const char *message)
+{
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = NULL;
+    if (!ctx) {
+        return;
+    }
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    av_log(ctx, AV_LOG_ERROR,
+           "[pipewiregrab] Error id:%u seq:%d res:%d (%s): %s\n", id, seq,
+           res, g_strerror(res), message);
+
+    pw_thread_loop_signal(pw_ctx->thread_loop, false);
+    g_main_loop_quit(pw_ctx->glib_main_loop);
+}
+
+static const struct pw_core_events core_events = {
+    PW_VERSION_CORE_EVENTS,
+    .done = on_core_done_callback,
+    .error = on_core_error_callback,
+};
+
+/**
+ * helper function: create a new path to dbus desktop object request method
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ * @out_path dbus token count
+ * @out_token final object/interface path for request method
+ */
+static void new_request_path(AVFormatContext * ctx, char **out_path,
+                             char **out_token)
+{
+    static uint32_t request_token_count = 0;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    request_token_count++;
+
+    if (out_token) {
+        *out_token = g_strdup_printf("obs%u", request_token_count);
+    }
+
+    if (out_path) {
+        *out_path = g_strdup_printf(REQUEST_PATH, pw_ctx->sender_name,
+                                    request_token_count);
+    }
+}
+
+/**
+ * helper function: create new path to dbus active desktop session
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ * @out_path dbus session token count
+ * @out_token final object/interface path for active session
+ */
+static void new_session_path(AVFormatContext * ctx, char **out_path,
+                             char **out_token)
+{
+    static uint32_t session_token_count = 0;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    session_token_count++;
+
+    if (out_token) {
+        *out_token = g_strdup_printf("obs%u", session_token_count);
+    }
+
+    if (out_path) {
+        *out_path = g_strdup_printf(SESSION_PATH, pw_ctx->sender_name,
+                                    session_token_count);
+    }
+}
+
+/**
+ * helper function: convert spa format to FFmpeg av format
+ *
+ * @spa_format pipewire spa pixel format
+ * @return av pixel format
+ */
+static enum AVPixelFormat
+spa_pixel_format_to_av_pixel_format(uint32_t spa_format)
+{
+    enum AVPixelFormat ret = AV_PIX_FMT_NONE;
+    switch (spa_format) {
+    case SPA_VIDEO_FORMAT_RGBA:
+    case SPA_VIDEO_FORMAT_RGBx:
+        ret = AV_PIX_FMT_RGBA;
+        break;
+
+    case SPA_VIDEO_FORMAT_BGRA:
+    case SPA_VIDEO_FORMAT_BGRx:
+        ret = AV_PIX_FMT_BGRA;
+        break;
+
+    default:
+        ret = AV_PIX_FMT_NONE;
+    }
+
+    return ret;
+}
+
+/**
+ * helper function: queue/free current pipewire buffer
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static void maybe_queue_buffer(AVFormatContext * ctx)
+{
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    if (pw_ctx->current_pw_buffer) {
+        pw_stream_queue_buffer(pw_ctx->stream, pw_ctx->current_pw_buffer);
+        pw_ctx->current_pw_buffer = NULL;
+    }
+}
+
+/**
+ * helper function: gracefully stop/destroy of pipewire objects
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static void teardown_pipewire(AVFormatContext * ctx)
+{
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    maybe_queue_buffer(ctx);
+
+    if (pw_ctx->thread_loop) {
+        pw_thread_loop_unlock(pw_ctx->thread_loop);
+        pw_thread_loop_stop(pw_ctx->thread_loop);
+    }
+
+    if (pw_ctx->stream) {
+        pw_stream_disconnect(pw_ctx->stream);
+        g_clear_pointer(&pw_ctx->stream, pw_stream_destroy);
+    }
+
+    if (pw_ctx->core)
+        pw_core_disconnect(pw_ctx->core);
+
+    if (pw_ctx->context)
+        pw_context_destroy(pw_ctx->context);
+
+    if (pw_ctx->thread_loop) {
+        pw_thread_loop_destroy(pw_ctx->thread_loop);
+    }
+
+    pw_ctx->negotiated = false;
+}
+
+/**
+ * helper function: gracefully stop/destroy of dbus session
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static void destroy_session(AVFormatContext * ctx)
+{
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    if (pw_ctx->session_handle) {
+        g_dbus_connection_call(pw_ctx->connection,
+                               "org.freedesktop.portal.Desktop",
+                               pw_ctx->session_handle,
+                               "org.freedesktop.portal.Session", "Close",
+                               NULL, NULL, G_DBUS_CALL_FLAGS_NONE, -1,
+                               NULL, NULL, NULL);
+
+        g_clear_pointer(&pw_ctx->session_handle, g_free);
+    }
+
+    g_cancellable_cancel(pw_ctx->cancellable);
+    g_clear_object(&pw_ctx->cancellable);
+    g_clear_object(&pw_ctx->connection);
+    g_clear_object(&pw_ctx->proxy);
+    g_clear_pointer(&pw_ctx->sender_name, g_free);
+}
+
+/**
+ * helper function: gracefully stop/destroy of pipewire/dbus session
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static void pipewire_destroy(AVFormatContext * ctx)
+{
+    teardown_pipewire(ctx);
+    destroy_session(ctx);
+}
+
+/**
+ * Asynchronous callback to stop/disconnect current dbus session
+ *
+ * @ptr_dbus_call_data dbus marshalling structure
+ */
+static void dbus_call_data_free(struct dbus_call_data *ptr_dbus_call_data)
+{
+    AVFormatContext *ctx = NULL;
+    PipewireGrabContext *pw_ctx = NULL;
+
+    if (!ptr_dbus_call_data)
+        return;
+
+    ctx = ptr_dbus_call_data->ctx;
+    if (!ctx)
+        return;
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    if (ptr_dbus_call_data->signal_id)
+        g_dbus_connection_signal_unsubscribe(pw_ctx->connection,
+                                             ptr_dbus_call_data->
+                                             signal_id);
+
+    if (ptr_dbus_call_data->cancelled_id > 0)
+        g_signal_handler_disconnect(pw_ctx->cancellable,
+                                    ptr_dbus_call_data->cancelled_id);
+
+    g_clear_pointer(&ptr_dbus_call_data->request_path, g_free);
+    g_free(ptr_dbus_call_data);
+}
+
+/**
+ * Asynchronous dbus callback of cancelled events
+ *
+ * @cancellable not used
+ * @user_data dbus marshalling structure
+ */
+static void on_cancelled_callback(GCancellable * cancellable,
+                                  gpointer user_data)
+{
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    (void) cancellable;
+
+    av_log(ctx, AV_LOG_INFO,
+           "[pipewiregrab] Screencast session cancelled!\n");
+
+    g_dbus_connection_call(pw_ctx->connection,
+                           "org.freedesktop.portal.Desktop",
+                           ptr_dbus_call_data->request_path,
+                           "org.freedesktop.portal.Request", "Close", NULL,
+                           NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL,
+                           NULL);
+}
+
+/**
+ * Asynchronous pipewire callback of parameters changed events
+ *
+ * reflects changed pipewire video stream params, upon
+ * which some additional paramters can be updated
+ * before actual streaming starts
+ *
+ * @user_data dbus marshalling structure
+ * @id contains changed param type
+ * @param changed param structure
+ */
+static void on_stream_param_changed_callback(void *user_data, uint32_t id,
+                                             const struct spa_pod *param)
+{
+    struct spa_pod_builder pod_builder;
+    const struct spa_pod *params[3];
+    uint8_t params_buffer[4096];
+    int result;
+
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = NULL;
+    if (!ctx) {
+        return;
+    }
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    if (!param || id != SPA_PARAM_Format) {
+        av_log(ctx, AV_LOG_WARNING,
+               "[pipewiregrab] Ignoring none stream param format change!\n");
+        return;
+    }
+
+    result = spa_format_parse(param, &pw_ctx->format.media_type,
+                              &pw_ctx->format.media_subtype);
+    if (result < 0)
+        return;
+
+    if (pw_ctx->format.media_type != SPA_MEDIA_TYPE_video ||
+        pw_ctx->format.media_subtype != SPA_MEDIA_SUBTYPE_raw)
+        return;
+
+    spa_format_video_raw_parse(param, &pw_ctx->format.info.raw);
+
+    av_log(ctx, AV_LOG_INFO, "[pipewiregrab] Negotiated format:\n");
+
+    av_log(ctx, AV_LOG_INFO, "[pipewiregrab]     Format: %d (%s)\n",
+           pw_ctx->format.info.raw.format,
+           spa_debug_type_find_name(spa_type_video_format,
+                                    pw_ctx->format.info.raw.format));
+    av_log(ctx, AV_LOG_INFO, "[pipewiregrab]     Size: %dx%d\n",
+           pw_ctx->format.info.raw.size.width,
+           pw_ctx->format.info.raw.size.height);
+    av_log(ctx, AV_LOG_INFO, "[pipewiregrab]     Framerate: %d/%d\n",
+           pw_ctx->format.info.raw.framerate.num,
+           pw_ctx->format.info.raw.framerate.denom);
+
+    pw_ctx->width = pw_ctx->format.info.raw.size.width;
+    pw_ctx->height = pw_ctx->format.info.raw.size.height;
+    pw_ctx->Bpp = BYTES_PER_PIXEL;
+    pw_ctx->frame_size = pw_ctx->width * pw_ctx->height * pw_ctx->Bpp;
+    pw_ctx->av_pxl_format =
+        spa_pixel_format_to_av_pixel_format(pw_ctx->format.info.raw.
+                                            format);
+
+    /* Video crop */
+    pod_builder =
+        SPA_POD_BUILDER_INIT(params_buffer, sizeof(params_buffer));
+    params[0] =
+        spa_pod_builder_add_object(&pod_builder, SPA_TYPE_OBJECT_ParamMeta,
+                                   SPA_PARAM_Meta, SPA_PARAM_META_type,
+                                   SPA_POD_Id(SPA_META_VideoCrop),
+                                   SPA_PARAM_META_size,
+                                   SPA_POD_Int(sizeof
+                                               (struct spa_meta_region)));
+
+    /* Buffer options */
+    params[1] =
+        spa_pod_builder_add_object(&pod_builder,
+                                   SPA_TYPE_OBJECT_ParamBuffers,
+                                   SPA_PARAM_Buffers,
+                                   SPA_PARAM_BUFFERS_dataType,
+                                   SPA_POD_Int((1 << SPA_DATA_MemPtr) |
+                                               (1 << SPA_DATA_DmaBuf) | (1
+                                                                         <<
+                                                                         SPA_DATA_MemPtr)));
+
+    pw_stream_update_params(pw_ctx->stream, params, 2);
+
+    pw_ctx->negotiated = true;
+
+    create_ffmpeg_stream(ctx);
+}
+
+/**
+ * Asynchronous pipewire callback containing captured data
+ *
+ * Main callback returning the actual captured pipewire
+ * buffered video stream data. This buffered data is
+ * passed back to libavdevice et al logic as a new AVPacket.
+ *
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ */
+static void on_stream_process_callback(void *user_data)
+{
+    struct spa_buffer *spa_buf = NULL;
+    struct pw_buffer *pw_buf = NULL;
+    uint8_t *map = NULL;
+    size_t mmap_size;
+    void *sdata = NULL;
+    bool has_buffer;
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = NULL;
+    int64_t pts = av_gettime();
+
+    ctx = user_data;
+    if (!ctx) {
+        return;
+    }
+
+    pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    /* Find the most recent buffer */
+    pw_buf = NULL;
+    while (true) {
+        struct pw_buffer *aux = pw_stream_dequeue_buffer(pw_ctx->stream);
+        if (!aux)
+            break;
+        if (pw_buf)
+            pw_stream_queue_buffer(pw_ctx->stream, pw_buf);
+        pw_buf = aux;
+    }
+
+    if (pw_buf == NULL) {
+        av_log(ctx, AV_LOG_ERROR, "[pipewiregrab] Out of buffers!\n");
+        return;
+    }
+
+    spa_buf = pw_buf->buffer;
+    has_buffer = spa_buf->datas[0].chunk->size != 0;
+
+    // av_log( ctx, AV_LOG_DEBUG, "got new buffer @ %p\n", spa_buf );
+
+    pw_ctx->current_pw_buffer = pw_buf;
+
+    if (pw_ctx->av_pxl_format == AV_PIX_FMT_NONE) {
+        av_log(ctx, AV_LOG_WARNING,
+               "[pipewiregrab] unsupported buffer format: %d\n",
+               pw_ctx->format.info.raw.format);
+        goto queue_buffer;
+    }
+
+    if (!has_buffer)
+        goto queue_buffer;
+
+    // av_log( ctx, AV_LOG_DEBUG, "[pipewiregrab] datas[0].type %u \n", spa_buf->datas[0].type );
+
+    if (spa_buf->datas[0].type == SPA_DATA_MemFd ||
+        spa_buf->datas[0].type == SPA_DATA_DmaBuf) {
+        mmap_size =
+            spa_buf->datas[0].maxsize + spa_buf->datas[0].mapoffset;
+        map =
+            mmap(NULL, mmap_size, PROT_READ, MAP_PRIVATE,
+                 spa_buf->datas[0].fd, 0);
+        if (map == MAP_FAILED) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] mmap failed! error %s\n",
+                   g_strerror(errno));
+            return;
+        }
+
+        sdata = SPA_PTROFF(map, spa_buf->datas[0].mapoffset, uint8_t);
+    } else if (spa_buf->datas[0].type == SPA_DATA_MemPtr) {
+        if (spa_buf->datas[0].data == NULL) {
+            av_log(ctx, AV_LOG_ERROR, "[pipewiregrab] no data!\n");
+            return;
+        }
+        sdata = spa_buf->datas[0].data;
+    } else {
+        av_log(ctx, AV_LOG_ERROR, "[pipewiregrab] Buffer is not valid!\n");
+        return;
+    }
+
+    /* transfer new captured buffer to pkt circular queue */
+    if (atomic_load(&pw_ctx->circular_queue_size) < CQ_MAX_SIZE) {
+        struct avpacket_entry *pkte = NULL;
+        AVPacket *pkt = NULL;
+        int ret = 0;
+
+        pkt = av_packet_alloc();
+        if (pkt == NULL) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Failed to allocate new av packet\n");
+
+            if (map != NULL) {
+                munmap(map, mmap_size);
+            }
+
+            return;
+        }
+
+        /* create buf and reset packet size to frame_size */
+        ret = av_new_packet(pkt, pw_ctx->frame_size);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Failed to create new av packet, error: %s\n",
+                   av_err2str(ret));
+
+            if (map != NULL) {
+                munmap(map, mmap_size);
+            }
+
+            return;
+        }
+
+        pkt->dts = pkt->pts = pts;
+        pkt->duration = pw_ctx->frame_duration;
+        memcpy(pkt->data, sdata, pw_ctx->frame_size);
+        if (map != NULL) {
+            munmap(map, mmap_size);
+        }
+
+        pkte = malloc(sizeof(struct avpacket_entry));
+        if (pkte == NULL) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Failed to allocate new packet CQ entry\n");
+            av_packet_free(&pkt);
+            return;
+        }
+
+        pkte->cq_pkt = pkt;
+        CIRCLEQ_INSERT_TAIL(&pw_ctx->circular_queue_head, pkte, entries);
+        atomic_fetch_add(&pw_ctx->circular_queue_size, 1);
+        pthread_cond_signal(&pw_ctx->read_packet_cond_var);
+    }
+
+  queue_buffer:
+
+    maybe_queue_buffer(ctx);
+}
+
+/**
+ * PipeWire stream event callback structure
+ */
+
+static const struct pw_stream_events stream_events = {
+    PW_VERSION_STREAM_EVENTS,
+    .param_changed = on_stream_param_changed_callback,
+    .process = on_stream_process_callback,
+};
+
+/**
+ * dbus signal/event subscriber
+ *
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ * @path path to dbus object path
+ * @callback pointer to function that will be called asynchronousely
+ */
+static struct dbus_call_data *subscribe_to_signal(AVFormatContext * ctx,
+                                                  const char *path,
+                                                  GDBusSignalCallback
+                                                  callback)
+{
+    struct dbus_call_data *ptr_dbus_call_data;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return NULL;
+    }
+
+    ptr_dbus_call_data = g_new0(struct dbus_call_data, 1);
+    ptr_dbus_call_data->ctx = ctx;
+    ptr_dbus_call_data->request_path = g_strdup(path);
+    ptr_dbus_call_data->cancelled_id =
+        g_signal_connect(pw_ctx->cancellable, "cancelled",
+                         G_CALLBACK(on_cancelled_callback),
+                         ptr_dbus_call_data /* user_data */ );
+    ptr_dbus_call_data->signal_id =
+        g_dbus_connection_signal_subscribe(pw_ctx->connection,
+                                           "org.freedesktop.portal.Desktop"
+                                           /*sender */ ,
+                                           "org.freedesktop.portal.Request"
+                                           /*interface_name */ ,
+                                           "Response"
+                                           /*member: dbus signal name */ ,
+                                           ptr_dbus_call_data->
+                                           request_path /*object_path */ ,
+                                           NULL,
+                                           G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE,
+                                           callback, ptr_dbus_call_data,
+                                           NULL);
+
+    return ptr_dbus_call_data;
+}
+
+/**
+ * create new pipewire video stream
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static int play_pipewire_stream(AVFormatContext * ctx)
+{
+    int ret = 0;
+    const struct spa_pod *ptr_spa_pod[1];
+    uint8_t buffer[4096];
+    struct spa_pod_builder spa_pod_bldr = {
+        0,
+    };
+
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return ret;
+    }
+
+    pw_ctx->thread_loop =
+        pw_thread_loop_new("[pipewiregrab] thread loop", NULL);
+    if (pw_ctx->thread_loop == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] pw_thread_loop_new failed!\n");
+        ret = AVERROR(ENOMEM);
+        return ret;
+    }
+
+    pw_ctx->context =
+        pw_context_new(pw_thread_loop_get_loop(pw_ctx->thread_loop), NULL,
+                       0);
+    if (pw_ctx->context == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] pw_context_new failed!\n");
+        ret = AVERROR(ENOMEM);
+        goto thread_loop_destroy;
+    }
+
+    if (pw_thread_loop_start(pw_ctx->thread_loop) < 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] pw_thread_loop_start failed!\n");
+        ret = AVERROR(EFAULT);
+        goto context_destroy;
+    }
+
+    pw_thread_loop_lock(pw_ctx->thread_loop);
+
+    /* Core */
+    pw_ctx->core =
+        pw_context_connect_fd(pw_ctx->context,
+                              fcntl(pw_ctx->pipewire_fd, F_DUPFD_CLOEXEC,
+                                    3), NULL, 0);
+    if (pw_ctx->core == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] pw_context_connect_fd failed!\n");
+        ret = AVERROR(EFAULT);
+        pw_thread_loop_unlock(pw_ctx->thread_loop);
+        goto context_destroy;
+    }
+
+    pw_core_add_listener(pw_ctx->core, &pw_ctx->core_listener,
+                         &core_events, ctx /* user_data */ );
+
+    /* Stream */
+    pw_ctx->stream = pw_stream_new(pw_ctx->core, "wayland grab",
+                                   pw_properties_new(PW_KEY_MEDIA_TYPE,
+                                                     "Video",
+                                                     PW_KEY_MEDIA_CATEGORY,
+                                                     "Capture",
+                                                     PW_KEY_MEDIA_ROLE,
+                                                     "Screen", NULL));
+
+    if (pw_ctx->stream == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] pw_stream_new failed!\n");
+        ret = AVERROR(ENOMEM);
+        pw_thread_loop_unlock(pw_ctx->thread_loop);
+        goto core_disconnect;
+    }
+
+    pw_stream_add_listener(pw_ctx->stream, &pw_ctx->stream_listener,
+                           &stream_events, ctx /* user_data */ );
+
+    /* Stream parameters */
+    spa_pod_bldr = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
+    ptr_spa_pod[0] =
+        spa_pod_builder_add_object(&spa_pod_bldr, SPA_TYPE_OBJECT_Format,
+                                   SPA_PARAM_EnumFormat,
+                                   SPA_FORMAT_mediaType,
+                                   SPA_POD_Id(SPA_MEDIA_TYPE_video),
+                                   SPA_FORMAT_mediaSubtype,
+                                   SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),
+                                   SPA_FORMAT_VIDEO_format,
+                                   SPA_POD_CHOICE_ENUM_Id(4,
+                                                          SPA_VIDEO_FORMAT_RGBA,
+                                                          SPA_VIDEO_FORMAT_RGBx,
+                                                          SPA_VIDEO_FORMAT_BGRx,
+                                                          SPA_VIDEO_FORMAT_BGRA),
+                                   SPA_FORMAT_VIDEO_size,
+                                   SPA_POD_CHOICE_RANGE_Rectangle
+                                   (&SPA_RECTANGLE(320, 240),
+                                    &SPA_RECTANGLE(1, 1),
+                                    &SPA_RECTANGLE(4096, 4096)),
+                                   SPA_FORMAT_VIDEO_framerate,
+                                   SPA_POD_CHOICE_RANGE_Fraction
+                                   (&SPA_FRACTION
+                                    (pw_ctx->user_frame_rate.num,
+                                     pw_ctx->user_frame_rate.den),
+                                    &SPA_FRACTION(0, 1), &SPA_FRACTION(144,
+                                                                       1)));
+
+    ret =
+        pw_stream_connect(pw_ctx->stream, PW_DIRECTION_INPUT,
+                          pw_ctx->pipewire_node,
+                          PW_STREAM_FLAG_AUTOCONNECT |
+                          PW_STREAM_FLAG_MAP_BUFFERS, ptr_spa_pod, 1);
+
+    av_log(ctx, AV_LOG_INFO,
+           "[pipewiregrab] Starting screen capture ...\n");
+
+    pw_thread_loop_unlock(pw_ctx->thread_loop);
+
+    return ret;
+
+    /*
+     * disconnect from the server/daemon
+     * destroy the core proxy object and will remove the proxies
+     * that might have been created on this connection
+     */
+  core_disconnect:
+    pw_core_disconnect(pw_ctx->core);
+
+  context_destroy:
+    pw_context_destroy(pw_ctx->context);
+
+  thread_loop_destroy:
+    pw_thread_loop_destroy(pw_ctx->thread_loop);
+
+    return ret;
+}
+
+/**
+ * Asynchronous dbus event callback
+ *
+ * @source pointer to event source
+ * @res pointer callback state
+ * @user_data AVFormatContext that contains PipeWire Grab main structure
+ */
+static void on_pipewire_remote_opened_callback(GObject * source,
+                                               GAsyncResult * res,
+                                               gpointer user_data)
+{
+    g_autoptr(GUnixFDList) fd_list = NULL;
+    g_autoptr(GVariant) result = NULL;
+    g_autoptr(GError) error = NULL;
+    int fd_index;
+
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    result =
+        g_dbus_proxy_call_with_unix_fd_list_finish(G_DBUS_PROXY(source),
+                                                   &fd_list, res, &error);
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error retrieving pipewire fd: %s\n",
+                   error->message);
+
+        return;
+    }
+
+    g_variant_get(result, "(h)", &fd_index, &error);
+
+    pw_ctx->pipewire_fd = g_unix_fd_list_get(fd_list, fd_index, &error);
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error retrieving pipewire fd: %s\n",
+                   error->message);
+
+        return;
+    }
+
+    play_pipewire_stream(ctx);
+}
+
+/**
+ * start remote dbus desktop connection
+ *
+ * @ctx AVFormatContext that contains PipeWire Grab main structure
+ */
+static void open_pipewire_remote(AVFormatContext * ctx)
+{
+    GVariantBuilder builder;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+
+    g_dbus_proxy_call_with_unix_fd_list(pw_ctx->proxy,
+                                        "OpenPipeWireRemote",
+                                        g_variant_new("(oa{sv})",
+                                                      pw_ctx->
+                                                      session_handle,
+                                                      &builder),
+                                        G_DBUS_CALL_FLAGS_NONE, -1, NULL,
+                                        pw_ctx->cancellable,
+                                        on_pipewire_remote_opened_callback,
+                                        ctx /* user_data */ );
+}
+
+/**
+ * Asynchronous dbus callback received upon user response
+ * to desktop/display selection dialog
+ *
+ * @connection dbus connection (not used)
+ * @sender_name sender name, dbus session, (not used)
+ * @object_path dbus object path (not used)
+ * @interface_name dbus object's interface name (not used)
+ * @signal_name event name (not used)
+ * @parameters contains remote proxy connection params
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_start_response_received_callback(GDBusConnection *
+                                                connection,
+                                                const char *sender_name,
+                                                const char *object_path,
+                                                const char *interface_name,
+                                                const char *signal_name,
+                                                GVariant * parameters,
+                                                gpointer user_data)
+{
+    g_autoptr(GVariant) stream_properties = NULL;
+    g_autoptr(GVariant) streams = NULL;
+    g_autoptr(GVariant) result = NULL;
+    GVariantIter iter;
+    uint32_t response;
+
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    (void) connection;
+    (void) sender_name;
+    (void) object_path;
+    (void) interface_name;
+    (void) signal_name;
+
+    g_clear_pointer(&ptr_dbus_call_data, dbus_call_data_free);
+
+    g_variant_get(parameters, "(u@a{sv})", &response, &result);
+
+    if (response != 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Failed to start screencast, denied or cancelled by user!\n");
+        pipewiregrab_abort(ctx,
+                           "Failed to start screencast, denied or cancelled by user!");
+        return;
+    }
+
+    streams =
+        g_variant_lookup_value(result, "streams", G_VARIANT_TYPE_ARRAY);
+
+    g_variant_iter_init(&iter, streams);
+    g_assert(g_variant_iter_n_children(&iter) == 1);
+
+    g_variant_iter_loop(&iter, "(u@a{sv})", &pw_ctx->pipewire_node,
+                        &stream_properties);
+
+    av_log(ctx, AV_LOG_INFO,
+           "[pipewiregrab] Monitor selected, setting up screencast\n\n");
+
+    open_pipewire_remote(ctx);
+}
+
+/**
+ * Asynchronous dbus callback containing capture source
+ *
+ * @source dbus capture source
+ * @res dbus callback state
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_started_callback(GObject * source, GAsyncResult * res,
+                                gpointer user_data)
+{
+    g_autoptr(GVariant) result = NULL;
+    g_autoptr(GError) error = NULL;
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+
+    (void) user_data;
+
+    result = g_dbus_proxy_call_finish(G_DBUS_PROXY(source), res, &error);
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error selecting screencast source: %s\n",
+                   error->message);
+
+        return;
+    }
+}
+
+/**
+ * start the dbus remote connection/proxy
+ *
+ * @ctx AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static void start(AVFormatContext * ctx)
+{
+    g_autofree char *request_token = NULL;
+    g_autofree char *request_path = NULL;
+    GVariantBuilder builder;
+    struct dbus_call_data *ptr_dbus_call_data;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    new_request_path(ctx, &request_path, &request_token);
+
+    av_log(ctx, AV_LOG_WARNING, "[pipewiregrab] Asking for monitor…\n");
+
+    ptr_dbus_call_data =
+        subscribe_to_signal(ctx /* user_data */ , request_path,
+                            on_start_response_received_callback);
+    if (ptr_dbus_call_data == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] subscribe_to_signal failed!\n");
+        return;
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+    g_variant_builder_add(&builder, "{sv}", "handle_token",
+                          g_variant_new_string(request_token));
+
+    g_dbus_proxy_call(pw_ctx->proxy, "Start",
+                      g_variant_new("(osa{sv})", pw_ctx->session_handle,
+                                    "", &builder), G_DBUS_CALL_FLAGS_NONE,
+                      -1, pw_ctx->cancellable, on_started_callback,
+                      ptr_dbus_call_data /* user_data */ );
+}
+
+/**
+ * Asynchronous dbus callback signaled upon user response
+ *
+ * @connection dbus connection (not used)
+ * @sender_name sender name, dbus session, (not used)
+ * @object_path dbus object path (not used)
+ * @interface_name dbus object's interface name (not used)
+ * @signal_name event name (not used)
+ * @parameters contains remote proxy connection params
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_select_source_response_received_callback(GDBusConnection *
+                                                        connection,
+                                                        const char
+                                                        *sender_name,
+                                                        const char
+                                                        *object_path,
+                                                        const char
+                                                        *interface_name,
+                                                        const char
+                                                        *signal_name,
+                                                        GVariant *
+                                                        parameters,
+                                                        gpointer user_data)
+{
+    g_autoptr(GVariant) ret = NULL;
+    uint32_t response;
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+
+    (void) connection;
+    (void) sender_name;
+    (void) object_path;
+    (void) interface_name;
+    (void) signal_name;
+
+    av_log(ctx, AV_LOG_INFO,
+           "[pipewiregrab] Response to select source received\n");
+
+    g_clear_pointer(&ptr_dbus_call_data, dbus_call_data_free);
+
+    g_variant_get(parameters, "(u@a{sv})", &response, &ret);
+
+    if (response != 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Failed to select source, denied or cancelled by user!\n");
+        pipewiregrab_abort(ctx,
+                           "Failed to select source, denied or cancelled by user!");
+        return;
+    }
+
+    start(ctx);
+}
+
+/**
+ * Asynchronous dbus callback recevied after initial
+ * capture source selection
+ *
+ * @source dbus capture source
+ * @res dbus callback state
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_source_selected_callback(GObject * source,
+                                        GAsyncResult * res,
+                                        gpointer user_data)
+{
+    g_autoptr(GVariant) result = NULL;
+    g_autoptr(GError) error = NULL;
+
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+
+    result = g_dbus_proxy_call_finish(G_DBUS_PROXY(source), res, &error);
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error selecting screencast source: %s\n",
+                   error->message);
+
+        return;
+    }
+}
+
+/**
+ * start capture source selection
+ *
+ * @ctx AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static void select_source(AVFormatContext * ctx)
+{
+    g_autofree char *request_token = NULL;
+    g_autofree char *request_path = NULL;
+    GVariantBuilder builder;
+    struct dbus_call_data *ptr_dbus_call_data;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    new_request_path(ctx, &request_path, &request_token);
+
+    ptr_dbus_call_data =
+        subscribe_to_signal(ctx /* user_data */ , request_path,
+                            on_select_source_response_received_callback);
+    if (ptr_dbus_call_data == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] subscribe_to_signal failed!\n");
+        return;
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+    g_variant_builder_add(&builder, "{sv}", "types",
+                          g_variant_new_uint32(pw_ctx->capture_type));
+    g_variant_builder_add(&builder, "{sv}", "multiple",
+                          g_variant_new_boolean(FALSE));
+    g_variant_builder_add(&builder, "{sv}", "handle_token",
+                          g_variant_new_string(request_token));
+
+    g_dbus_proxy_call(pw_ctx->proxy, "SelectSources",
+                      g_variant_new("(oa{sv})", pw_ctx->session_handle,
+                                    &builder),
+                      G_DBUS_CALL_FLAGS_NONE, -1, pw_ctx->cancellable,
+                      (GAsyncReadyCallback) on_source_selected_callback,
+                      ptr_dbus_call_data /* user_data */ );
+}
+
+/**
+ * Asynchronous dbus session user response callback
+ *
+ * @connection dbus connection (not used)
+ * @sender_name sender name, dbus session, (not used)
+ * @object_path dbus object path (not used)
+ * @interface_name dbus object's interface name (not used)
+ * @signal_name event name (not used)
+ * @parameters contains remote proxy connection params
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_create_session_response_received_callback(GDBusConnection *
+                                                         connection,
+                                                         const char
+                                                         *sender_name,
+                                                         const char
+                                                         *object_path,
+                                                         const char
+                                                         *interface_name,
+                                                         const char
+                                                         *signal_name,
+                                                         GVariant *
+                                                         parameters,
+                                                         gpointer
+                                                         user_data)
+{
+    uint32_t response;
+    g_autoptr(GVariant) result = NULL;
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    (void) connection;
+    (void) sender_name;
+    (void) object_path;
+    (void) interface_name;
+    (void) signal_name;
+
+    g_clear_pointer(&ptr_dbus_call_data, dbus_call_data_free);
+
+    g_variant_get(parameters, "(u@a{sv})", &response, &result);
+
+    if (response != 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Pipewire failed to create session, denied or cancelled by user!\n");
+        return;
+    }
+
+    av_log(ctx, AV_LOG_DEBUG,
+           "[pipewiregrab] Screencast session created\n");
+
+    g_variant_lookup(result, "session_handle", "s",
+                     &pw_ctx->session_handle);
+
+    select_source(ctx);
+}
+
+/**
+ * Asynchronous dbus callback on session creation
+ *
+ * @source dbus capture source
+ * @res dbus callback state
+ * @user_data dbus callback structure that contains PipeWire Grab main structure
+ */
+static void on_session_created_callback(GObject * source,
+                                        GAsyncResult * res,
+                                        gpointer user_data)
+{
+    g_autoptr(GVariant) result = NULL;
+    g_autoptr(GError) error = NULL;
+    struct dbus_call_data *ptr_dbus_call_data = user_data;
+    AVFormatContext *ctx = ptr_dbus_call_data->ctx;
+
+    result = g_dbus_proxy_call_finish(G_DBUS_PROXY(source), res, &error);
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error creating screencast session: %s\n",
+                   error->message);
+
+        return;
+    }
+}
+
+/**
+ * start a dbus remote session
+ *
+ * @ctx AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static void create_session(AVFormatContext * ctx)
+{
+    GVariantBuilder builder;
+    g_autofree char *request_token = NULL;
+    g_autofree char *request_path = NULL;
+    g_autofree char *session_token = NULL;
+    struct dbus_call_data *ptr_dbus_call_data;
+
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    new_request_path(ctx, &request_path, &request_token);
+    new_session_path(ctx, NULL, &session_token);
+
+    ptr_dbus_call_data =
+        subscribe_to_signal(ctx /* user_data */ , request_path,
+                            on_create_session_response_received_callback);
+    if (ptr_dbus_call_data == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] subscribe_to_signal failed!\n");
+        return;
+    }
+
+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);
+    g_variant_builder_add(&builder, "{sv}", "handle_token",
+                          g_variant_new_string(request_token));
+    g_variant_builder_add(&builder, "{sv}", "session_handle_token",
+                          g_variant_new_string(session_token));
+
+    g_dbus_proxy_call(pw_ctx->proxy, "CreateSession",
+                      g_variant_new("(a{sv})", &builder),
+                      G_DBUS_CALL_FLAGS_NONE, -1, pw_ctx->cancellable,
+                      on_session_created_callback,
+                      ptr_dbus_call_data /* user_data */ );
+}
+
+/**
+ * Asynchronous dbus callback on remote proxy creation
+ *
+ * @source dbus capture source
+ * @res dbus callback state
+ * @user_data AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static void on_pipewire_proxy_created_callback(GObject * source,
+                                               GAsyncResult * res,
+                                               gpointer user_data)
+{
+    g_autoptr(GError) error = NULL;
+    AVFormatContext *ctx = user_data;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    (void) source;
+
+    pw_ctx->proxy = g_dbus_proxy_new_finish(res, &error);
+
+    if (error) {
+        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Error creating proxy: %s\n",
+                   error->message);
+
+        return;
+    }
+
+    create_session(ctx);
+}
+
+/**
+ * create dbus remote proxy connection to session bus
+ *
+ * @ctx AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static void create_pipewire_proxy(AVFormatContext * ctx)
+{
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return;
+    }
+
+    g_dbus_proxy_new(pw_ctx->connection, G_DBUS_PROXY_FLAGS_NONE, NULL,
+                     "org.freedesktop.portal.Desktop",
+                     "/org/freedesktop/portal/desktop",
+                     "org.freedesktop.portal.ScreenCast",
+                     pw_ctx->cancellable,
+                     (GAsyncReadyCallback)
+                     on_pipewire_proxy_created_callback,
+                     ctx /* user_data */ );
+}
+
+/**
+ * intiate the dbus capture session, setting capture source
+ * as desktop (for now, later add WINDOW_CAPTURE)
+ *
+ * @ctx AVFormatContext structure that contains PipeWire Grab main structure
+ */
+static int init_pipewiregrab(AVFormatContext * ctx)
+{
+    char *aux;
+    g_autoptr(GError) error = NULL;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return AVERROR(EINVAL);
+    }
+
+    pw_ctx->capture_type = DESKTOP_CAPTURE;
+    pw_ctx->cancellable = g_cancellable_new();
+    CIRCLEQ_INIT(&pw_ctx->circular_queue_head); /* Initialize the avpacket circular queue */
+
+    pw_ctx->connection = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);
+    if (error) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Error getting session bus: %s\n",
+               error->message);
+        return error->code;
+    }
+
+    pw_ctx->sender_name =
+        g_strdup(g_dbus_connection_get_unique_name(pw_ctx->connection) +
+                 1);
+
+    /* Replace dots by underscores */
+    while ((aux = g_strstr_len(pw_ctx->sender_name, -1, ".")) != NULL)
+        *aux = '_';
+
+    av_log(ctx, AV_LOG_DEBUG,
+           "[pipewiregrab] Initialized (sender name: %s)\n",
+           pw_ctx->sender_name);
+
+    create_pipewire_proxy(ctx);
+
+    return 0;
+}
+
+/* ------------------------------------------------- */
+
+static const AVClass pipewiregrab = {
+    .class_name = "pipewiregrab indev",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+    .category = AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,
+};
+
+static int pipewiregrab_read_packet(AVFormatContext * ctx, AVPacket * pkt)
+{
+    uint8_t crnt_circular_queue_size;
+    struct avpacket_entry *pkte = NULL;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return AVERROR(EINVAL);
+    }
+
+    crnt_circular_queue_size = atomic_load(&pw_ctx->circular_queue_size);
+    if (crnt_circular_queue_size == 0) {
+        pthread_mutex_lock(&pw_ctx->read_packet_mutex);
+        pthread_cond_wait(&pw_ctx->read_packet_cond_var,
+                          &pw_ctx->read_packet_mutex);
+        pthread_mutex_unlock(&pw_ctx->read_packet_mutex);
+    }
+
+    pkte = CIRCLEQ_FIRST(&pw_ctx->circular_queue_head);
+    if (pkte == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid packet circular queue entry!\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (crnt_circular_queue_size < 2) {
+        if (pkte->cq_pkt->dts == pw_ctx->time_frame) {
+            pkte->cq_pkt->dts += pw_ctx->frame_duration;
+            pkte->cq_pkt->pts = pw_ctx->time_frame = pkte->cq_pkt->dts;
+        }
+
+        av_packet_ref(pkt, pkte->cq_pkt);
+
+    } else {
+        CIRCLEQ_REMOVE(&pw_ctx->circular_queue_head, pkte, entries);
+        av_packet_free(&pkte->cq_pkt);
+        free(pkte);
+        atomic_fetch_sub(&pw_ctx->circular_queue_size, 1);
+
+        pkte = CIRCLEQ_FIRST(&pw_ctx->circular_queue_head);
+        if (pkte == NULL) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "[pipewiregrab] Invalid packet circular queue entry!\n");
+            return AVERROR(EINVAL);
+        }
+
+        av_packet_ref(pkt, pkte->cq_pkt);
+    }
+
+    return 0;
+}
+
+static int pipewiregrab_read_close(AVFormatContext * ctx)
+{
+    struct avpacket_entry *pkte = NULL;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (pw_ctx->thread_loop != NULL)
+        pw_thread_loop_signal(pw_ctx->thread_loop, false);
+
+    if (pw_ctx->glib_main_loop != NULL &&
+        g_main_loop_is_running(pw_ctx->glib_main_loop)) {
+        g_main_loop_quit(pw_ctx->glib_main_loop);
+    }
+
+    pthread_join(pw_ctx->pipewire_pthread, NULL);
+
+    /* free/removal forward traversal */
+    CIRCLEQ_FOREACH(pkte, &pw_ctx->circular_queue_head, entries) {
+        CIRCLEQ_REMOVE(&pw_ctx->circular_queue_head, pkte, entries);
+        av_packet_free(&pkte->cq_pkt);
+        free(pkte);
+    }
+
+    return 0;
+}
+
+static void *pipewire_gdbus_init_pthread(void *argo)
+{
+    intptr_t ret = 0;
+    AVFormatContext *ctx = (AVFormatContext *) argo;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return (void *) AVERROR(EINVAL);
+    }
+
+    /* initialize the PipeWire library */
+    pw_init(NULL, NULL);
+
+    pw_ctx->glib_main_loop = g_main_loop_new(NULL, FALSE);
+    if (pw_ctx->glib_main_loop == NULL) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] g_main_loop_new failed!\n");
+        ret = AVERROR(ENOMEM);
+        goto exit_pw_deinit;
+    }
+
+    if (init_pipewiregrab(ctx) != 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] init_pipewiregrab failed!\n");
+        ret = AVERROR(EPERM);
+        goto exit_glib_loop;
+    }
+
+    av_log(ctx, AV_LOG_INFO, "[pipewiregrab] starting glib main loop!\n");
+    g_main_loop_run(pw_ctx->glib_main_loop);
+
+    /* g_main_loop quited, destroy pipewire */
+    pipewire_destroy(ctx);
+
+  exit_glib_loop:
+    g_main_loop_unref(pw_ctx->glib_main_loop);
+    pw_ctx->glib_main_loop = NULL;
+  exit_pw_deinit:
+    pw_deinit();
+
+    return (void *) ret;
+}
+
+static int pipewiregrab_read_header(AVFormatContext * ctx)
+{
+    int ret = 0;
+    PipewireGrabContext *pw_ctx = ctx->priv_data;
+
+    if (!pw_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] Invalid private context data!\n");
+        return AVERROR(EINVAL);
+    }
+
+    atomic_init(&pw_ctx->avstream_codec_flag, 0);
+    atomic_init(&pw_ctx->circular_queue_size, 0);
+
+    pthread_cond_init(&pw_ctx->avstream_codec_cond_var, NULL);
+    pthread_cond_init(&pw_ctx->read_packet_cond_var, NULL);
+    pthread_mutex_init(&pw_ctx->avstream_codec_mutex, NULL);
+    pthread_mutex_init(&pw_ctx->read_packet_mutex, NULL);
+
+    ret = av_parse_video_rate(&pw_ctx->user_frame_rate, pw_ctx->framerate);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_ERROR,
+               "[pipewiregrab] av_parse_video_rate failed!\n");
+        return ret;
+    }
+
+    ret = pthread_create(&pw_ctx->pipewire_pthread, NULL,
+                         &pipewire_gdbus_init_pthread, ctx);
+    pthread_mutex_lock(&pw_ctx->avstream_codec_mutex);
+    if (atomic_load(&pw_ctx->avstream_codec_flag) == 0)
+        pthread_cond_wait(&pw_ctx->avstream_codec_cond_var,
+                          &pw_ctx->avstream_codec_mutex);
+    // wait until signaled
+    pthread_mutex_unlock(&pw_ctx->avstream_codec_mutex);
+
+    return ret;
+}
+
+const AVInputFormat ff_pipewiregrab_demuxer = {
+    .name = "pipewiregrab",
+    .long_name = NULL_IF_CONFIG_SMALL("screen capture, using pipewire"),
+    .priv_data_size = sizeof(struct PipewireGrabContext),
+    .read_header = pipewiregrab_read_header,
+    .read_packet = pipewiregrab_read_packet,
+    .read_close = pipewiregrab_read_close,
+    .flags = AVFMT_NOFILE,
+    .priv_class = &pipewiregrab,
+};
