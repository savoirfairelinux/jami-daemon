--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,249 @@
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+
+#output directories
+DebugLib/
+Debug/
+ReleaseLib/
+Release/
+.config/
+# User-specific files
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+*.VC.VC.opendb
+*.VC.db
+*.db
+*.filters
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+bld/
+[Bb]in/
+[Oo]bj/
+
+# Visual Studio 2015 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUNIT
+*.VisualState.xml
+TestResult.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# DNX
+project.lock.json
+artifacts/
+
+#*_i.c
+#*_p.c
+#*_i.h
+*.ilk
+*.meta
+*.obj
+*.o
+*.pch
+*.pdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# JustCode is a .NET coding add-in
+.JustCode
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# TODO: Comment the next line if you want to checkin your web deploy settings 
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# NuGet Packages
+*.nupkg
+# The packages folder can be ignored because of Package Restore
+**/packages/*
+# except build/, which is used as an MSBuild target.
+!**/packages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/packages/repositories.config
+# NuGet v3's project.json files produces more ignoreable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Microsoft Azure ApplicationInsights config file
+ApplicationInsights.config
+
+# Windows Store app package directory
+AppPackages/
+BundleArtifacts/
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.pfx
+*.publishsettings
+node_modules/
+orleans.codegen.cs
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+
+# SQL Server files
+*.mdf
+*.ldf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+
+# FAKE - F# Make
+.fake/
+
+!config.h
\ No newline at end of file
--- /dev/null
+++ b/MSVC/portaudio-UWP/pch.cpp
@@ -0,0 +1 @@
+﻿#include "pch.h"
--- /dev/null
+++ b/MSVC/portaudio-UWP/pch.h
@@ -0,0 +1,9 @@
+﻿#pragma once
+
+#include "targetver.h"
+
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+
+#include <windows.h>
--- /dev/null
+++ b/MSVC/portaudio-UWP/portaudio-UWP.cpp
@@ -0,0 +1,2 @@
+﻿#include "pch.h"
+#include "portaudio-UWP.h"
--- /dev/null
+++ b/MSVC/portaudio-UWP/portaudio-UWP.h
@@ -0,0 +1 @@
+﻿#pragma once
--- /dev/null
+++ b/MSVC/portaudio-UWP/portaudio-UWP.vcxproj
@@ -0,0 +1,252 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{23913386-5333-4c93-b3f0-0227aff77b49}</ProjectGuid>
+    <Keyword>StaticLibrary</Keyword>
+    <RootNamespace>portaudio_UWP</RootNamespace>
+    <DefaultLanguage>en-US</DefaultLanguage>
+    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
+    <AppContainerApplication>true</AppContainerApplication>
+    <ApplicationType>Windows Store</ApplicationType>
+    <WindowsTargetPlatformVersion>10.0.14393.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformMinVersion>10.0.10240.0</WindowsTargetPlatformMinVersion>
+    <ApplicationTypeRevision>10.0</ApplicationTypeRevision>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <GenerateManifest>false</GenerateManifest>
+    <OutDir>$(ProjectDir)$(Platform)\$(Configuration)\$(MSBuildProjectName)\</OutDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|arm'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|arm'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <CompileAsWinRT>false</CompileAsWinRT>
+      <SDLCheck>true</SDLCheck>
+      <PreprocessorDefinitions>COBJMACROS;CINTERFACE;WIN32;NDEBUG;_CRT_SECURE_NO_DEPRECATE;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(ProjectDir)..\..\include;$(ProjectDir)..\..\src\common;$(ProjectDir)..\..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <DisableSpecificWarnings>4005;</DisableSpecificWarnings>
+      <ProgramDataBaseFileName>$(OutDir)$(ProjectName).pdb</ProgramDataBaseFileName>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
+    </Link>
+    <PostBuildEvent>
+      <Command>mkdir $(ProjectDir)..\..\..\include
+xcopy /S /Y $(ProjectDir)..\..\include\*.h $(ProjectDir)..\..\..\include
+mkdir $(ProjectDir)..\..\..\lib
+mkdir $(ProjectDir)..\..\..\lib\x64
+copy $(OutDir)*.lib $(ProjectDir)..\..\..\lib\x64
+copy $(OutDir)*.pdb $(ProjectDir)..\..\..\lib\x64</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="portaudio-UWP.h" />
+    <ClInclude Include="pch.h" />
+    <ClInclude Include="targetver.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\common\pa_allocation.c" />
+    <ClCompile Include="..\..\src\common\pa_converters.c" />
+    <ClCompile Include="..\..\src\common\pa_cpuload.c" />
+    <ClCompile Include="..\..\src\common\pa_debugprint.c" />
+    <ClCompile Include="..\..\src\common\pa_dither.c" />
+    <ClCompile Include="..\..\src\common\pa_front.c" />
+    <ClCompile Include="..\..\src\common\pa_process.c" />
+    <ClCompile Include="..\..\src\common\pa_ringbuffer.c" />
+    <ClCompile Include="..\..\src\common\pa_stream.c" />
+    <ClCompile Include="..\..\src\common\pa_trace.c" />
+    <ClCompile Include="..\..\src\hostapi\skeleton\pa_hostapi_skeleton.c" />
+    <ClCompile Include="..\..\src\hostapi\wasapi\pa_win_wasapi.c" />
+    <ClCompile Include="..\..\src\os\win\pa_win_coinitialize.c" />
+    <ClCompile Include="..\..\src\os\win\pa_win_hostapis.c" />
+    <ClCompile Include="..\..\src\os\win\pa_win_util.c" />
+    <ClCompile Include="..\..\src\os\win\pa_win_waveformat.c" />
+    <ClCompile Include="..\..\src\os\win\pa_win_wdmks_utils.c">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\..\src\os\win\pa_x86_plain_converters.c" />
+    <ClCompile Include="portaudio-UWP.cpp" />
+    <ClCompile Include="pch.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
--- /dev/null
+++ b/MSVC/portaudio-UWP/targetver.h
@@ -0,0 +1,8 @@
+﻿#pragma once
+
+// Including SDKDDKVer.h defines the highest available Windows platform.
+
+// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
+// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
+
+#include <SDKDDKVer.h>
--- /dev/null
+++ b/MSVC/portaudio.def
@@ -0,0 +1,46 @@
+EXPORTS
+
+;
+Pa_GetVersion                       @1
+Pa_GetVersionText                   @2
+Pa_GetErrorText                     @3                 
+Pa_Initialize                       @4
+Pa_Terminate                        @5
+Pa_GetHostApiCount                  @6
+Pa_GetDefaultHostApi                @7
+Pa_GetHostApiInfo                   @8
+Pa_HostApiTypeIdToHostApiIndex      @9
+Pa_HostApiDeviceIndexToDeviceIndex  @10
+Pa_GetLastHostErrorInfo             @11
+Pa_GetDeviceCount                   @12
+Pa_GetDefaultInputDevice            @13
+Pa_GetDefaultOutputDevice           @14
+Pa_GetDeviceInfo                    @15
+Pa_IsFormatSupported                @16
+Pa_OpenStream                       @17
+Pa_OpenDefaultStream                @18
+Pa_CloseStream                      @19
+Pa_SetStreamFinishedCallback        @20
+Pa_StartStream                      @21
+Pa_StopStream                       @22
+Pa_AbortStream                      @23
+Pa_IsStreamStopped                  @24
+Pa_IsStreamActive                   @25
+Pa_GetStreamInfo                    @26
+Pa_GetStreamTime                    @27
+Pa_GetStreamCpuLoad                 @28
+Pa_ReadStream                       @29
+Pa_WriteStream                      @30
+Pa_GetStreamReadAvailable           @31
+Pa_GetStreamWriteAvailable          @32
+Pa_GetSampleSize                    @33
+Pa_Sleep                            @34
+PaUtil_InitializeX86PlainConverters @52
+PaUtil_SetDebugPrintFunction        @55
+PaWasapi_GetDeviceDefaultFormat     @56
+PaWasapi_GetDeviceRole              @57
+PaWasapi_ThreadPriorityBoost        @58
+PaWasapi_ThreadPriorityRevert       @59
+PaWasapi_GetFramesPerHostBuffer     @60
+PaWasapi_GetJackDescription         @61
+PaWasapi_GetJackCount               @62
\ No newline at end of file
--- /dev/null
+++ b/MSVC/portaudio.sln
@@ -0,0 +1,52 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portaudio-UWP", "portaudio-UWP\portaudio-UWP.vcxproj", "{23913386-5333-4C93-B3F0-0227AFF77B49}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|ARM = Debug|ARM
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		DebugLib|ARM = DebugLib|ARM
+		DebugLib|Win32 = DebugLib|Win32
+		DebugLib|x64 = DebugLib|x64
+		Release|ARM = Release|ARM
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+		ReleaseLib|ARM = ReleaseLib|ARM
+		ReleaseLib|Win32 = ReleaseLib|Win32
+		ReleaseLib|x64 = ReleaseLib|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|ARM.ActiveCfg = Debug|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|ARM.Build.0 = Debug|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|Win32.ActiveCfg = Debug|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|Win32.Build.0 = Debug|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|x64.ActiveCfg = Debug|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Debug|x64.Build.0 = Debug|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|ARM.ActiveCfg = Debug|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|ARM.Build.0 = Debug|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|Win32.ActiveCfg = Debug|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|Win32.Build.0 = Debug|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|x64.ActiveCfg = Debug|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.DebugLib|x64.Build.0 = Debug|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|ARM.ActiveCfg = Release|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|ARM.Build.0 = Release|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|Win32.ActiveCfg = Release|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|Win32.Build.0 = Release|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|x64.ActiveCfg = Release|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.Release|x64.Build.0 = Release|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|ARM.ActiveCfg = Release|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|ARM.Build.0 = Release|ARM
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|Win32.ActiveCfg = Release|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|Win32.Build.0 = Release|Win32
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|x64.ActiveCfg = Release|x64
+		{23913386-5333-4C93-B3F0-0227AFF77B49}.ReleaseLib|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
--- /dev/null
+++ b/MSVC/portaudio.vcxproj
@@ -0,0 +1,608 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="DebugLib|Win32">
+      <Configuration>DebugLib</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="DebugLib|x64">
+      <Configuration>DebugLib</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseLib|Win32">
+      <Configuration>ReleaseLib</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseLib|x64">
+      <Configuration>ReleaseLib</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0A18A071-125E-442F-AFF7-A3F68ABECF99}</ProjectGuid>
+    <RootNamespace>portaudio</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0.14393.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <UseOfMfc>false</UseOfMfc>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25123.0</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\..\bin\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|Win32'">
+    <OutDir>$(SolutionDir)..\..\lib\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetExt>.lib</TargetExt>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(ProjectDir)..\..\lib\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|x64'">
+    <OutDir>$(ProjectDir)..\..\lib\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetExt>.lib</TargetExt>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\..\bin\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetExt>.dll</TargetExt>
+    <TargetName>$(ProjectName)d</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|Win32'">
+    <OutDir>$(SolutionDir)..\..\lib\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetExt>.lib</TargetExt>
+    <TargetName>$(ProjectName)d</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\..\bin\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)d</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|x64'">
+    <OutDir>$(SolutionDir)..\..\lib\$(PlatformTarget)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetExt>.lib</TargetExt>
+    <TargetName>$(ProjectName)d</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Release_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName />
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;WIN32;NDEBUG;_USRDLL;PA_ENABLE_DEBUG_OUTPUT;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=1;PA_USE_WASAPI=1;PA_USE_WDMKS=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)/portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksuser.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <ProgramDatabaseFile>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).lib</ImportLibrary>
+      <TargetMachine>MachineX86</TargetMachine>
+      <AdditionalLibraryDirectories>$(WindowsSdkDir)\Lib\winv6.3\km\$(PlatformTarget)\</AdditionalLibraryDirectories>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|Win32'">
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Release_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;WIN32;NDEBUG;_USRDLL;PA_ENABLE_DEBUG_OUTPUT;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=1;PA_USE_WASAPI=1;PA_USE_WDMKS=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)/portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksuser.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x86.dll</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <ProgramDatabaseFile>$(Platform)\$(Configuration)\portaudio_x86.pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(Platform)\$(Configuration)\portaudio_x86.lib</ImportLibrary>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>X64</TargetEnvironment>
+      <TypeLibraryName>.\Release_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName />
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;_WIN64;NDEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=0;PA_USE_WASAPI=1;PA_USE_WDMKS=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)\portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksuser.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <ProgramDatabaseFile>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).lib</ImportLibrary>
+      <TargetMachine>MachineX64</TargetMachine>
+      <AdditionalLibraryDirectories>$(WindowsSdkDir)\Lib\winv6.3\km\$(PlatformTarget)\</AdditionalLibraryDirectories>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x64.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(ProjectDir)..\..\include
+xcopy /S /Y $(ProjectDir)..\include\*.h $(ProjectDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLib|x64'">
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>X64</TargetEnvironment>
+      <TypeLibraryName>.\Release_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;_WIN64;NDEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=1;PA_USE_WASAPI=1;PA_USE_WDMKS=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)\portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksuser.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x64.dll</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <ProgramDatabaseFile>$(Platform)\$(Configuration)/portaudio_x64.pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(Platform)\$(Configuration)/portaudio_x64.lib</ImportLibrary>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x64.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(ProjectDir)..\..\include
+xcopy /S /Y $(ProjectDir)..\include\*.h $(ProjectDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Debug_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName />
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;WIN32;_DEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=1;PA_USE_WMME=0;PA_USE_WASAPI=0;PA_USE_WDMKS=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)/portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <DisableSpecificWarnings>4996;</DisableSpecificWarnings>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).lib</ImportLibrary>
+      <TargetMachine>MachineX86</TargetMachine>
+      <AdditionalLibraryDirectories>
+      </AdditionalLibraryDirectories>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|Win32'">
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Debug_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;WIN32;_DEBUG;_USRDLL;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_USE_ASIO=0;PA_USE_DS=1;PA_USE_WMME=0;PA_USE_WASAPI=0;PA_USE_WDMKS=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)/portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <DisableSpecificWarnings>4996;</DisableSpecificWarnings>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x86.dll</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(Platform)\$(Configuration)\portaudio_x86.pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(Platform)\$(Configuration)\portaudio_x86.lib</ImportLibrary>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+    <Lib>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>X64</TargetEnvironment>
+      <TypeLibraryName>.\Debug_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName />
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;_WIN64;_DEBUG;_USRDLL;PA_ENABLE_DEBUG_OUTPUT;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_WDMKS_NO_KSGUID_LIB;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=1;PA_USE_WASAPI=1;PA_USE_WDMKS=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)\portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(SolutionDir)..\..\lib\$(PlatformTarget)\$(TargetName).lib</ImportLibrary>
+      <TargetMachine>MachineX64</TargetMachine>
+      <AdditionalLibraryDirectories>
+      </AdditionalLibraryDirectories>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)/portaudio_x64.bsc</OutputFile>
+    </Bscmake>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugLib|x64'">
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>X64</TargetEnvironment>
+      <TypeLibraryName>.\Debug_x86/portaudio.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\src\common;..\include;.\;..\src\os\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>PA_WDMKS_NO_KSGUID_LIB;_WIN64;_DEBUG;_USRDLL;PA_ENABLE_DEBUG_OUTPUT;_CRT_SECURE_NO_DEPRECATE;PAWIN_USE_WDMKS_DEVICE_INFO;PA_WDMKS_NO_KSGUID_LIB;PA_USE_ASIO=0;PA_USE_DS=0;PA_USE_WMME=1;PA_USE_WASAPI=1;PA_USE_WDMKS=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeaderOutputFile>$(Platform)\$(Configuration)\portaudio.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>$(Platform)\$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>$(Platform)\$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>$(Platform)\$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>ksguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(Platform)\$(Configuration)\portaudio_x64.dll</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <ModuleDefinitionFile>.\portaudio.def</ModuleDefinitionFile>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(Platform)\$(Configuration)/portaudio_x64.pdb</ProgramDatabaseFile>
+      <ImportLibrary>$(Platform)\$(Configuration)\portaudio_x64.lib</ImportLibrary>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>$(Platform)\$(Configuration)/portaudio_x64.bsc</OutputFile>
+    </Bscmake>
+    <Lib>
+      <OutputFile>$(OutDir)\$(TargetName)$(TargetExt)</OutputFile>
+    </Lib>
+    <PostBuildEvent>
+      <Command>mkdir $(SolutionDir)..\..\include
+xcopy /S /Y $(SolutionDir)..\include\*.h $(SolutionDir)..\..\include</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\src\common\pa_allocation.c" />
+    <ClCompile Include="..\src\common\pa_converters.c" />
+    <ClCompile Include="..\src\common\pa_cpuload.c" />
+    <ClCompile Include="..\src\common\pa_debugprint.c" />
+    <ClCompile Include="..\src\common\pa_dither.c" />
+    <ClCompile Include="..\src\common\pa_front.c" />
+    <ClCompile Include="..\src\common\pa_process.c" />
+    <ClCompile Include="..\src\common\pa_ringbuffer.c" />
+    <ClCompile Include="..\src\common\pa_stream.c" />
+    <ClCompile Include="..\src\common\pa_trace.c" />
+    <ClCompile Include="..\src\hostapi\dsound\pa_win_ds.c" />
+    <ClCompile Include="..\src\hostapi\dsound\pa_win_ds_dynlink.c" />
+    <ClCompile Include="..\src\hostapi\skeleton\pa_hostapi_skeleton.c" />
+    <ClCompile Include="..\src\hostapi\wasapi\pa_win_wasapi.c" />
+    <ClCompile Include="..\src\hostapi\wdmks\pa_win_wdmks.c" />
+    <ClCompile Include="..\src\hostapi\wmme\pa_win_wmme.c" />
+    <ClCompile Include="..\src\os\win\pa_win_coinitialize.c" />
+    <ClCompile Include="..\src\os\win\pa_win_hostapis.c" />
+    <ClCompile Include="..\src\os\win\pa_win_util.c" />
+    <ClCompile Include="..\src\os\win\pa_win_waveformat.c" />
+    <ClCompile Include="..\src\os\win\pa_win_wdmks_utils.c" />
+    <ClCompile Include="..\src\os\win\pa_x86_plain_converters.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="portaudio.def" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\include\pa_asio.h" />
+    <ClInclude Include="..\include\pa_win_ds.h" />
+    <ClInclude Include="..\include\pa_win_wasapi.h" />
+    <ClInclude Include="..\include\pa_win_waveformat.h" />
+    <ClInclude Include="..\include\pa_win_wmme.h" />
+    <ClInclude Include="..\include\portaudio.h" />
+    <ClInclude Include="..\src\common\pa_gitrevision.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
--- a/include/pa_win_wasapi.h
+++ b/include/pa_win_wasapi.h
@@ -1,391 +1,443 @@
-#ifndef PA_WIN_WASAPI_H
-#define PA_WIN_WASAPI_H
-/*
- * $Id:  $
- * PortAudio Portable Real-Time Audio Library
- * DirectSound specific extensions
- *
- * Copyright (c) 1999-2007 Ross Bencina and Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however, 
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
- * license above.
- */
-
-/** @file
- @ingroup public_header
- @brief WASAPI-specific PortAudio API extension header file.
-*/
-
-#include "portaudio.h"
-#include "pa_win_waveformat.h"
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /* __cplusplus */
-
-
-/* Setup flags */
-typedef enum PaWasapiFlags
-{
-    /* puts WASAPI into exclusive mode */
-    paWinWasapiExclusive                = (1 << 0),
-
-    /* allows to skip internal PA processing completely */
-    paWinWasapiRedirectHostProcessor    = (1 << 1),
-
-    /* assigns custom channel mask */
-    paWinWasapiUseChannelMask           = (1 << 2),
-
-    /* selects non-Event driven method of data read/write
-       Note: WASAPI Event driven core is capable of 2ms latency!!!, but Polling
-             method can only provide 15-20ms latency. */
-    paWinWasapiPolling                  = (1 << 3),
-
-    /* forces custom thread priority setting. must be used if PaWasapiStreamInfo::threadPriority 
-       is set to custom value. */
-    paWinWasapiThreadPriority           = (1 << 4)
-}
-PaWasapiFlags;
-#define paWinWasapiExclusive             (paWinWasapiExclusive)
-#define paWinWasapiRedirectHostProcessor (paWinWasapiRedirectHostProcessor)
-#define paWinWasapiUseChannelMask        (paWinWasapiUseChannelMask)
-#define paWinWasapiPolling               (paWinWasapiPolling)
-#define paWinWasapiThreadPriority        (paWinWasapiThreadPriority)
-
-
-/* Host processor. Allows to skip internal PA processing completely. 
-   You must set paWinWasapiRedirectHostProcessor flag to PaWasapiStreamInfo::flags member
-   in order to have host processor redirected to your callback.
-   Use with caution! inputFrames and outputFrames depend solely on final device setup.
-   To query maximal values of inputFrames/outputFrames use PaWasapi_GetFramesPerHostBuffer.
-*/
-typedef void (*PaWasapiHostProcessorCallback) (void *inputBuffer,  long inputFrames,
-                                               void *outputBuffer, long outputFrames,
-                                               void *userData);
-
-/* Device role */
-typedef enum PaWasapiDeviceRole
-{
-    eRoleRemoteNetworkDevice = 0,
-    eRoleSpeakers,
-    eRoleLineLevel,
-    eRoleHeadphones,
-    eRoleMicrophone,
-    eRoleHeadset,
-    eRoleHandset,
-    eRoleUnknownDigitalPassthrough,
-    eRoleSPDIF,
-    eRoleHDMI,
-    eRoleUnknownFormFactor
-}
-PaWasapiDeviceRole;
-
-
-/* Jack connection type */
-typedef enum PaWasapiJackConnectionType
-{
-    eJackConnTypeUnknown,
-    eJackConnType3Point5mm,
-    eJackConnTypeQuarter,
-    eJackConnTypeAtapiInternal,
-    eJackConnTypeRCA,
-    eJackConnTypeOptical,
-    eJackConnTypeOtherDigital,
-    eJackConnTypeOtherAnalog,
-    eJackConnTypeMultichannelAnalogDIN,
-    eJackConnTypeXlrProfessional,
-    eJackConnTypeRJ11Modem,
-    eJackConnTypeCombination
-} 
-PaWasapiJackConnectionType;
-
-
-/* Jack geometric location */
-typedef enum PaWasapiJackGeoLocation
-{
-	eJackGeoLocUnk = 0,
-    eJackGeoLocRear = 0x1, /* matches EPcxGeoLocation::eGeoLocRear */
-    eJackGeoLocFront,
-    eJackGeoLocLeft,
-    eJackGeoLocRight,
-    eJackGeoLocTop,
-    eJackGeoLocBottom,
-    eJackGeoLocRearPanel,
-    eJackGeoLocRiser,
-    eJackGeoLocInsideMobileLid,
-    eJackGeoLocDrivebay,
-    eJackGeoLocHDMI,
-    eJackGeoLocOutsideMobileLid,
-    eJackGeoLocATAPI,
-    eJackGeoLocReserved5,
-    eJackGeoLocReserved6,
-} 
-PaWasapiJackGeoLocation;
-
-
-/* Jack general location */
-typedef enum PaWasapiJackGenLocation
-{
-    eJackGenLocPrimaryBox = 0,
-    eJackGenLocInternal,
-    eJackGenLocSeparate,
-    eJackGenLocOther
-} 
-PaWasapiJackGenLocation;
-
-
-/* Jack's type of port */
-typedef enum PaWasapiJackPortConnection
-{
-    eJackPortConnJack = 0,
-    eJackPortConnIntegratedDevice,
-    eJackPortConnBothIntegratedAndJack,
-    eJackPortConnUnknown
-} 
-PaWasapiJackPortConnection;
-
-
-/* Thread priority */
-typedef enum PaWasapiThreadPriority
-{
-    eThreadPriorityNone = 0,
-    eThreadPriorityAudio,            //!< Default for Shared mode.
-    eThreadPriorityCapture,
-    eThreadPriorityDistribution,
-    eThreadPriorityGames,
-    eThreadPriorityPlayback,
-    eThreadPriorityProAudio,        //!< Default for Exclusive mode.
-    eThreadPriorityWindowManager
-}
-PaWasapiThreadPriority;
-
-
-/* Stream descriptor. */
-typedef struct PaWasapiJackDescription 
-{
-    unsigned long              channelMapping;
-    unsigned long              color; /* derived from macro: #define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16))) */
-    PaWasapiJackConnectionType connectionType;
-    PaWasapiJackGeoLocation    geoLocation;
-    PaWasapiJackGenLocation    genLocation;
-    PaWasapiJackPortConnection portConnection;
-    unsigned int               isConnected;
-}
-PaWasapiJackDescription;
-
-
-/* Stream descriptor. */
-typedef struct PaWasapiStreamInfo 
-{
-    unsigned long size;             /**< sizeof(PaWasapiStreamInfo) */
-    PaHostApiTypeId hostApiType;    /**< paWASAPI */
-    unsigned long version;          /**< 1 */
-
-    unsigned long flags;            /**< collection of PaWasapiFlags */
-
-    /* Support for WAVEFORMATEXTENSIBLE channel masks. If flags contains
-       paWinWasapiUseChannelMask this allows you to specify which speakers 
-       to address in a multichannel stream. Constants for channelMask
-       are specified in pa_win_waveformat.h. Will be used only if 
-       paWinWasapiUseChannelMask flag is specified.
-    */
-    PaWinWaveFormatChannelMask channelMask;
-
-    /* Delivers raw data to callback obtained from GetBuffer() methods skipping 
-       internal PortAudio processing inventory completely. userData parameter will 
-       be the same that was passed to Pa_OpenStream method. Will be used only if 
-       paWinWasapiRedirectHostProcessor flag is specified.
-    */
-    PaWasapiHostProcessorCallback hostProcessorOutput;
-    PaWasapiHostProcessorCallback hostProcessorInput;
-
-    /* Specifies thread priority explicitly. Will be used only if paWinWasapiThreadPriority flag
-       is specified.
-
-       Please note, if Input/Output streams are opened simultaniously (Full-Duplex mode)
-       you shall specify same value for threadPriority or othervise one of the values will be used
-       to setup thread priority.
-    */
-    PaWasapiThreadPriority threadPriority;
-} 
-PaWasapiStreamInfo;
-
-
-/** Returns default sound format for device. Format is represented by PaWinWaveFormat or 
-    WAVEFORMATEXTENSIBLE structure.
-
- @param pFormat Pointer to PaWinWaveFormat or WAVEFORMATEXTENSIBLE structure.
- @param nFormatSize Size of PaWinWaveFormat or WAVEFORMATEXTENSIBLE structure in bytes.
- @param nDevice Device index.
-
- @return Non-negative value indicating the number of bytes copied into format decriptor
-         or, a PaErrorCode (which are always negative) if PortAudio is not initialized
-         or an error is encountered.
-*/
-int PaWasapi_GetDeviceDefaultFormat( void *pFormat, unsigned int nFormatSize, PaDeviceIndex nDevice );
-
-
-/** Returns device role (PaWasapiDeviceRole enum).
-
- @param nDevice device index.
-
- @return Non-negative value indicating device role or, a PaErrorCode (which are always negative)
-         if PortAudio is not initialized or an error is encountered.
-*/
-int/*PaWasapiDeviceRole*/ PaWasapi_GetDeviceRole( PaDeviceIndex nDevice );
-
-
-/** Boost thread priority of calling thread (MMCSS). Use it for Blocking Interface only for thread
-    which makes calls to Pa_WriteStream/Pa_ReadStream.
-
- @param hTask Handle to pointer to priority task. Must be used with PaWasapi_RevertThreadPriority
-              method to revert thread priority to initial state.
-
- @param nPriorityClass Id of thread priority of PaWasapiThreadPriority type. Specifying 
-                       eThreadPriorityNone does nothing.
-
- @return Error code indicating success or failure.
- @see    PaWasapi_RevertThreadPriority
-*/
-PaError PaWasapi_ThreadPriorityBoost( void **hTask, PaWasapiThreadPriority nPriorityClass );
-
-
-/** Boost thread priority of calling thread (MMCSS). Use it for Blocking Interface only for thread
-    which makes calls to Pa_WriteStream/Pa_ReadStream.
-
- @param  hTask Task handle obtained by PaWasapi_BoostThreadPriority method.
- @return Error code indicating success or failure.
- @see    PaWasapi_BoostThreadPriority
-*/
-PaError PaWasapi_ThreadPriorityRevert( void *hTask );
-
-
-/** Get number of frames per host buffer. This is maximal value of frames of WASAPI buffer which 
-    can be locked for operations. Use this method as helper to findout maximal values of 
-    inputFrames/outputFrames of PaWasapiHostProcessorCallback.
-
- @param  pStream Pointer to PaStream to query.
- @param  nInput  Pointer to variable to receive number of input frames. Can be NULL.
- @param  nOutput Pointer to variable to receive number of output frames. Can be NULL.
- @return Error code indicating success or failure.
- @see    PaWasapiHostProcessorCallback
-*/
-PaError PaWasapi_GetFramesPerHostBuffer( PaStream *pStream, unsigned int *nInput, unsigned int *nOutput );
-
-
-/** Get number of jacks associated with a WASAPI device.  Use this method to determine if
-    there are any jacks associated with the provided WASAPI device.  Not all audio devices
-	will support this capability.  This is valid for both input and output devices.
- @param  nDevice  device index.
- @param  jcount   Number of jacks is returned in this variable
- @return Error code indicating success or failure
- @see PaWasapi_GetJackDescription
- */
-PaError PaWasapi_GetJackCount(PaDeviceIndex nDevice, int *jcount);
-
-
-/** Get the jack description associated with a WASAPI device and jack number
-    Before this function is called, use PaWasapi_GetJackCount to determine the
-	number of jacks associated with device.  If jcount is greater than zero, then
-	each jack from 0 to jcount can be queried with this function to get the jack
-	description.
- @param  nDevice  device index.
- @param  jindex   Which jack to return information
- @param  KSJACK_DESCRIPTION This structure filled in on success.
- @return Error code indicating success or failure
- @see PaWasapi_GetJackCount
- */
-PaError PaWasapi_GetJackDescription(PaDeviceIndex nDevice, int jindex, PaWasapiJackDescription *pJackDescription);
-
-
-/*
-    IMPORTANT:
-
-    WASAPI is implemented for Callback and Blocking interfaces. It supports Shared and Exclusive
-    share modes. 
-    
-    Exclusive Mode:
-
-        Exclusive mode allows to deliver audio data directly to hardware bypassing
-        software mixing.
-        Exclusive mode is specified by 'paWinWasapiExclusive' flag.
-
-    Callback Interface:
-
-        Provides best audio quality with low latency. Callback interface is implemented in 
-        two versions:
-
-        1) Event-Driven:
-        This is the most powerful WASAPI implementation which provides glitch-free
-        audio at around 3ms latency in Exclusive mode. Lowest possible latency for this mode is 
-        3 ms for HD Audio class audio chips. For the Shared mode latency can not be 
-		lower than 20 ms.
-
-        2) Poll-Driven:
-        Polling is another 2-nd method to operate with WASAPI. It is less efficient than Event-Driven
-        and provides latency at around 10-13ms. Polling must be used to overcome a system bug
-        under Windows Vista x64 when application is WOW64(32-bit) and Event-Driven method simply 
-        times out (event handle is never signalled on buffer completion). Please note, such WOW64 bug 
-        does not exist in Vista x86 or Windows 7.
-        Polling can be setup by speciying 'paWinWasapiPolling' flag. Our WASAPI implementation detects
-        WOW64 bug and sets 'paWinWasapiPolling' automatically.
-
-    Thread priority:
-
-        Normally thread priority is set automatically and does not require modification. Although
-        if user wants some tweaking thread priority can be modified by setting 'paWinWasapiThreadPriority'
-        flag and specifying 'PaWasapiStreamInfo::threadPriority' with value from PaWasapiThreadPriority 
-        enum.
-
-    Blocking Interface:
-
-        Blocking interface is implemented but due to above described Poll-Driven method can not
-        deliver lowest possible latency. Specifying too low latency in Shared mode will result in 
-        distorted audio although Exclusive mode adds stability.
-
-    Pa_IsFormatSupported:
-
-        To check format with correct Share Mode (Exclusive/Shared) you must supply
-        PaWasapiStreamInfo with flags paWinWasapiExclusive set through member of 
-        PaStreamParameters::hostApiSpecificStreamInfo structure.
-
-    Pa_OpenStream:
-
-        To set desired Share Mode (Exclusive/Shared) you must supply
-        PaWasapiStreamInfo with flags paWinWasapiExclusive set through member of 
-        PaStreamParameters::hostApiSpecificStreamInfo structure.
-*/
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* PA_WIN_WASAPI_H */                                  
+#ifndef PA_WIN_WASAPI_H
+#define PA_WIN_WASAPI_H
+/*
+ * $Id:  $
+ * PortAudio Portable Real-Time Audio Library
+ * DirectSound specific extensions
+ *
+ * Copyright (c) 1999-2007 Ross Bencina and Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however, 
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also 
+ * requested that these non-binding requests be included along with the 
+ * license above.
+ */
+
+/** @file
+ @ingroup public_header
+ @brief WASAPI-specific PortAudio API extension header file.
+*/
+
+#include "portaudio.h"
+#include "pa_win_waveformat.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+
+/* Setup flags */
+typedef enum PaWasapiFlags
+{
+    /* puts WASAPI into exclusive mode */
+    paWinWasapiExclusive                = (1 << 0),
+
+    /* allows to skip internal PA processing completely */
+    paWinWasapiRedirectHostProcessor    = (1 << 1),
+
+    /* assigns custom channel mask */
+    paWinWasapiUseChannelMask           = (1 << 2),
+
+    /* selects non-Event driven method of data read/write
+       Note: WASAPI Event driven core is capable of 2ms latency!!!, but Polling
+             method can only provide 15-20ms latency. */
+    paWinWasapiPolling                  = (1 << 3),
+
+    /* forces custom thread priority setting, must be used if PaWasapiStreamInfo::threadPriority 
+       is set to a custom value */
+    paWinWasapiThreadPriority           = (1 << 4)
+}
+PaWasapiFlags;
+#define paWinWasapiExclusive             (paWinWasapiExclusive)
+#define paWinWasapiRedirectHostProcessor (paWinWasapiRedirectHostProcessor)
+#define paWinWasapiUseChannelMask        (paWinWasapiUseChannelMask)
+#define paWinWasapiPolling               (paWinWasapiPolling)
+#define paWinWasapiThreadPriority        (paWinWasapiThreadPriority)
+
+
+/* Host processor. Allows to skip internal PA processing completely. 
+   You must set paWinWasapiRedirectHostProcessor flag to PaWasapiStreamInfo::flags member
+   in order to have host processor redirected to your callback.
+   Use with caution! inputFrames and outputFrames depend solely on final device setup.
+   To query maximal values of inputFrames/outputFrames use PaWasapi_GetFramesPerHostBuffer.
+*/
+typedef void (*PaWasapiHostProcessorCallback) (void *inputBuffer,  long inputFrames,
+                                               void *outputBuffer, long outputFrames,
+                                               void *userData);
+
+/* Device role. */
+typedef enum PaWasapiDeviceRole
+{
+    eRoleRemoteNetworkDevice = 0,
+    eRoleSpeakers,
+    eRoleLineLevel,
+    eRoleHeadphones,
+    eRoleMicrophone,
+    eRoleHeadset,
+    eRoleHandset,
+    eRoleUnknownDigitalPassthrough,
+    eRoleSPDIF,
+    eRoleHDMI,
+    eRoleUnknownFormFactor
+}
+PaWasapiDeviceRole;
+
+
+/* Jack connection type. */
+typedef enum PaWasapiJackConnectionType
+{
+    eJackConnTypeUnknown,
+    eJackConnType3Point5mm,
+    eJackConnTypeQuarter,
+    eJackConnTypeAtapiInternal,
+    eJackConnTypeRCA,
+    eJackConnTypeOptical,
+    eJackConnTypeOtherDigital,
+    eJackConnTypeOtherAnalog,
+    eJackConnTypeMultichannelAnalogDIN,
+    eJackConnTypeXlrProfessional,
+    eJackConnTypeRJ11Modem,
+    eJackConnTypeCombination
+} 
+PaWasapiJackConnectionType;
+
+
+/* Jack geometric location. */
+typedef enum PaWasapiJackGeoLocation
+{
+    eJackGeoLocUnk = 0,
+    eJackGeoLocRear = 0x1, /* matches EPcxGeoLocation::eGeoLocRear */
+    eJackGeoLocFront,
+    eJackGeoLocLeft,
+    eJackGeoLocRight,
+    eJackGeoLocTop,
+    eJackGeoLocBottom,
+    eJackGeoLocRearPanel,
+    eJackGeoLocRiser,
+    eJackGeoLocInsideMobileLid,
+    eJackGeoLocDrivebay,
+    eJackGeoLocHDMI,
+    eJackGeoLocOutsideMobileLid,
+    eJackGeoLocATAPI,
+    eJackGeoLocReserved5,
+    eJackGeoLocReserved6,
+} 
+PaWasapiJackGeoLocation;
+
+
+/* Jack general location. */
+typedef enum PaWasapiJackGenLocation
+{
+    eJackGenLocPrimaryBox = 0,
+    eJackGenLocInternal,
+    eJackGenLocSeparate,
+    eJackGenLocOther
+} 
+PaWasapiJackGenLocation;
+
+
+/* Jack's type of port. */
+typedef enum PaWasapiJackPortConnection
+{
+    eJackPortConnJack = 0,
+    eJackPortConnIntegratedDevice,
+    eJackPortConnBothIntegratedAndJack,
+    eJackPortConnUnknown
+} 
+PaWasapiJackPortConnection;
+
+
+/* Thread priority. */
+typedef enum PaWasapiThreadPriority
+{
+    eThreadPriorityNone = 0,
+    eThreadPriorityAudio,            //!< Default for Shared mode.
+    eThreadPriorityCapture,
+    eThreadPriorityDistribution,
+    eThreadPriorityGames,
+    eThreadPriorityPlayback,
+    eThreadPriorityProAudio,        //!< Default for Exclusive mode.
+    eThreadPriorityWindowManager
+}
+PaWasapiThreadPriority;
+
+
+/* Stream descriptor. */
+typedef struct PaWasapiJackDescription 
+{
+    unsigned long              channelMapping;
+    unsigned long              color; /* derived from macro: #define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16))) */
+    PaWasapiJackConnectionType connectionType;
+    PaWasapiJackGeoLocation    geoLocation;
+    PaWasapiJackGenLocation    genLocation;
+    PaWasapiJackPortConnection portConnection;
+    unsigned int               isConnected;
+}
+PaWasapiJackDescription;
+
+
+/** Stream category.
+   Note:
+    - values are equal to WASAPI AUDIO_STREAM_CATEGORY enum
+    - supported since Windows 8.0, noop on earler versions
+    - values 1,2 are deprecated on Windows 10 and not included into enumeration
+
+ @version Available as of 19.6.0
+*/
+typedef enum PaWasapiStreamCategory
+{
+    eAudioCategoryOther           = 0,
+    eAudioCategoryCommunications  = 3,
+    eAudioCategoryAlerts          = 4,
+    eAudioCategorySoundEffects    = 5,
+    eAudioCategoryGameEffects     = 6,
+    eAudioCategoryGameMedia       = 7,
+    eAudioCategoryGameChat        = 8,
+    eAudioCategorySpeech          = 9,
+    eAudioCategoryMovie           = 10,
+    eAudioCategoryMedia           = 11
+}
+PaWasapiStreamCategory;
+
+
+/** Stream option.
+   Note:
+    - values are equal to WASAPI AUDCLNT_STREAMOPTIONS enum
+    - supported since Windows 8.1, noop on earler versions
+
+ @version Available as of 19.6.0
+*/
+typedef enum PaWasapiStreamOption
+{
+    eStreamOptionNone        = 0, //!< default
+    eStreamOptionRaw         = 1, //!< bypass WASAPI Audio Engine DSP effects, supported since Windows 8.1
+    eStreamOptionMatchFormat = 2  //!< force WASAPI Audio Engine into a stream format, supported since Windows 10
+}
+PaWasapiStreamOption;
+
+
+/* Stream descriptor. */
+typedef struct PaWasapiStreamInfo 
+{
+    unsigned long size;             /**< sizeof(PaWasapiStreamInfo) */
+    PaHostApiTypeId hostApiType;    /**< paWASAPI */
+    unsigned long version;          /**< 1 */
+
+    unsigned long flags;            /**< collection of PaWasapiFlags */
+
+    /** Support for WAVEFORMATEXTENSIBLE channel masks. If flags contains
+       paWinWasapiUseChannelMask this allows you to specify which speakers 
+       to address in a multichannel stream. Constants for channelMask
+       are specified in pa_win_waveformat.h. Will be used only if 
+       paWinWasapiUseChannelMask flag is specified.
+    */
+    PaWinWaveFormatChannelMask channelMask;
+
+    /** Delivers raw data to callback obtained from GetBuffer() methods skipping
+       internal PortAudio processing inventory completely. userData parameter will 
+       be the same that was passed to Pa_OpenStream method. Will be used only if 
+       paWinWasapiRedirectHostProcessor flag is specified.
+    */
+    PaWasapiHostProcessorCallback hostProcessorOutput;
+    PaWasapiHostProcessorCallback hostProcessorInput;
+
+    /** Specifies thread priority explicitly. Will be used only if paWinWasapiThreadPriority flag
+       is specified.
+
+       Please note, if Input/Output streams are opened simultaniously (Full-Duplex mode)
+       you shall specify same value for threadPriority or othervise one of the values will be used
+       to setup thread priority.
+    */
+    PaWasapiThreadPriority threadPriority;
+
+    /** Stream category.
+     @see PaWasapiStreamCategory
+     @version Available as of 19.6.0
+    */
+    PaWasapiStreamCategory streamCategory;
+
+    /** Stream option.
+     @see PaWasapiStreamOption
+     @version Available as of 19.6.0
+    */
+    PaWasapiStreamOption streamOption;
+} 
+PaWasapiStreamInfo;
+
+
+/** Returns default sound format for device. Format is represented by PaWinWaveFormat or 
+    WAVEFORMATEXTENSIBLE structure.
+
+ @param pFormat Pointer to PaWinWaveFormat or WAVEFORMATEXTENSIBLE structure.
+ @param nFormatSize Size of PaWinWaveFormat or WAVEFORMATEXTENSIBLE structure in bytes.
+ @param nDevice Device index.
+
+ @return Non-negative value indicating the number of bytes copied into format decriptor
+         or, a PaErrorCode (which are always negative) if PortAudio is not initialized
+         or an error is encountered.
+*/
+int PaWasapi_GetDeviceDefaultFormat( void *pFormat, unsigned int nFormatSize, PaDeviceIndex nDevice );
+
+
+/** Returns device role (PaWasapiDeviceRole enum).
+
+ @param nDevice device index.
+
+ @return Non-negative value indicating device role or, a PaErrorCode (which are always negative)
+         if PortAudio is not initialized or an error is encountered.
+*/
+int/*PaWasapiDeviceRole*/ PaWasapi_GetDeviceRole( PaDeviceIndex nDevice );
+
+
+/** Boost thread priority of calling thread (MMCSS). Use it for Blocking Interface only for thread
+    which makes calls to Pa_WriteStream/Pa_ReadStream.
+
+ @param hTask Handle to pointer to priority task. Must be used with PaWasapi_RevertThreadPriority
+              method to revert thread priority to initial state.
+
+ @param nPriorityClass Id of thread priority of PaWasapiThreadPriority type. Specifying 
+                       eThreadPriorityNone does nothing.
+
+ @return Error code indicating success or failure.
+ @see    PaWasapi_RevertThreadPriority
+*/
+PaError PaWasapi_ThreadPriorityBoost( void **hTask, PaWasapiThreadPriority nPriorityClass );
+
+
+/** Boost thread priority of calling thread (MMCSS). Use it for Blocking Interface only for thread
+    which makes calls to Pa_WriteStream/Pa_ReadStream.
+
+ @param  hTask Task handle obtained by PaWasapi_BoostThreadPriority method.
+ @return Error code indicating success or failure.
+ @see    PaWasapi_BoostThreadPriority
+*/
+PaError PaWasapi_ThreadPriorityRevert( void *hTask );
+
+
+/** Get number of frames per host buffer. This is maximal value of frames of WASAPI buffer which 
+    can be locked for operations. Use this method as helper to findout maximal values of 
+    inputFrames/outputFrames of PaWasapiHostProcessorCallback.
+
+ @param  pStream Pointer to PaStream to query.
+ @param  nInput  Pointer to variable to receive number of input frames. Can be NULL.
+ @param  nOutput Pointer to variable to receive number of output frames. Can be NULL.
+ @return Error code indicating success or failure.
+ @see    PaWasapiHostProcessorCallback
+*/
+PaError PaWasapi_GetFramesPerHostBuffer( PaStream *pStream, unsigned int *nInput, unsigned int *nOutput );
+
+
+/** Get number of jacks associated with a WASAPI device.  Use this method to determine if
+    there are any jacks associated with the provided WASAPI device.  Not all audio devices
+    will support this capability.  This is valid for both input and output devices.
+ @param  nDevice  device index.
+ @param  jcount   Number of jacks is returned in this variable
+ @return Error code indicating success or failure
+ @see PaWasapi_GetJackDescription
+ */
+PaError PaWasapi_GetJackCount(PaDeviceIndex nDevice, int *jcount);
+
+
+/** Get the jack description associated with a WASAPI device and jack number
+    Before this function is called, use PaWasapi_GetJackCount to determine the
+    number of jacks associated with device.  If jcount is greater than zero, then
+    each jack from 0 to jcount can be queried with this function to get the jack
+    description.
+ @param  nDevice  device index.
+ @param  jindex   Which jack to return information
+ @param  KSJACK_DESCRIPTION This structure filled in on success.
+ @return Error code indicating success or failure
+ @see PaWasapi_GetJackCount
+ */
+PaError PaWasapi_GetJackDescription(PaDeviceIndex nDevice, int jindex, PaWasapiJackDescription *pJackDescription);
+
+
+/*
+    IMPORTANT:
+
+    WASAPI is implemented for Callback and Blocking interfaces. It supports Shared and Exclusive
+    share modes. 
+    
+    Exclusive Mode:
+
+        Exclusive mode allows to deliver audio data directly to hardware bypassing
+        software mixing.
+        Exclusive mode is specified by 'paWinWasapiExclusive' flag.
+
+    Callback Interface:
+
+        Provides best audio quality with low latency. Callback interface is implemented in 
+        two versions:
+
+        1) Event-Driven:
+        This is the most powerful WASAPI implementation which provides glitch-free
+        audio at around 3ms latency in Exclusive mode. Lowest possible latency for this mode is 
+        3 ms for HD Audio class audio chips. For the Shared mode latency can not be 
+        lower than 20 ms.
+
+        2) Poll-Driven:
+        Polling is another 2-nd method to operate with WASAPI. It is less efficient than Event-Driven
+        and provides latency at around 10-13ms. Polling must be used to overcome a system bug
+        under Windows Vista x64 when application is WOW64(32-bit) and Event-Driven method simply 
+        times out (event handle is never signalled on buffer completion). Please note, such WOW64 bug 
+        does not exist in Vista x86 or Windows 7.
+        Polling can be setup by speciying 'paWinWasapiPolling' flag. Our WASAPI implementation detects
+        WOW64 bug and sets 'paWinWasapiPolling' automatically.
+
+    Thread priority:
+
+        Normally thread priority is set automatically and does not require modification. Although
+        if user wants some tweaking thread priority can be modified by setting 'paWinWasapiThreadPriority'
+        flag and specifying 'PaWasapiStreamInfo::threadPriority' with value from PaWasapiThreadPriority 
+        enum.
+
+    Blocking Interface:
+
+        Blocking interface is implemented but due to above described Poll-Driven method can not
+        deliver lowest possible latency. Specifying too low latency in Shared mode will result in 
+        distorted audio although Exclusive mode adds stability.
+
+    Pa_IsFormatSupported:
+
+        To check format with correct Share Mode (Exclusive/Shared) you must supply
+        PaWasapiStreamInfo with flags paWinWasapiExclusive set through member of 
+        PaStreamParameters::hostApiSpecificStreamInfo structure.
+
+    Pa_OpenStream:
+
+        To set desired Share Mode (Exclusive/Shared) you must supply
+        PaWasapiStreamInfo with flags paWinWasapiExclusive set through member of 
+        PaStreamParameters::hostApiSpecificStreamInfo structure.
+*/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* PA_WIN_WASAPI_H */                                  
--- a/src/hostapi/wasapi/mingw-include/audioclient.h
+++ b/src/hostapi/wasapi/mingw-include/audioclient.h
@@ -1,1177 +1,1177 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for audioclient.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 500
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __audioclient_h__
-#define __audioclient_h__
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IAudioClient_FWD_DEFINED__
-#define __IAudioClient_FWD_DEFINED__
-typedef interface IAudioClient IAudioClient;
-#endif 	/* __IAudioClient_FWD_DEFINED__ */
-
-
-#ifndef __IAudioRenderClient_FWD_DEFINED__
-#define __IAudioRenderClient_FWD_DEFINED__
-typedef interface IAudioRenderClient IAudioRenderClient;
-#endif 	/* __IAudioRenderClient_FWD_DEFINED__ */
-
-
-#ifndef __IAudioCaptureClient_FWD_DEFINED__
-#define __IAudioCaptureClient_FWD_DEFINED__
-typedef interface IAudioCaptureClient IAudioCaptureClient;
-#endif 	/* __IAudioCaptureClient_FWD_DEFINED__ */
-
-
-#ifndef __IAudioClock_FWD_DEFINED__
-#define __IAudioClock_FWD_DEFINED__
-typedef interface IAudioClock IAudioClock;
-#endif 	/* __IAudioClock_FWD_DEFINED__ */
-
-
-#ifndef __ISimpleAudioVolume_FWD_DEFINED__
-#define __ISimpleAudioVolume_FWD_DEFINED__
-typedef interface ISimpleAudioVolume ISimpleAudioVolume;
-#endif 	/* __ISimpleAudioVolume_FWD_DEFINED__ */
-
-
-#ifndef __IAudioStreamVolume_FWD_DEFINED__
-#define __IAudioStreamVolume_FWD_DEFINED__
-typedef interface IAudioStreamVolume IAudioStreamVolume;
-#endif 	/* __IAudioStreamVolume_FWD_DEFINED__ */
-
-
-#ifndef __IChannelAudioVolume_FWD_DEFINED__
-#define __IChannelAudioVolume_FWD_DEFINED__
-typedef interface IChannelAudioVolume IChannelAudioVolume;
-#endif 	/* __IChannelAudioVolume_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "wtypes.h"
-#include "unknwn.h"
-#include "AudioSessionTypes.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_audioclient_0000_0000 */
-/* [local] */ 
-
-#if 0
-typedef /* [hidden][restricted] */ struct WAVEFORMATEX
-    {
-    WORD wFormatTag;
-    WORD nChannels;
-    DWORD nSamplesPerSec;
-    DWORD nAvgBytesPerSec;
-    WORD nBlockAlign;
-    WORD wBitsPerSample;
-    WORD cbSize;
-    } 	WAVEFORMATEX;
-
-#else
-#include <mmreg.h>
-#endif
-#if 0
-typedef /* [hidden][restricted] */ LONGLONG REFERENCE_TIME;
-
-#else
-#define _IKsControl_
-#include <ks.h>
-#include <ksmedia.h>
-#endif
-
-enum _AUDCLNT_BUFFERFLAGS
-    {	AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY	= 0x1,
-	AUDCLNT_BUFFERFLAGS_SILENT	= 0x2,
-	AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR	= 0x4
-    } ;
-
-
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IAudioClient_INTERFACE_DEFINED__
-#define __IAudioClient_INTERFACE_DEFINED__
-
-/* interface IAudioClient */
-/* [local][unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IAudioClient;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("1CB9AD4C-DBFA-4c32-B178-C2F568A703B2")
-    IAudioClient : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Initialize( 
-            /* [in] */ 
-            __in  AUDCLNT_SHAREMODE ShareMode,
-            /* [in] */ 
-            __in  DWORD StreamFlags,
-            /* [in] */ 
-            __in  REFERENCE_TIME hnsBufferDuration,
-            /* [in] */ 
-            __in  REFERENCE_TIME hnsPeriodicity,
-            /* [in] */ 
-            __in  const WAVEFORMATEX *pFormat,
-            /* [in] */ 
-            __in_opt  LPCGUID AudioSessionGuid) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetBufferSize( 
-            /* [out] */ 
-            __out  UINT32 *pNumBufferFrames) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetStreamLatency( 
-            /* [out] */ 
-            __out  REFERENCE_TIME *phnsLatency) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetCurrentPadding( 
-            /* [out] */ 
-            __out  UINT32 *pNumPaddingFrames) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
-            /* [in] */ 
-            __in  AUDCLNT_SHAREMODE ShareMode,
-            /* [in] */ 
-            __in  const WAVEFORMATEX *pFormat,
-            /* [unique][out] */ 
-            __out_opt  WAVEFORMATEX **ppClosestMatch) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetMixFormat( 
-            /* [out] */ 
-            __out  WAVEFORMATEX **ppDeviceFormat) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetDevicePeriod( 
-            /* [out] */ 
-            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
-            /* [out] */ 
-            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetEventHandle( 
-            /* [in] */ HANDLE eventHandle) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetService( 
-            /* [in] */ 
-            __in  REFIID riid,
-            /* [iid_is][out] */ 
-            __out  void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioClientVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioClient * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioClient * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
-            IAudioClient * This,
-            /* [in] */ 
-            __in  AUDCLNT_SHAREMODE ShareMode,
-            /* [in] */ 
-            __in  DWORD StreamFlags,
-            /* [in] */ 
-            __in  REFERENCE_TIME hnsBufferDuration,
-            /* [in] */ 
-            __in  REFERENCE_TIME hnsPeriodicity,
-            /* [in] */ 
-            __in  const WAVEFORMATEX *pFormat,
-            /* [in] */ 
-            __in_opt  LPCGUID AudioSessionGuid);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetBufferSize )( 
-            IAudioClient * This,
-            /* [out] */ 
-            __out  UINT32 *pNumBufferFrames);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetStreamLatency )( 
-            IAudioClient * This,
-            /* [out] */ 
-            __out  REFERENCE_TIME *phnsLatency);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCurrentPadding )( 
-            IAudioClient * This,
-            /* [out] */ 
-            __out  UINT32 *pNumPaddingFrames);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
-            IAudioClient * This,
-            /* [in] */ 
-            __in  AUDCLNT_SHAREMODE ShareMode,
-            /* [in] */ 
-            __in  const WAVEFORMATEX *pFormat,
-            /* [unique][out] */ 
-            __out_opt  WAVEFORMATEX **ppClosestMatch);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetMixFormat )( 
-            IAudioClient * This,
-            /* [out] */ 
-            __out  WAVEFORMATEX **ppDeviceFormat);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDevicePeriod )( 
-            IAudioClient * This,
-            /* [out] */ 
-            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
-            /* [out] */ 
-            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod);
-        
-        HRESULT ( STDMETHODCALLTYPE *Start )( 
-            IAudioClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Stop )( 
-            IAudioClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Reset )( 
-            IAudioClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetEventHandle )( 
-            IAudioClient * This,
-            /* [in] */ HANDLE eventHandle);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetService )( 
-            IAudioClient * This,
-            /* [in] */ 
-            __in  REFIID riid,
-            /* [iid_is][out] */ 
-            __out  void **ppv);
-        
-        END_INTERFACE
-    } IAudioClientVtbl;
-
-    interface IAudioClient
-    {
-        CONST_VTBL struct IAudioClientVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioClient_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioClient_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioClient_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioClient_Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid)	\
-    ( (This)->lpVtbl -> Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid) ) 
-
-#define IAudioClient_GetBufferSize(This,pNumBufferFrames)	\
-    ( (This)->lpVtbl -> GetBufferSize(This,pNumBufferFrames) ) 
-
-#define IAudioClient_GetStreamLatency(This,phnsLatency)	\
-    ( (This)->lpVtbl -> GetStreamLatency(This,phnsLatency) ) 
-
-#define IAudioClient_GetCurrentPadding(This,pNumPaddingFrames)	\
-    ( (This)->lpVtbl -> GetCurrentPadding(This,pNumPaddingFrames) ) 
-
-#define IAudioClient_IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch)	\
-    ( (This)->lpVtbl -> IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch) ) 
-
-#define IAudioClient_GetMixFormat(This,ppDeviceFormat)	\
-    ( (This)->lpVtbl -> GetMixFormat(This,ppDeviceFormat) ) 
-
-#define IAudioClient_GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod)	\
-    ( (This)->lpVtbl -> GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod) ) 
-
-#define IAudioClient_Start(This)	\
-    ( (This)->lpVtbl -> Start(This) ) 
-
-#define IAudioClient_Stop(This)	\
-    ( (This)->lpVtbl -> Stop(This) ) 
-
-#define IAudioClient_Reset(This)	\
-    ( (This)->lpVtbl -> Reset(This) ) 
-
-#define IAudioClient_SetEventHandle(This,eventHandle)	\
-    ( (This)->lpVtbl -> SetEventHandle(This,eventHandle) ) 
-
-#define IAudioClient_GetService(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetService(This,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioClient_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioRenderClient_INTERFACE_DEFINED__
-#define __IAudioRenderClient_INTERFACE_DEFINED__
-
-/* interface IAudioRenderClient */
-/* [local][unique][helpstring][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IAudioRenderClient;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("F294ACFC-3146-4483-A7BF-ADDCA7C260E2")
-    IAudioRenderClient : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
-            /* [in] */ 
-            __in  UINT32 NumFramesRequested,
-            /* [out] */ 
-            __out  BYTE **ppData) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
-            /* [in] */ 
-            __in  UINT32 NumFramesWritten,
-            /* [in] */ 
-            __in  DWORD dwFlags) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioRenderClientVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioRenderClient * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioRenderClient * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioRenderClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
-            IAudioRenderClient * This,
-            /* [in] */ 
-            __in  UINT32 NumFramesRequested,
-            /* [out] */ 
-            __out  BYTE **ppData);
-        
-        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
-            IAudioRenderClient * This,
-            /* [in] */ 
-            __in  UINT32 NumFramesWritten,
-            /* [in] */ 
-            __in  DWORD dwFlags);
-        
-        END_INTERFACE
-    } IAudioRenderClientVtbl;
-
-    interface IAudioRenderClient
-    {
-        CONST_VTBL struct IAudioRenderClientVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioRenderClient_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioRenderClient_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioRenderClient_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioRenderClient_GetBuffer(This,NumFramesRequested,ppData)	\
-    ( (This)->lpVtbl -> GetBuffer(This,NumFramesRequested,ppData) ) 
-
-#define IAudioRenderClient_ReleaseBuffer(This,NumFramesWritten,dwFlags)	\
-    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesWritten,dwFlags) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioRenderClient_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioCaptureClient_INTERFACE_DEFINED__
-#define __IAudioCaptureClient_INTERFACE_DEFINED__
-
-/* interface IAudioCaptureClient */
-/* [local][unique][helpstring][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IAudioCaptureClient;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("C8ADBD64-E71E-48a0-A4DE-185C395CD317")
-    IAudioCaptureClient : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
-            /* [out] */ 
-            __out  BYTE **ppData,
-            /* [out] */ 
-            __out  UINT32 *pNumFramesToRead,
-            /* [out] */ 
-            __out  DWORD *pdwFlags,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64DevicePosition,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64QPCPosition) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
-            /* [in] */ 
-            __in  UINT32 NumFramesRead) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetNextPacketSize( 
-            /* [out] */ 
-            __out  UINT32 *pNumFramesInNextPacket) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioCaptureClientVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioCaptureClient * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioCaptureClient * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioCaptureClient * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
-            IAudioCaptureClient * This,
-            /* [out] */ 
-            __out  BYTE **ppData,
-            /* [out] */ 
-            __out  UINT32 *pNumFramesToRead,
-            /* [out] */ 
-            __out  DWORD *pdwFlags,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64DevicePosition,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64QPCPosition);
-        
-        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
-            IAudioCaptureClient * This,
-            /* [in] */ 
-            __in  UINT32 NumFramesRead);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetNextPacketSize )( 
-            IAudioCaptureClient * This,
-            /* [out] */ 
-            __out  UINT32 *pNumFramesInNextPacket);
-        
-        END_INTERFACE
-    } IAudioCaptureClientVtbl;
-
-    interface IAudioCaptureClient
-    {
-        CONST_VTBL struct IAudioCaptureClientVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioCaptureClient_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioCaptureClient_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioCaptureClient_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioCaptureClient_GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition)	\
-    ( (This)->lpVtbl -> GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition) ) 
-
-#define IAudioCaptureClient_ReleaseBuffer(This,NumFramesRead)	\
-    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesRead) ) 
-
-#define IAudioCaptureClient_GetNextPacketSize(This,pNumFramesInNextPacket)	\
-    ( (This)->lpVtbl -> GetNextPacketSize(This,pNumFramesInNextPacket) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioCaptureClient_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_audioclient_0000_0003 */
-/* [local] */ 
-
-#define AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ  0x00000001
-
-
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_s_ifspec;
-
-#ifndef __IAudioClock_INTERFACE_DEFINED__
-#define __IAudioClock_INTERFACE_DEFINED__
-
-/* interface IAudioClock */
-/* [local][unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IAudioClock;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("CD63314F-3FBA-4a1b-812C-EF96358728E7")
-    IAudioClock : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
-            /* [out] */ 
-            __out  UINT64 *pu64Frequency) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
-            /* [out] */ 
-            __out  UINT64 *pu64Position,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64QPCPosition) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
-            /* [out] */ 
-            __out  DWORD *pdwCharacteristics) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioClockVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioClock * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioClock * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioClock * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
-            IAudioClock * This,
-            /* [out] */ 
-            __out  UINT64 *pu64Frequency);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
-            IAudioClock * This,
-            /* [out] */ 
-            __out  UINT64 *pu64Position,
-            /* [unique][out] */ 
-            __out_opt  UINT64 *pu64QPCPosition);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
-            IAudioClock * This,
-            /* [out] */ 
-            __out  DWORD *pdwCharacteristics);
-        
-        END_INTERFACE
-    } IAudioClockVtbl;
-
-    interface IAudioClock
-    {
-        CONST_VTBL struct IAudioClockVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioClock_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioClock_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioClock_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioClock_GetFrequency(This,pu64Frequency)	\
-    ( (This)->lpVtbl -> GetFrequency(This,pu64Frequency) ) 
-
-#define IAudioClock_GetPosition(This,pu64Position,pu64QPCPosition)	\
-    ( (This)->lpVtbl -> GetPosition(This,pu64Position,pu64QPCPosition) ) 
-
-#define IAudioClock_GetCharacteristics(This,pdwCharacteristics)	\
-    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioClock_INTERFACE_DEFINED__ */
-
-
-#ifndef __ISimpleAudioVolume_INTERFACE_DEFINED__
-#define __ISimpleAudioVolume_INTERFACE_DEFINED__
-
-/* interface ISimpleAudioVolume */
-/* [local][unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_ISimpleAudioVolume;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("87CE5498-68D6-44E5-9215-6DA47EF883D8")
-    ISimpleAudioVolume : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE SetMasterVolume( 
-            /* [in] */ 
-            __in  float fLevel,
-            /* [unique][in] */ LPCGUID EventContext) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetMasterVolume( 
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetMute( 
-            /* [in] */ 
-            __in  const BOOL bMute,
-            /* [unique][in] */ LPCGUID EventContext) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetMute( 
-            /* [out] */ 
-            __out  BOOL *pbMute) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ISimpleAudioVolumeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ISimpleAudioVolume * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ISimpleAudioVolume * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ISimpleAudioVolume * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetMasterVolume )( 
-            ISimpleAudioVolume * This,
-            /* [in] */ 
-            __in  float fLevel,
-            /* [unique][in] */ LPCGUID EventContext);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetMasterVolume )( 
-            ISimpleAudioVolume * This,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetMute )( 
-            ISimpleAudioVolume * This,
-            /* [in] */ 
-            __in  const BOOL bMute,
-            /* [unique][in] */ LPCGUID EventContext);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetMute )( 
-            ISimpleAudioVolume * This,
-            /* [out] */ 
-            __out  BOOL *pbMute);
-        
-        END_INTERFACE
-    } ISimpleAudioVolumeVtbl;
-
-    interface ISimpleAudioVolume
-    {
-        CONST_VTBL struct ISimpleAudioVolumeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ISimpleAudioVolume_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ISimpleAudioVolume_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ISimpleAudioVolume_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ISimpleAudioVolume_SetMasterVolume(This,fLevel,EventContext)	\
-    ( (This)->lpVtbl -> SetMasterVolume(This,fLevel,EventContext) ) 
-
-#define ISimpleAudioVolume_GetMasterVolume(This,pfLevel)	\
-    ( (This)->lpVtbl -> GetMasterVolume(This,pfLevel) ) 
-
-#define ISimpleAudioVolume_SetMute(This,bMute,EventContext)	\
-    ( (This)->lpVtbl -> SetMute(This,bMute,EventContext) ) 
-
-#define ISimpleAudioVolume_GetMute(This,pbMute)	\
-    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ISimpleAudioVolume_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioStreamVolume_INTERFACE_DEFINED__
-#define __IAudioStreamVolume_INTERFACE_DEFINED__
-
-/* interface IAudioStreamVolume */
-/* [local][unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IAudioStreamVolume;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("93014887-242D-4068-8A15-CF5E93B90FE3")
-    IAudioStreamVolume : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
-            /* [out] */ 
-            __out  UINT32 *pdwCount) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [in] */ 
-            __in  const float fLevel) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][in] */ 
-            __in_ecount(dwCount)  const float *pfVolumes) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][out] */ 
-            __out_ecount(dwCount)  float *pfVolumes) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioStreamVolumeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioStreamVolume * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioStreamVolume * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioStreamVolume * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioStreamVolume * This,
-            /* [out] */ 
-            __out  UINT32 *pdwCount);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
-            IAudioStreamVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [in] */ 
-            __in  const float fLevel);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
-            IAudioStreamVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
-            IAudioStreamVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][in] */ 
-            __in_ecount(dwCount)  const float *pfVolumes);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
-            IAudioStreamVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][out] */ 
-            __out_ecount(dwCount)  float *pfVolumes);
-        
-        END_INTERFACE
-    } IAudioStreamVolumeVtbl;
-
-    interface IAudioStreamVolume
-    {
-        CONST_VTBL struct IAudioStreamVolumeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioStreamVolume_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioStreamVolume_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioStreamVolume_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioStreamVolume_GetChannelCount(This,pdwCount)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 
-
-#define IAudioStreamVolume_SetChannelVolume(This,dwIndex,fLevel)	\
-    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel) ) 
-
-#define IAudioStreamVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
-    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 
-
-#define IAudioStreamVolume_SetAllVolumes(This,dwCount,pfVolumes)	\
-    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes) ) 
-
-#define IAudioStreamVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
-    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioStreamVolume_INTERFACE_DEFINED__ */
-
-
-#ifndef __IChannelAudioVolume_INTERFACE_DEFINED__
-#define __IChannelAudioVolume_INTERFACE_DEFINED__
-
-/* interface IChannelAudioVolume */
-/* [local][unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IChannelAudioVolume;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("1C158861-B533-4B30-B1CF-E853E51C59B8")
-    IChannelAudioVolume : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
-            /* [out] */ 
-            __out  UINT32 *pdwCount) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [in] */ 
-            __in  const float fLevel,
-            /* [unique][in] */ LPCGUID EventContext) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][in] */ 
-            __in_ecount(dwCount)  const float *pfVolumes,
-            /* [unique][in] */ LPCGUID EventContext) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][out] */ 
-            __out_ecount(dwCount)  float *pfVolumes) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IChannelAudioVolumeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IChannelAudioVolume * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IChannelAudioVolume * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IChannelAudioVolume * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IChannelAudioVolume * This,
-            /* [out] */ 
-            __out  UINT32 *pdwCount);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
-            IChannelAudioVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [in] */ 
-            __in  const float fLevel,
-            /* [unique][in] */ LPCGUID EventContext);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
-            IChannelAudioVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwIndex,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
-            IChannelAudioVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][in] */ 
-            __in_ecount(dwCount)  const float *pfVolumes,
-            /* [unique][in] */ LPCGUID EventContext);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
-            IChannelAudioVolume * This,
-            /* [in] */ 
-            __in  UINT32 dwCount,
-            /* [size_is][out] */ 
-            __out_ecount(dwCount)  float *pfVolumes);
-        
-        END_INTERFACE
-    } IChannelAudioVolumeVtbl;
-
-    interface IChannelAudioVolume
-    {
-        CONST_VTBL struct IChannelAudioVolumeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IChannelAudioVolume_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IChannelAudioVolume_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IChannelAudioVolume_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IChannelAudioVolume_GetChannelCount(This,pdwCount)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 
-
-#define IChannelAudioVolume_SetChannelVolume(This,dwIndex,fLevel,EventContext)	\
-    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel,EventContext) ) 
-
-#define IChannelAudioVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
-    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 
-
-#define IChannelAudioVolume_SetAllVolumes(This,dwCount,pfVolumes,EventContext)	\
-    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes,EventContext) ) 
-
-#define IChannelAudioVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
-    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IChannelAudioVolume_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_audioclient_0000_0007 */
-/* [local] */ 
-
-#define FACILITY_AUDCLNT 0x889
-#define AUDCLNT_ERR(n) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUDCLNT, n)
-#define AUDCLNT_SUCCESS(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_AUDCLNT, n)
-#define AUDCLNT_E_NOT_INITIALIZED            AUDCLNT_ERR(0x001)
-#define AUDCLNT_E_ALREADY_INITIALIZED        AUDCLNT_ERR(0x002)
-#define AUDCLNT_E_WRONG_ENDPOINT_TYPE        AUDCLNT_ERR(0x003)
-#define AUDCLNT_E_DEVICE_INVALIDATED         AUDCLNT_ERR(0x004)
-#define AUDCLNT_E_NOT_STOPPED                AUDCLNT_ERR(0x005)
-#define AUDCLNT_E_BUFFER_TOO_LARGE           AUDCLNT_ERR(0x006)
-#define AUDCLNT_E_OUT_OF_ORDER               AUDCLNT_ERR(0x007)
-#define AUDCLNT_E_UNSUPPORTED_FORMAT         AUDCLNT_ERR(0x008)
-#define AUDCLNT_E_INVALID_SIZE               AUDCLNT_ERR(0x009)
-#define AUDCLNT_E_DEVICE_IN_USE              AUDCLNT_ERR(0x00a)
-#define AUDCLNT_E_BUFFER_OPERATION_PENDING   AUDCLNT_ERR(0x00b)
-#define AUDCLNT_E_THREAD_NOT_REGISTERED      AUDCLNT_ERR(0x00c)
-#define AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED AUDCLNT_ERR(0x00e)
-#define AUDCLNT_E_ENDPOINT_CREATE_FAILED     AUDCLNT_ERR(0x00f)
-#define AUDCLNT_E_SERVICE_NOT_RUNNING        AUDCLNT_ERR(0x010)
-#define AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     AUDCLNT_ERR(0x011)
-#define AUDCLNT_E_EXCLUSIVE_MODE_ONLY          AUDCLNT_ERR(0x012)
-#define AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL AUDCLNT_ERR(0x013)
-#define AUDCLNT_E_EVENTHANDLE_NOT_SET          AUDCLNT_ERR(0x014)
-#define AUDCLNT_E_INCORRECT_BUFFER_SIZE        AUDCLNT_ERR(0x015)
-#define AUDCLNT_E_BUFFER_SIZE_ERROR            AUDCLNT_ERR(0x016)
-#define AUDCLNT_E_CPUUSAGE_EXCEEDED            AUDCLNT_ERR(0x017)
-#define AUDCLNT_S_BUFFER_EMPTY              AUDCLNT_SUCCESS(0x001)
-#define AUDCLNT_S_THREAD_ALREADY_REGISTERED AUDCLNT_SUCCESS(0x002)
-#define AUDCLNT_S_POSITION_STALLED		   AUDCLNT_SUCCESS(0x003)
-
-
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_s_ifspec;
-
-/* Additional Prototypes for ALL interfaces */
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for audioclient.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __audioclient_h__
+#define __audioclient_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAudioClient_FWD_DEFINED__
+#define __IAudioClient_FWD_DEFINED__
+typedef interface IAudioClient IAudioClient;
+#endif 	/* __IAudioClient_FWD_DEFINED__ */
+
+
+#ifndef __IAudioRenderClient_FWD_DEFINED__
+#define __IAudioRenderClient_FWD_DEFINED__
+typedef interface IAudioRenderClient IAudioRenderClient;
+#endif 	/* __IAudioRenderClient_FWD_DEFINED__ */
+
+
+#ifndef __IAudioCaptureClient_FWD_DEFINED__
+#define __IAudioCaptureClient_FWD_DEFINED__
+typedef interface IAudioCaptureClient IAudioCaptureClient;
+#endif 	/* __IAudioCaptureClient_FWD_DEFINED__ */
+
+
+#ifndef __IAudioClock_FWD_DEFINED__
+#define __IAudioClock_FWD_DEFINED__
+typedef interface IAudioClock IAudioClock;
+#endif 	/* __IAudioClock_FWD_DEFINED__ */
+
+
+#ifndef __ISimpleAudioVolume_FWD_DEFINED__
+#define __ISimpleAudioVolume_FWD_DEFINED__
+typedef interface ISimpleAudioVolume ISimpleAudioVolume;
+#endif 	/* __ISimpleAudioVolume_FWD_DEFINED__ */
+
+
+#ifndef __IAudioStreamVolume_FWD_DEFINED__
+#define __IAudioStreamVolume_FWD_DEFINED__
+typedef interface IAudioStreamVolume IAudioStreamVolume;
+#endif 	/* __IAudioStreamVolume_FWD_DEFINED__ */
+
+
+#ifndef __IChannelAudioVolume_FWD_DEFINED__
+#define __IChannelAudioVolume_FWD_DEFINED__
+typedef interface IChannelAudioVolume IChannelAudioVolume;
+#endif 	/* __IChannelAudioVolume_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "wtypes.h"
+#include "unknwn.h"
+#include "AudioSessionTypes.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_audioclient_0000_0000 */
+/* [local] */ 
+
+#if 0
+typedef /* [hidden][restricted] */ struct WAVEFORMATEX
+    {
+    WORD wFormatTag;
+    WORD nChannels;
+    DWORD nSamplesPerSec;
+    DWORD nAvgBytesPerSec;
+    WORD nBlockAlign;
+    WORD wBitsPerSample;
+    WORD cbSize;
+    } 	WAVEFORMATEX;
+
+#else
+#include <mmreg.h>
+#endif
+#if 0
+typedef /* [hidden][restricted] */ LONGLONG REFERENCE_TIME;
+
+#else
+#define _IKsControl_
+#include <ks.h>
+#include <ksmedia.h>
+#endif
+
+enum _AUDCLNT_BUFFERFLAGS
+    {	AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY	= 0x1,
+	AUDCLNT_BUFFERFLAGS_SILENT	= 0x2,
+	AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR	= 0x4
+    } ;
+
+
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAudioClient_INTERFACE_DEFINED__
+#define __IAudioClient_INTERFACE_DEFINED__
+
+/* interface IAudioClient */
+/* [local][unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAudioClient;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1CB9AD4C-DBFA-4c32-B178-C2F568A703B2")
+    IAudioClient : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Initialize( 
+            /* [in] */ 
+            __in  AUDCLNT_SHAREMODE ShareMode,
+            /* [in] */ 
+            __in  DWORD StreamFlags,
+            /* [in] */ 
+            __in  REFERENCE_TIME hnsBufferDuration,
+            /* [in] */ 
+            __in  REFERENCE_TIME hnsPeriodicity,
+            /* [in] */ 
+            __in  const WAVEFORMATEX *pFormat,
+            /* [in] */ 
+            __in_opt  LPCGUID AudioSessionGuid) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetBufferSize( 
+            /* [out] */ 
+            __out  UINT32 *pNumBufferFrames) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetStreamLatency( 
+            /* [out] */ 
+            __out  REFERENCE_TIME *phnsLatency) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetCurrentPadding( 
+            /* [out] */ 
+            __out  UINT32 *pNumPaddingFrames) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE IsFormatSupported( 
+            /* [in] */ 
+            __in  AUDCLNT_SHAREMODE ShareMode,
+            /* [in] */ 
+            __in  const WAVEFORMATEX *pFormat,
+            /* [unique][out] */ 
+            __out_opt  WAVEFORMATEX **ppClosestMatch) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMixFormat( 
+            /* [out] */ 
+            __out  WAVEFORMATEX **ppDeviceFormat) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDevicePeriod( 
+            /* [out] */ 
+            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
+            /* [out] */ 
+            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetEventHandle( 
+            /* [in] */ HANDLE eventHandle) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetService( 
+            /* [in] */ 
+            __in  REFIID riid,
+            /* [iid_is][out] */ 
+            __out  void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioClientVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioClient * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioClient * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
+            IAudioClient * This,
+            /* [in] */ 
+            __in  AUDCLNT_SHAREMODE ShareMode,
+            /* [in] */ 
+            __in  DWORD StreamFlags,
+            /* [in] */ 
+            __in  REFERENCE_TIME hnsBufferDuration,
+            /* [in] */ 
+            __in  REFERENCE_TIME hnsPeriodicity,
+            /* [in] */ 
+            __in  const WAVEFORMATEX *pFormat,
+            /* [in] */ 
+            __in_opt  LPCGUID AudioSessionGuid);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBufferSize )( 
+            IAudioClient * This,
+            /* [out] */ 
+            __out  UINT32 *pNumBufferFrames);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetStreamLatency )( 
+            IAudioClient * This,
+            /* [out] */ 
+            __out  REFERENCE_TIME *phnsLatency);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCurrentPadding )( 
+            IAudioClient * This,
+            /* [out] */ 
+            __out  UINT32 *pNumPaddingFrames);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
+            IAudioClient * This,
+            /* [in] */ 
+            __in  AUDCLNT_SHAREMODE ShareMode,
+            /* [in] */ 
+            __in  const WAVEFORMATEX *pFormat,
+            /* [unique][out] */ 
+            __out_opt  WAVEFORMATEX **ppClosestMatch);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMixFormat )( 
+            IAudioClient * This,
+            /* [out] */ 
+            __out  WAVEFORMATEX **ppDeviceFormat);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDevicePeriod )( 
+            IAudioClient * This,
+            /* [out] */ 
+            __out_opt  REFERENCE_TIME *phnsDefaultDevicePeriod,
+            /* [out] */ 
+            __out_opt  REFERENCE_TIME *phnsMinimumDevicePeriod);
+        
+        HRESULT ( STDMETHODCALLTYPE *Start )( 
+            IAudioClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Stop )( 
+            IAudioClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Reset )( 
+            IAudioClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetEventHandle )( 
+            IAudioClient * This,
+            /* [in] */ HANDLE eventHandle);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetService )( 
+            IAudioClient * This,
+            /* [in] */ 
+            __in  REFIID riid,
+            /* [iid_is][out] */ 
+            __out  void **ppv);
+        
+        END_INTERFACE
+    } IAudioClientVtbl;
+
+    interface IAudioClient
+    {
+        CONST_VTBL struct IAudioClientVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioClient_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioClient_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioClient_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioClient_Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid)	\
+    ( (This)->lpVtbl -> Initialize(This,ShareMode,StreamFlags,hnsBufferDuration,hnsPeriodicity,pFormat,AudioSessionGuid) ) 
+
+#define IAudioClient_GetBufferSize(This,pNumBufferFrames)	\
+    ( (This)->lpVtbl -> GetBufferSize(This,pNumBufferFrames) ) 
+
+#define IAudioClient_GetStreamLatency(This,phnsLatency)	\
+    ( (This)->lpVtbl -> GetStreamLatency(This,phnsLatency) ) 
+
+#define IAudioClient_GetCurrentPadding(This,pNumPaddingFrames)	\
+    ( (This)->lpVtbl -> GetCurrentPadding(This,pNumPaddingFrames) ) 
+
+#define IAudioClient_IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch)	\
+    ( (This)->lpVtbl -> IsFormatSupported(This,ShareMode,pFormat,ppClosestMatch) ) 
+
+#define IAudioClient_GetMixFormat(This,ppDeviceFormat)	\
+    ( (This)->lpVtbl -> GetMixFormat(This,ppDeviceFormat) ) 
+
+#define IAudioClient_GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod)	\
+    ( (This)->lpVtbl -> GetDevicePeriod(This,phnsDefaultDevicePeriod,phnsMinimumDevicePeriod) ) 
+
+#define IAudioClient_Start(This)	\
+    ( (This)->lpVtbl -> Start(This) ) 
+
+#define IAudioClient_Stop(This)	\
+    ( (This)->lpVtbl -> Stop(This) ) 
+
+#define IAudioClient_Reset(This)	\
+    ( (This)->lpVtbl -> Reset(This) ) 
+
+#define IAudioClient_SetEventHandle(This,eventHandle)	\
+    ( (This)->lpVtbl -> SetEventHandle(This,eventHandle) ) 
+
+#define IAudioClient_GetService(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetService(This,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioClient_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioRenderClient_INTERFACE_DEFINED__
+#define __IAudioRenderClient_INTERFACE_DEFINED__
+
+/* interface IAudioRenderClient */
+/* [local][unique][helpstring][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAudioRenderClient;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("F294ACFC-3146-4483-A7BF-ADDCA7C260E2")
+    IAudioRenderClient : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
+            /* [in] */ 
+            __in  UINT32 NumFramesRequested,
+            /* [out] */ 
+            __out  BYTE **ppData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
+            /* [in] */ 
+            __in  UINT32 NumFramesWritten,
+            /* [in] */ 
+            __in  DWORD dwFlags) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioRenderClientVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioRenderClient * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioRenderClient * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioRenderClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
+            IAudioRenderClient * This,
+            /* [in] */ 
+            __in  UINT32 NumFramesRequested,
+            /* [out] */ 
+            __out  BYTE **ppData);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
+            IAudioRenderClient * This,
+            /* [in] */ 
+            __in  UINT32 NumFramesWritten,
+            /* [in] */ 
+            __in  DWORD dwFlags);
+        
+        END_INTERFACE
+    } IAudioRenderClientVtbl;
+
+    interface IAudioRenderClient
+    {
+        CONST_VTBL struct IAudioRenderClientVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioRenderClient_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioRenderClient_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioRenderClient_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioRenderClient_GetBuffer(This,NumFramesRequested,ppData)	\
+    ( (This)->lpVtbl -> GetBuffer(This,NumFramesRequested,ppData) ) 
+
+#define IAudioRenderClient_ReleaseBuffer(This,NumFramesWritten,dwFlags)	\
+    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesWritten,dwFlags) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioRenderClient_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioCaptureClient_INTERFACE_DEFINED__
+#define __IAudioCaptureClient_INTERFACE_DEFINED__
+
+/* interface IAudioCaptureClient */
+/* [local][unique][helpstring][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAudioCaptureClient;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("C8ADBD64-E71E-48a0-A4DE-185C395CD317")
+    IAudioCaptureClient : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
+            /* [out] */ 
+            __out  BYTE **ppData,
+            /* [out] */ 
+            __out  UINT32 *pNumFramesToRead,
+            /* [out] */ 
+            __out  DWORD *pdwFlags,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64DevicePosition,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64QPCPosition) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
+            /* [in] */ 
+            __in  UINT32 NumFramesRead) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetNextPacketSize( 
+            /* [out] */ 
+            __out  UINT32 *pNumFramesInNextPacket) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioCaptureClientVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioCaptureClient * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioCaptureClient * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioCaptureClient * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
+            IAudioCaptureClient * This,
+            /* [out] */ 
+            __out  BYTE **ppData,
+            /* [out] */ 
+            __out  UINT32 *pNumFramesToRead,
+            /* [out] */ 
+            __out  DWORD *pdwFlags,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64DevicePosition,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64QPCPosition);
+        
+        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
+            IAudioCaptureClient * This,
+            /* [in] */ 
+            __in  UINT32 NumFramesRead);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetNextPacketSize )( 
+            IAudioCaptureClient * This,
+            /* [out] */ 
+            __out  UINT32 *pNumFramesInNextPacket);
+        
+        END_INTERFACE
+    } IAudioCaptureClientVtbl;
+
+    interface IAudioCaptureClient
+    {
+        CONST_VTBL struct IAudioCaptureClientVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioCaptureClient_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioCaptureClient_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioCaptureClient_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioCaptureClient_GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition)	\
+    ( (This)->lpVtbl -> GetBuffer(This,ppData,pNumFramesToRead,pdwFlags,pu64DevicePosition,pu64QPCPosition) ) 
+
+#define IAudioCaptureClient_ReleaseBuffer(This,NumFramesRead)	\
+    ( (This)->lpVtbl -> ReleaseBuffer(This,NumFramesRead) ) 
+
+#define IAudioCaptureClient_GetNextPacketSize(This,pNumFramesInNextPacket)	\
+    ( (This)->lpVtbl -> GetNextPacketSize(This,pNumFramesInNextPacket) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioCaptureClient_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_audioclient_0000_0003 */
+/* [local] */ 
+
+#define AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ  0x00000001
+
+
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0003_v0_0_s_ifspec;
+
+#ifndef __IAudioClock_INTERFACE_DEFINED__
+#define __IAudioClock_INTERFACE_DEFINED__
+
+/* interface IAudioClock */
+/* [local][unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAudioClock;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("CD63314F-3FBA-4a1b-812C-EF96358728E7")
+    IAudioClock : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
+            /* [out] */ 
+            __out  UINT64 *pu64Frequency) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
+            /* [out] */ 
+            __out  UINT64 *pu64Position,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64QPCPosition) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
+            /* [out] */ 
+            __out  DWORD *pdwCharacteristics) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioClockVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioClock * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioClock * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioClock * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
+            IAudioClock * This,
+            /* [out] */ 
+            __out  UINT64 *pu64Frequency);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
+            IAudioClock * This,
+            /* [out] */ 
+            __out  UINT64 *pu64Position,
+            /* [unique][out] */ 
+            __out_opt  UINT64 *pu64QPCPosition);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
+            IAudioClock * This,
+            /* [out] */ 
+            __out  DWORD *pdwCharacteristics);
+        
+        END_INTERFACE
+    } IAudioClockVtbl;
+
+    interface IAudioClock
+    {
+        CONST_VTBL struct IAudioClockVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioClock_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioClock_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioClock_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioClock_GetFrequency(This,pu64Frequency)	\
+    ( (This)->lpVtbl -> GetFrequency(This,pu64Frequency) ) 
+
+#define IAudioClock_GetPosition(This,pu64Position,pu64QPCPosition)	\
+    ( (This)->lpVtbl -> GetPosition(This,pu64Position,pu64QPCPosition) ) 
+
+#define IAudioClock_GetCharacteristics(This,pdwCharacteristics)	\
+    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioClock_INTERFACE_DEFINED__ */
+
+
+#ifndef __ISimpleAudioVolume_INTERFACE_DEFINED__
+#define __ISimpleAudioVolume_INTERFACE_DEFINED__
+
+/* interface ISimpleAudioVolume */
+/* [local][unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_ISimpleAudioVolume;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("87CE5498-68D6-44E5-9215-6DA47EF883D8")
+    ISimpleAudioVolume : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetMasterVolume( 
+            /* [in] */ 
+            __in  float fLevel,
+            /* [unique][in] */ LPCGUID EventContext) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMasterVolume( 
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetMute( 
+            /* [in] */ 
+            __in  const BOOL bMute,
+            /* [unique][in] */ LPCGUID EventContext) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMute( 
+            /* [out] */ 
+            __out  BOOL *pbMute) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ISimpleAudioVolumeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ISimpleAudioVolume * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ISimpleAudioVolume * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ISimpleAudioVolume * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMasterVolume )( 
+            ISimpleAudioVolume * This,
+            /* [in] */ 
+            __in  float fLevel,
+            /* [unique][in] */ LPCGUID EventContext);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMasterVolume )( 
+            ISimpleAudioVolume * This,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMute )( 
+            ISimpleAudioVolume * This,
+            /* [in] */ 
+            __in  const BOOL bMute,
+            /* [unique][in] */ LPCGUID EventContext);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMute )( 
+            ISimpleAudioVolume * This,
+            /* [out] */ 
+            __out  BOOL *pbMute);
+        
+        END_INTERFACE
+    } ISimpleAudioVolumeVtbl;
+
+    interface ISimpleAudioVolume
+    {
+        CONST_VTBL struct ISimpleAudioVolumeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ISimpleAudioVolume_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ISimpleAudioVolume_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ISimpleAudioVolume_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ISimpleAudioVolume_SetMasterVolume(This,fLevel,EventContext)	\
+    ( (This)->lpVtbl -> SetMasterVolume(This,fLevel,EventContext) ) 
+
+#define ISimpleAudioVolume_GetMasterVolume(This,pfLevel)	\
+    ( (This)->lpVtbl -> GetMasterVolume(This,pfLevel) ) 
+
+#define ISimpleAudioVolume_SetMute(This,bMute,EventContext)	\
+    ( (This)->lpVtbl -> SetMute(This,bMute,EventContext) ) 
+
+#define ISimpleAudioVolume_GetMute(This,pbMute)	\
+    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ISimpleAudioVolume_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioStreamVolume_INTERFACE_DEFINED__
+#define __IAudioStreamVolume_INTERFACE_DEFINED__
+
+/* interface IAudioStreamVolume */
+/* [local][unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IAudioStreamVolume;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("93014887-242D-4068-8A15-CF5E93B90FE3")
+    IAudioStreamVolume : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
+            /* [out] */ 
+            __out  UINT32 *pdwCount) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [in] */ 
+            __in  const float fLevel) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][in] */ 
+            __in_ecount(dwCount)  const float *pfVolumes) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][out] */ 
+            __out_ecount(dwCount)  float *pfVolumes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioStreamVolumeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioStreamVolume * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioStreamVolume * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioStreamVolume * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioStreamVolume * This,
+            /* [out] */ 
+            __out  UINT32 *pdwCount);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
+            IAudioStreamVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [in] */ 
+            __in  const float fLevel);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
+            IAudioStreamVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
+            IAudioStreamVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][in] */ 
+            __in_ecount(dwCount)  const float *pfVolumes);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
+            IAudioStreamVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][out] */ 
+            __out_ecount(dwCount)  float *pfVolumes);
+        
+        END_INTERFACE
+    } IAudioStreamVolumeVtbl;
+
+    interface IAudioStreamVolume
+    {
+        CONST_VTBL struct IAudioStreamVolumeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioStreamVolume_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioStreamVolume_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioStreamVolume_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioStreamVolume_GetChannelCount(This,pdwCount)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 
+
+#define IAudioStreamVolume_SetChannelVolume(This,dwIndex,fLevel)	\
+    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel) ) 
+
+#define IAudioStreamVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
+    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 
+
+#define IAudioStreamVolume_SetAllVolumes(This,dwCount,pfVolumes)	\
+    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes) ) 
+
+#define IAudioStreamVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
+    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioStreamVolume_INTERFACE_DEFINED__ */
+
+
+#ifndef __IChannelAudioVolume_INTERFACE_DEFINED__
+#define __IChannelAudioVolume_INTERFACE_DEFINED__
+
+/* interface IChannelAudioVolume */
+/* [local][unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IChannelAudioVolume;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1C158861-B533-4B30-B1CF-E853E51C59B8")
+    IChannelAudioVolume : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
+            /* [out] */ 
+            __out  UINT32 *pdwCount) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetChannelVolume( 
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [in] */ 
+            __in  const float fLevel,
+            /* [unique][in] */ LPCGUID EventContext) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetChannelVolume( 
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetAllVolumes( 
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][in] */ 
+            __in_ecount(dwCount)  const float *pfVolumes,
+            /* [unique][in] */ LPCGUID EventContext) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAllVolumes( 
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][out] */ 
+            __out_ecount(dwCount)  float *pfVolumes) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IChannelAudioVolumeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IChannelAudioVolume * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IChannelAudioVolume * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IChannelAudioVolume * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IChannelAudioVolume * This,
+            /* [out] */ 
+            __out  UINT32 *pdwCount);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetChannelVolume )( 
+            IChannelAudioVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [in] */ 
+            __in  const float fLevel,
+            /* [unique][in] */ LPCGUID EventContext);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetChannelVolume )( 
+            IChannelAudioVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwIndex,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetAllVolumes )( 
+            IChannelAudioVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][in] */ 
+            __in_ecount(dwCount)  const float *pfVolumes,
+            /* [unique][in] */ LPCGUID EventContext);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAllVolumes )( 
+            IChannelAudioVolume * This,
+            /* [in] */ 
+            __in  UINT32 dwCount,
+            /* [size_is][out] */ 
+            __out_ecount(dwCount)  float *pfVolumes);
+        
+        END_INTERFACE
+    } IChannelAudioVolumeVtbl;
+
+    interface IChannelAudioVolume
+    {
+        CONST_VTBL struct IChannelAudioVolumeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IChannelAudioVolume_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IChannelAudioVolume_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IChannelAudioVolume_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IChannelAudioVolume_GetChannelCount(This,pdwCount)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pdwCount) ) 
+
+#define IChannelAudioVolume_SetChannelVolume(This,dwIndex,fLevel,EventContext)	\
+    ( (This)->lpVtbl -> SetChannelVolume(This,dwIndex,fLevel,EventContext) ) 
+
+#define IChannelAudioVolume_GetChannelVolume(This,dwIndex,pfLevel)	\
+    ( (This)->lpVtbl -> GetChannelVolume(This,dwIndex,pfLevel) ) 
+
+#define IChannelAudioVolume_SetAllVolumes(This,dwCount,pfVolumes,EventContext)	\
+    ( (This)->lpVtbl -> SetAllVolumes(This,dwCount,pfVolumes,EventContext) ) 
+
+#define IChannelAudioVolume_GetAllVolumes(This,dwCount,pfVolumes)	\
+    ( (This)->lpVtbl -> GetAllVolumes(This,dwCount,pfVolumes) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IChannelAudioVolume_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_audioclient_0000_0007 */
+/* [local] */ 
+
+#define FACILITY_AUDCLNT 0x889
+#define AUDCLNT_ERR(n) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUDCLNT, n)
+#define AUDCLNT_SUCCESS(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_AUDCLNT, n)
+#define AUDCLNT_E_NOT_INITIALIZED            AUDCLNT_ERR(0x001)
+#define AUDCLNT_E_ALREADY_INITIALIZED        AUDCLNT_ERR(0x002)
+#define AUDCLNT_E_WRONG_ENDPOINT_TYPE        AUDCLNT_ERR(0x003)
+#define AUDCLNT_E_DEVICE_INVALIDATED         AUDCLNT_ERR(0x004)
+#define AUDCLNT_E_NOT_STOPPED                AUDCLNT_ERR(0x005)
+#define AUDCLNT_E_BUFFER_TOO_LARGE           AUDCLNT_ERR(0x006)
+#define AUDCLNT_E_OUT_OF_ORDER               AUDCLNT_ERR(0x007)
+#define AUDCLNT_E_UNSUPPORTED_FORMAT         AUDCLNT_ERR(0x008)
+#define AUDCLNT_E_INVALID_SIZE               AUDCLNT_ERR(0x009)
+#define AUDCLNT_E_DEVICE_IN_USE              AUDCLNT_ERR(0x00a)
+#define AUDCLNT_E_BUFFER_OPERATION_PENDING   AUDCLNT_ERR(0x00b)
+#define AUDCLNT_E_THREAD_NOT_REGISTERED      AUDCLNT_ERR(0x00c)
+#define AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED AUDCLNT_ERR(0x00e)
+#define AUDCLNT_E_ENDPOINT_CREATE_FAILED     AUDCLNT_ERR(0x00f)
+#define AUDCLNT_E_SERVICE_NOT_RUNNING        AUDCLNT_ERR(0x010)
+#define AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     AUDCLNT_ERR(0x011)
+#define AUDCLNT_E_EXCLUSIVE_MODE_ONLY          AUDCLNT_ERR(0x012)
+#define AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL AUDCLNT_ERR(0x013)
+#define AUDCLNT_E_EVENTHANDLE_NOT_SET          AUDCLNT_ERR(0x014)
+#define AUDCLNT_E_INCORRECT_BUFFER_SIZE        AUDCLNT_ERR(0x015)
+#define AUDCLNT_E_BUFFER_SIZE_ERROR            AUDCLNT_ERR(0x016)
+#define AUDCLNT_E_CPUUSAGE_EXCEEDED            AUDCLNT_ERR(0x017)
+#define AUDCLNT_S_BUFFER_EMPTY              AUDCLNT_SUCCESS(0x001)
+#define AUDCLNT_S_THREAD_ALREADY_REGISTERED AUDCLNT_SUCCESS(0x002)
+#define AUDCLNT_S_POSITION_STALLED		   AUDCLNT_SUCCESS(0x003)
+
+
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_audioclient_0000_0007_v0_0_s_ifspec;
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/mingw-include/devicetopology.h
+++ b/src/hostapi/wasapi/mingw-include/devicetopology.h
@@ -1,3275 +1,3275 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for devicetopology.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 500
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __devicetopology_h__
-#define __devicetopology_h__
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IKsControl_FWD_DEFINED__
-#define __IKsControl_FWD_DEFINED__
-typedef interface IKsControl IKsControl;
-#endif 	/* __IKsControl_FWD_DEFINED__ */
-
-
-#ifndef __IPerChannelDbLevel_FWD_DEFINED__
-#define __IPerChannelDbLevel_FWD_DEFINED__
-typedef interface IPerChannelDbLevel IPerChannelDbLevel;
-#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */
-
-
-#ifndef __IAudioVolumeLevel_FWD_DEFINED__
-#define __IAudioVolumeLevel_FWD_DEFINED__
-typedef interface IAudioVolumeLevel IAudioVolumeLevel;
-#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */
-
-
-#ifndef __IAudioChannelConfig_FWD_DEFINED__
-#define __IAudioChannelConfig_FWD_DEFINED__
-typedef interface IAudioChannelConfig IAudioChannelConfig;
-#endif 	/* __IAudioChannelConfig_FWD_DEFINED__ */
-
-
-#ifndef __IAudioLoudness_FWD_DEFINED__
-#define __IAudioLoudness_FWD_DEFINED__
-typedef interface IAudioLoudness IAudioLoudness;
-#endif 	/* __IAudioLoudness_FWD_DEFINED__ */
-
-
-#ifndef __IAudioInputSelector_FWD_DEFINED__
-#define __IAudioInputSelector_FWD_DEFINED__
-typedef interface IAudioInputSelector IAudioInputSelector;
-#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */
-
-
-#ifndef __IAudioOutputSelector_FWD_DEFINED__
-#define __IAudioOutputSelector_FWD_DEFINED__
-typedef interface IAudioOutputSelector IAudioOutputSelector;
-#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */
-
-
-#ifndef __IAudioMute_FWD_DEFINED__
-#define __IAudioMute_FWD_DEFINED__
-typedef interface IAudioMute IAudioMute;
-#endif 	/* __IAudioMute_FWD_DEFINED__ */
-
-
-#ifndef __IAudioBass_FWD_DEFINED__
-#define __IAudioBass_FWD_DEFINED__
-typedef interface IAudioBass IAudioBass;
-#endif 	/* __IAudioBass_FWD_DEFINED__ */
-
-
-#ifndef __IAudioMidrange_FWD_DEFINED__
-#define __IAudioMidrange_FWD_DEFINED__
-typedef interface IAudioMidrange IAudioMidrange;
-#endif 	/* __IAudioMidrange_FWD_DEFINED__ */
-
-
-#ifndef __IAudioTreble_FWD_DEFINED__
-#define __IAudioTreble_FWD_DEFINED__
-typedef interface IAudioTreble IAudioTreble;
-#endif 	/* __IAudioTreble_FWD_DEFINED__ */
-
-
-#ifndef __IAudioAutoGainControl_FWD_DEFINED__
-#define __IAudioAutoGainControl_FWD_DEFINED__
-typedef interface IAudioAutoGainControl IAudioAutoGainControl;
-#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */
-
-
-#ifndef __IAudioPeakMeter_FWD_DEFINED__
-#define __IAudioPeakMeter_FWD_DEFINED__
-typedef interface IAudioPeakMeter IAudioPeakMeter;
-#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */
-
-
-#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
-#define __IDeviceSpecificProperty_FWD_DEFINED__
-typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
-#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */
-
-
-#ifndef __IKsFormatSupport_FWD_DEFINED__
-#define __IKsFormatSupport_FWD_DEFINED__
-typedef interface IKsFormatSupport IKsFormatSupport;
-#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */
-
-
-#ifndef __IKsJackDescription_FWD_DEFINED__
-#define __IKsJackDescription_FWD_DEFINED__
-typedef interface IKsJackDescription IKsJackDescription;
-#endif 	/* __IKsJackDescription_FWD_DEFINED__ */
-
-
-#ifndef __IPartsList_FWD_DEFINED__
-#define __IPartsList_FWD_DEFINED__
-typedef interface IPartsList IPartsList;
-#endif 	/* __IPartsList_FWD_DEFINED__ */
-
-
-#ifndef __IPart_FWD_DEFINED__
-#define __IPart_FWD_DEFINED__
-typedef interface IPart IPart;
-#endif 	/* __IPart_FWD_DEFINED__ */
-
-
-#ifndef __IConnector_FWD_DEFINED__
-#define __IConnector_FWD_DEFINED__
-typedef interface IConnector IConnector;
-#endif 	/* __IConnector_FWD_DEFINED__ */
-
-
-#ifndef __ISubunit_FWD_DEFINED__
-#define __ISubunit_FWD_DEFINED__
-typedef interface ISubunit ISubunit;
-#endif 	/* __ISubunit_FWD_DEFINED__ */
-
-
-#ifndef __IControlInterface_FWD_DEFINED__
-#define __IControlInterface_FWD_DEFINED__
-typedef interface IControlInterface IControlInterface;
-#endif 	/* __IControlInterface_FWD_DEFINED__ */
-
-
-#ifndef __IControlChangeNotify_FWD_DEFINED__
-#define __IControlChangeNotify_FWD_DEFINED__
-typedef interface IControlChangeNotify IControlChangeNotify;
-#endif 	/* __IControlChangeNotify_FWD_DEFINED__ */
-
-
-#ifndef __IDeviceTopology_FWD_DEFINED__
-#define __IDeviceTopology_FWD_DEFINED__
-typedef interface IDeviceTopology IDeviceTopology;
-#endif 	/* __IDeviceTopology_FWD_DEFINED__ */
-
-
-#ifndef __DeviceTopology_FWD_DEFINED__
-#define __DeviceTopology_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class DeviceTopology DeviceTopology;
-#else
-typedef struct DeviceTopology DeviceTopology;
-#endif /* __cplusplus */
-
-#endif 	/* __DeviceTopology_FWD_DEFINED__ */
-
-
-#ifndef __IPartsList_FWD_DEFINED__
-#define __IPartsList_FWD_DEFINED__
-typedef interface IPartsList IPartsList;
-#endif 	/* __IPartsList_FWD_DEFINED__ */
-
-
-#ifndef __IPerChannelDbLevel_FWD_DEFINED__
-#define __IPerChannelDbLevel_FWD_DEFINED__
-typedef interface IPerChannelDbLevel IPerChannelDbLevel;
-#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */
-
-
-#ifndef __IAudioVolumeLevel_FWD_DEFINED__
-#define __IAudioVolumeLevel_FWD_DEFINED__
-typedef interface IAudioVolumeLevel IAudioVolumeLevel;
-#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */
-
-
-#ifndef __IAudioLoudness_FWD_DEFINED__
-#define __IAudioLoudness_FWD_DEFINED__
-typedef interface IAudioLoudness IAudioLoudness;
-#endif 	/* __IAudioLoudness_FWD_DEFINED__ */
-
-
-#ifndef __IAudioInputSelector_FWD_DEFINED__
-#define __IAudioInputSelector_FWD_DEFINED__
-typedef interface IAudioInputSelector IAudioInputSelector;
-#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */
-
-
-#ifndef __IAudioMute_FWD_DEFINED__
-#define __IAudioMute_FWD_DEFINED__
-typedef interface IAudioMute IAudioMute;
-#endif 	/* __IAudioMute_FWD_DEFINED__ */
-
-
-#ifndef __IAudioBass_FWD_DEFINED__
-#define __IAudioBass_FWD_DEFINED__
-typedef interface IAudioBass IAudioBass;
-#endif 	/* __IAudioBass_FWD_DEFINED__ */
-
-
-#ifndef __IAudioMidrange_FWD_DEFINED__
-#define __IAudioMidrange_FWD_DEFINED__
-typedef interface IAudioMidrange IAudioMidrange;
-#endif 	/* __IAudioMidrange_FWD_DEFINED__ */
-
-
-#ifndef __IAudioTreble_FWD_DEFINED__
-#define __IAudioTreble_FWD_DEFINED__
-typedef interface IAudioTreble IAudioTreble;
-#endif 	/* __IAudioTreble_FWD_DEFINED__ */
-
-
-#ifndef __IAudioAutoGainControl_FWD_DEFINED__
-#define __IAudioAutoGainControl_FWD_DEFINED__
-typedef interface IAudioAutoGainControl IAudioAutoGainControl;
-#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */
-
-
-#ifndef __IAudioOutputSelector_FWD_DEFINED__
-#define __IAudioOutputSelector_FWD_DEFINED__
-typedef interface IAudioOutputSelector IAudioOutputSelector;
-#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */
-
-
-#ifndef __IAudioPeakMeter_FWD_DEFINED__
-#define __IAudioPeakMeter_FWD_DEFINED__
-typedef interface IAudioPeakMeter IAudioPeakMeter;
-#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */
-
-
-#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
-#define __IDeviceSpecificProperty_FWD_DEFINED__
-typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
-#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */
-
-
-#ifndef __IKsFormatSupport_FWD_DEFINED__
-#define __IKsFormatSupport_FWD_DEFINED__
-typedef interface IKsFormatSupport IKsFormatSupport;
-#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "oaidl.h"
-#include "ocidl.h"
-#include "propidl.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_devicetopology_0000_0000 */
-/* [local] */ 
-
-#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
-//
-//   Flag for clients of IControlChangeNotify::OnNotify to allow those clients to identify hardware initiated notifications
-//
-#define DEVTOPO_HARDWARE_INITIATED_EVENTCONTEXT 'draH'
-/* E2C2E9DE-09B1-4B04-84E5-07931225EE04 */
-DEFINE_GUID(EVENTCONTEXT_VOLUMESLIDER, 0xE2C2E9DE,0x09B1,0x4B04,0x84, 0xE5, 0x07, 0x93, 0x12, 0x25, 0xEE, 0x04);
-#define _IKsControl_
-#include "ks.h"
-#include "ksmedia.h"
-#ifndef _KS_
-typedef /* [public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001
-    {
-    ULONG FormatSize;
-    ULONG Flags;
-    ULONG SampleSize;
-    ULONG Reserved;
-    GUID MajorFormat;
-    GUID SubFormat;
-    GUID Specifier;
-    } 	KSDATAFORMAT;
-
-typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001 *PKSDATAFORMAT;
-
-typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002
-    {
-    union 
-        {
-        struct 
-            {
-            GUID Set;
-            ULONG Id;
-            ULONG Flags;
-            } 	;
-        LONGLONG Alignment;
-        } 	;
-    } 	KSIDENTIFIER;
-
-typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002 *PKSIDENTIFIER;
-
-typedef /* [public][public][public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0005
-    {	ePcxChanMap_FL_FR	= 0,
-	ePcxChanMap_FC_LFE	= ( ePcxChanMap_FL_FR + 1 ) ,
-	ePcxChanMap_BL_BR	= ( ePcxChanMap_FC_LFE + 1 ) ,
-	ePcxChanMap_FLC_FRC	= ( ePcxChanMap_BL_BR + 1 ) ,
-	ePcxChanMap_SL_SR	= ( ePcxChanMap_FLC_FRC + 1 ) ,
-	ePcxChanMap_Unknown	= ( ePcxChanMap_SL_SR + 1 ) 
-    } 	EChannelMapping;
-
-typedef /* [public][public][public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0006
-    {	eConnTypeUnknown	= 0,
-	eConnTypeEighth	= ( eConnTypeUnknown + 1 ) ,
-	eConnTypeQuarter	= ( eConnTypeEighth + 1 ) ,
-	eConnTypeAtapiInternal	= ( eConnTypeQuarter + 1 ) ,
-	eConnTypeRCA	= ( eConnTypeAtapiInternal + 1 ) ,
-	eConnTypeOptical	= ( eConnTypeRCA + 1 ) ,
-	eConnTypeOtherDigital	= ( eConnTypeOptical + 1 ) ,
-	eConnTypeOtherAnalog	= ( eConnTypeOtherDigital + 1 ) ,
-	eConnTypeMultichannelAnalogDIN	= ( eConnTypeOtherAnalog + 1 ) ,
-	eConnTypeXlrProfessional	= ( eConnTypeMultichannelAnalogDIN + 1 ) ,
-	eConnTypeRJ11Modem	= ( eConnTypeXlrProfessional + 1 ) ,
-	eConnTypeCombination	= ( eConnTypeRJ11Modem + 1 ) 
-    } 	EPcxConnectionType;
-
-typedef /* [public][public][public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0007
-    {	eGeoLocRear	= 0x1,
-	eGeoLocFront	= ( eGeoLocRear + 1 ) ,
-	eGeoLocLeft	= ( eGeoLocFront + 1 ) ,
-	eGeoLocRight	= ( eGeoLocLeft + 1 ) ,
-	eGeoLocTop	= ( eGeoLocRight + 1 ) ,
-	eGeoLocBottom	= ( eGeoLocTop + 1 ) ,
-	eGeoLocRearOPanel	= ( eGeoLocBottom + 1 ) ,
-	eGeoLocRiser	= ( eGeoLocRearOPanel + 1 ) ,
-	eGeoLocInsideMobileLid	= ( eGeoLocRiser + 1 ) ,
-	eGeoLocDrivebay	= ( eGeoLocInsideMobileLid + 1 ) ,
-	eGeoLocHDMI	= ( eGeoLocDrivebay + 1 ) ,
-	eGeoLocOutsideMobileLid	= ( eGeoLocHDMI + 1 ) ,
-	eGeoLocATAPI	= ( eGeoLocOutsideMobileLid + 1 ) ,
-	eGeoLocReserved5	= ( eGeoLocATAPI + 1 ) ,
-	eGeoLocReserved6	= ( eGeoLocReserved5 + 1 ) 
-    } 	EPcxGeoLocation;
-
-typedef /* [public][public][public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0008
-    {	eGenLocPrimaryBox	= 0,
-	eGenLocInternal	= ( eGenLocPrimaryBox + 1 ) ,
-	eGenLocSeperate	= ( eGenLocInternal + 1 ) ,
-	eGenLocOther	= ( eGenLocSeperate + 1 ) 
-    } 	EPcxGenLocation;
-
-typedef /* [public][public][public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0009
-    {	ePortConnJack	= 0,
-	ePortConnIntegratedDevice	= ( ePortConnJack + 1 ) ,
-	ePortConnBothIntegratedAndJack	= ( ePortConnIntegratedDevice + 1 ) ,
-	ePortConnUnknown	= ( ePortConnBothIntegratedAndJack + 1 ) 
-    } 	EPxcPortConnection;
-
-typedef /* [public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010
-    {
-    EChannelMapping ChannelMapping;
-    COLORREF Color;
-    EPcxConnectionType ConnectionType;
-    EPcxGeoLocation GeoLocation;
-    EPcxGenLocation GenLocation;
-    EPxcPortConnection PortConnection;
-    BOOL IsConnected;
-    } 	KSJACK_DESCRIPTION;
-
-typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010 *PKSJACK_DESCRIPTION;
-
-typedef KSIDENTIFIER KSPROPERTY;
-
-typedef KSIDENTIFIER *PKSPROPERTY;
-
-typedef KSIDENTIFIER KSMETHOD;
-
-typedef KSIDENTIFIER *PKSMETHOD;
-
-typedef KSIDENTIFIER KSEVENT;
-
-typedef KSIDENTIFIER *PKSEVENT;
-
-#endif
-
-
-
-
-
-
-
-
-typedef /* [public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0011
-    {	In	= 0,
-	Out	= ( In + 1 ) 
-    } 	DataFlow;
-
-typedef /* [public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0012
-    {	Connector	= 0,
-	Subunit	= ( Connector + 1 ) 
-    } 	PartType;
-
-#define PARTTYPE_FLAG_CONNECTOR 0x00010000
-#define PARTTYPE_FLAG_SUBUNIT   0x00020000
-#define PARTTYPE_MASK           0x00030000
-#define PARTID_MASK             0x0000ffff
-typedef /* [public][public] */ 
-enum __MIDL___MIDL_itf_devicetopology_0000_0000_0013
-    {	Unknown_Connector	= 0,
-	Physical_Internal	= ( Unknown_Connector + 1 ) ,
-	Physical_External	= ( Physical_Internal + 1 ) ,
-	Software_IO	= ( Physical_External + 1 ) ,
-	Software_Fixed	= ( Software_IO + 1 ) ,
-	Network	= ( Software_Fixed + 1 ) 
-    } 	ConnectorType;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IKsControl_INTERFACE_DEFINED__
-#define __IKsControl_INTERFACE_DEFINED__
-
-/* interface IKsControl */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IKsControl;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("28F54685-06FD-11D2-B27A-00A0C9223196")
-    IKsControl : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE KsProperty( 
-            /* [in] */ PKSPROPERTY Property,
-            /* [in] */ ULONG PropertyLength,
-            /* [out][in] */ void *PropertyData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE KsMethod( 
-            /* [in] */ PKSMETHOD Method,
-            /* [in] */ ULONG MethodLength,
-            /* [out][in] */ void *MethodData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE KsEvent( 
-            /* [in] */ PKSEVENT Event,
-            /* [in] */ ULONG EventLength,
-            /* [out][in] */ void *EventData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IKsControlVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IKsControl * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IKsControl * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IKsControl * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *KsProperty )( 
-            IKsControl * This,
-            /* [in] */ PKSPROPERTY Property,
-            /* [in] */ ULONG PropertyLength,
-            /* [out][in] */ void *PropertyData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned);
-        
-        HRESULT ( STDMETHODCALLTYPE *KsMethod )( 
-            IKsControl * This,
-            /* [in] */ PKSMETHOD Method,
-            /* [in] */ ULONG MethodLength,
-            /* [out][in] */ void *MethodData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned);
-        
-        HRESULT ( STDMETHODCALLTYPE *KsEvent )( 
-            IKsControl * This,
-            /* [in] */ PKSEVENT Event,
-            /* [in] */ ULONG EventLength,
-            /* [out][in] */ void *EventData,
-            /* [in] */ ULONG DataLength,
-            /* [out] */ ULONG *BytesReturned);
-        
-        END_INTERFACE
-    } IKsControlVtbl;
-
-    interface IKsControl
-    {
-        CONST_VTBL struct IKsControlVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IKsControl_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IKsControl_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IKsControl_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IKsControl_KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned)	\
-    ( (This)->lpVtbl -> KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned) ) 
-
-#define IKsControl_KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned)	\
-    ( (This)->lpVtbl -> KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned) ) 
-
-#define IKsControl_KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned)	\
-    ( (This)->lpVtbl -> KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IKsControl_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPerChannelDbLevel_INTERFACE_DEFINED__
-#define __IPerChannelDbLevel_INTERFACE_DEFINED__
-
-/* interface IPerChannelDbLevel */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IPerChannelDbLevel;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("C2F8E001-F205-4BC9-99BC-C13B1E048CCB")
-    IPerChannelDbLevel : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
-            /* [out] */ 
-            __out  UINT *pcChannels) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevelRange( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevel( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelUniform( 
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelAllChannels( 
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPerChannelDbLevelVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPerChannelDbLevel * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPerChannelDbLevel * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPerChannelDbLevel * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IPerChannelDbLevel * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
-            IPerChannelDbLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IPerChannelDbLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
-            IPerChannelDbLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
-            IPerChannelDbLevel * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
-            IPerChannelDbLevel * This,
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IPerChannelDbLevelVtbl;
-
-    interface IPerChannelDbLevel
-    {
-        CONST_VTBL struct IPerChannelDbLevelVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPerChannelDbLevel_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPerChannelDbLevel_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPerChannelDbLevel_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPerChannelDbLevel_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IPerChannelDbLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
-    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
-
-#define IPerChannelDbLevel_GetLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
-
-#define IPerChannelDbLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IPerChannelDbLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
-
-#define IPerChannelDbLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPerChannelDbLevel_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioVolumeLevel_INTERFACE_DEFINED__
-#define __IAudioVolumeLevel_INTERFACE_DEFINED__
-
-/* interface IAudioVolumeLevel */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioVolumeLevel;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("7FB7B48F-531D-44A2-BCB3-5AD5A134B3DC")
-    IAudioVolumeLevel : public IPerChannelDbLevel
-    {
-    public:
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioVolumeLevelVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioVolumeLevel * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioVolumeLevel * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioVolumeLevel * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioVolumeLevel * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
-            IAudioVolumeLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IAudioVolumeLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
-            IAudioVolumeLevel * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
-            IAudioVolumeLevel * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
-            IAudioVolumeLevel * This,
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioVolumeLevelVtbl;
-
-    interface IAudioVolumeLevel
-    {
-        CONST_VTBL struct IAudioVolumeLevelVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioVolumeLevel_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioVolumeLevel_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioVolumeLevel_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioVolumeLevel_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IAudioVolumeLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
-    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
-
-#define IAudioVolumeLevel_GetLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
-
-#define IAudioVolumeLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IAudioVolumeLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
-
-#define IAudioVolumeLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
-
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioVolumeLevel_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioChannelConfig_INTERFACE_DEFINED__
-#define __IAudioChannelConfig_INTERFACE_DEFINED__
-
-/* interface IAudioChannelConfig */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioChannelConfig;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("BB11C46F-EC28-493C-B88A-5DB88062CE98")
-    IAudioChannelConfig : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetChannelConfig( 
-            /* [in] */ DWORD dwConfig,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelConfig( 
-            /* [retval][out] */ DWORD *pdwConfig) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioChannelConfigVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioChannelConfig * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioChannelConfig * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioChannelConfig * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetChannelConfig )( 
-            IAudioChannelConfig * This,
-            /* [in] */ DWORD dwConfig,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelConfig )( 
-            IAudioChannelConfig * This,
-            /* [retval][out] */ DWORD *pdwConfig);
-        
-        END_INTERFACE
-    } IAudioChannelConfigVtbl;
-
-    interface IAudioChannelConfig
-    {
-        CONST_VTBL struct IAudioChannelConfigVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioChannelConfig_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioChannelConfig_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioChannelConfig_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioChannelConfig_SetChannelConfig(This,dwConfig,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetChannelConfig(This,dwConfig,pguidEventContext) ) 
-
-#define IAudioChannelConfig_GetChannelConfig(This,pdwConfig)	\
-    ( (This)->lpVtbl -> GetChannelConfig(This,pdwConfig) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioChannelConfig_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioLoudness_INTERFACE_DEFINED__
-#define __IAudioLoudness_INTERFACE_DEFINED__
-
-/* interface IAudioLoudness */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioLoudness;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("7D8B1437-DD53-4350-9C1B-1EE2890BD938")
-    IAudioLoudness : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
-            /* [out] */ 
-            __out  BOOL *pbEnabled) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
-            /* [in] */ 
-            __in  BOOL bEnable,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioLoudnessVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioLoudness * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioLoudness * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioLoudness * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
-            IAudioLoudness * This,
-            /* [out] */ 
-            __out  BOOL *pbEnabled);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
-            IAudioLoudness * This,
-            /* [in] */ 
-            __in  BOOL bEnable,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioLoudnessVtbl;
-
-    interface IAudioLoudness
-    {
-        CONST_VTBL struct IAudioLoudnessVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioLoudness_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioLoudness_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioLoudness_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioLoudness_GetEnabled(This,pbEnabled)	\
-    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 
-
-#define IAudioLoudness_SetEnabled(This,bEnable,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioLoudness_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioInputSelector_INTERFACE_DEFINED__
-#define __IAudioInputSelector_INTERFACE_DEFINED__
-
-/* interface IAudioInputSelector */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioInputSelector;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("4F03DC02-5E6E-4653-8F72-A030C123D598")
-    IAudioInputSelector : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
-            /* [out] */ 
-            __out  UINT *pnIdSelected) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
-            /* [in] */ 
-            __in  UINT nIdSelect,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioInputSelectorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioInputSelector * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioInputSelector * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioInputSelector * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
-            IAudioInputSelector * This,
-            /* [out] */ 
-            __out  UINT *pnIdSelected);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
-            IAudioInputSelector * This,
-            /* [in] */ 
-            __in  UINT nIdSelect,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioInputSelectorVtbl;
-
-    interface IAudioInputSelector
-    {
-        CONST_VTBL struct IAudioInputSelectorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioInputSelector_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioInputSelector_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioInputSelector_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioInputSelector_GetSelection(This,pnIdSelected)	\
-    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 
-
-#define IAudioInputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioInputSelector_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioOutputSelector_INTERFACE_DEFINED__
-#define __IAudioOutputSelector_INTERFACE_DEFINED__
-
-/* interface IAudioOutputSelector */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioOutputSelector;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("BB515F69-94A7-429e-8B9C-271B3F11A3AB")
-    IAudioOutputSelector : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
-            /* [out] */ 
-            __out  UINT *pnIdSelected) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
-            /* [in] */ 
-            __in  UINT nIdSelect,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioOutputSelectorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioOutputSelector * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioOutputSelector * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioOutputSelector * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
-            IAudioOutputSelector * This,
-            /* [out] */ 
-            __out  UINT *pnIdSelected);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
-            IAudioOutputSelector * This,
-            /* [in] */ 
-            __in  UINT nIdSelect,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioOutputSelectorVtbl;
-
-    interface IAudioOutputSelector
-    {
-        CONST_VTBL struct IAudioOutputSelectorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioOutputSelector_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioOutputSelector_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioOutputSelector_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioOutputSelector_GetSelection(This,pnIdSelected)	\
-    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 
-
-#define IAudioOutputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioOutputSelector_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioMute_INTERFACE_DEFINED__
-#define __IAudioMute_INTERFACE_DEFINED__
-
-/* interface IAudioMute */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioMute;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("DF45AEEA-B74A-4B6B-AFAD-2366B6AA012E")
-    IAudioMute : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMute( 
-            /* [in] */ 
-            __in  BOOL bMuted,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMute( 
-            /* [out] */ 
-            __out  BOOL *pbMuted) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioMuteVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioMute * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioMute * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioMute * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
-            IAudioMute * This,
-            /* [in] */ 
-            __in  BOOL bMuted,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
-            IAudioMute * This,
-            /* [out] */ 
-            __out  BOOL *pbMuted);
-        
-        END_INTERFACE
-    } IAudioMuteVtbl;
-
-    interface IAudioMute
-    {
-        CONST_VTBL struct IAudioMuteVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioMute_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioMute_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioMute_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioMute_SetMute(This,bMuted,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetMute(This,bMuted,pguidEventContext) ) 
-
-#define IAudioMute_GetMute(This,pbMuted)	\
-    ( (This)->lpVtbl -> GetMute(This,pbMuted) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioMute_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioBass_INTERFACE_DEFINED__
-#define __IAudioBass_INTERFACE_DEFINED__
-
-/* interface IAudioBass */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioBass;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("A2B1A1D9-4DB3-425D-A2B2-BD335CB3E2E5")
-    IAudioBass : public IPerChannelDbLevel
-    {
-    public:
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioBassVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioBass * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioBass * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioBass * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioBass * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
-            IAudioBass * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IAudioBass * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
-            IAudioBass * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
-            IAudioBass * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
-            IAudioBass * This,
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioBassVtbl;
-
-    interface IAudioBass
-    {
-        CONST_VTBL struct IAudioBassVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioBass_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioBass_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioBass_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioBass_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IAudioBass_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
-    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
-
-#define IAudioBass_GetLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
-
-#define IAudioBass_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IAudioBass_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
-
-#define IAudioBass_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
-
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioBass_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioMidrange_INTERFACE_DEFINED__
-#define __IAudioMidrange_INTERFACE_DEFINED__
-
-/* interface IAudioMidrange */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioMidrange;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("5E54B6D7-B44B-40D9-9A9E-E691D9CE6EDF")
-    IAudioMidrange : public IPerChannelDbLevel
-    {
-    public:
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioMidrangeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioMidrange * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioMidrange * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioMidrange * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioMidrange * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
-            IAudioMidrange * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IAudioMidrange * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
-            IAudioMidrange * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
-            IAudioMidrange * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
-            IAudioMidrange * This,
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioMidrangeVtbl;
-
-    interface IAudioMidrange
-    {
-        CONST_VTBL struct IAudioMidrangeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioMidrange_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioMidrange_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioMidrange_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioMidrange_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IAudioMidrange_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
-    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
-
-#define IAudioMidrange_GetLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
-
-#define IAudioMidrange_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IAudioMidrange_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
-
-#define IAudioMidrange_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
-
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioMidrange_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioTreble_INTERFACE_DEFINED__
-#define __IAudioTreble_INTERFACE_DEFINED__
-
-/* interface IAudioTreble */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioTreble;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("0A717812-694E-4907-B74B-BAFA5CFDCA7B")
-    IAudioTreble : public IPerChannelDbLevel
-    {
-    public:
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioTrebleVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioTreble * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioTreble * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioTreble * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioTreble * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
-            IAudioTreble * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfMinLevelDB,
-            /* [out] */ 
-            __out  float *pfMaxLevelDB,
-            /* [out] */ 
-            __out  float *pfStepping);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IAudioTreble * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
-            IAudioTreble * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
-            IAudioTreble * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
-            IAudioTreble * This,
-            /* [size_is][in] */ 
-            __in_ecount(cChannels)  float aLevelsDB[  ],
-            /* [in] */ 
-            __in  ULONG cChannels,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioTrebleVtbl;
-
-    interface IAudioTreble
-    {
-        CONST_VTBL struct IAudioTrebleVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioTreble_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioTreble_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioTreble_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioTreble_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IAudioTreble_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
-    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
-
-#define IAudioTreble_GetLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
-
-#define IAudioTreble_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IAudioTreble_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
-
-#define IAudioTreble_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
-
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioTreble_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioAutoGainControl_INTERFACE_DEFINED__
-#define __IAudioAutoGainControl_INTERFACE_DEFINED__
-
-/* interface IAudioAutoGainControl */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioAutoGainControl;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("85401FD4-6DE4-4b9d-9869-2D6753A82F3C")
-    IAudioAutoGainControl : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
-            /* [out] */ 
-            __out  BOOL *pbEnabled) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
-            /* [in] */ 
-            __in  BOOL bEnable,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioAutoGainControlVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioAutoGainControl * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioAutoGainControl * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioAutoGainControl * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
-            IAudioAutoGainControl * This,
-            /* [out] */ 
-            __out  BOOL *pbEnabled);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
-            IAudioAutoGainControl * This,
-            /* [in] */ 
-            __in  BOOL bEnable,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IAudioAutoGainControlVtbl;
-
-    interface IAudioAutoGainControl
-    {
-        CONST_VTBL struct IAudioAutoGainControlVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioAutoGainControl_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioAutoGainControl_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioAutoGainControl_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioAutoGainControl_GetEnabled(This,pbEnabled)	\
-    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 
-
-#define IAudioAutoGainControl_SetEnabled(This,bEnable,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioAutoGainControl_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioPeakMeter_INTERFACE_DEFINED__
-#define __IAudioPeakMeter_INTERFACE_DEFINED__
-
-/* interface IAudioPeakMeter */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioPeakMeter;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("DD79923C-0599-45e0-B8B6-C8DF7DB6E796")
-    IAudioPeakMeter : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
-            /* [out] */ 
-            __out  UINT *pcChannels) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioPeakMeterVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioPeakMeter * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioPeakMeter * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioPeakMeter * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioPeakMeter * This,
-            /* [out] */ 
-            __out  UINT *pcChannels);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
-            IAudioPeakMeter * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        END_INTERFACE
-    } IAudioPeakMeterVtbl;
-
-    interface IAudioPeakMeter
-    {
-        CONST_VTBL struct IAudioPeakMeterVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioPeakMeter_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioPeakMeter_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioPeakMeter_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioPeakMeter_GetChannelCount(This,pcChannels)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
-
-#define IAudioPeakMeter_GetLevel(This,nChannel,pfLevel)	\
-    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevel) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioPeakMeter_INTERFACE_DEFINED__ */
-
-
-#ifndef __IDeviceSpecificProperty_INTERFACE_DEFINED__
-#define __IDeviceSpecificProperty_INTERFACE_DEFINED__
-
-/* interface IDeviceSpecificProperty */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IDeviceSpecificProperty;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("3B22BCBF-2586-4af0-8583-205D391B807C")
-    IDeviceSpecificProperty : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
-            /* [out] */ 
-            __deref_out  VARTYPE *pVType) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetValue( 
-            /* [out] */ 
-            __out  void *pvValue,
-            /* [out][in] */ 
-            __inout  DWORD *pcbValue) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetValue( 
-            /* [in] */ 
-            __in  void *pvValue,
-            /* [in] */ DWORD cbValue,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get4BRange( 
-            /* [out] */ 
-            __deref_out  LONG *plMin,
-            /* [out] */ 
-            __deref_out  LONG *plMax,
-            /* [out] */ 
-            __deref_out  LONG *plStepping) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IDeviceSpecificPropertyVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IDeviceSpecificProperty * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IDeviceSpecificProperty * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IDeviceSpecificProperty * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
-            IDeviceSpecificProperty * This,
-            /* [out] */ 
-            __deref_out  VARTYPE *pVType);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
-            IDeviceSpecificProperty * This,
-            /* [out] */ 
-            __out  void *pvValue,
-            /* [out][in] */ 
-            __inout  DWORD *pcbValue);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetValue )( 
-            IDeviceSpecificProperty * This,
-            /* [in] */ 
-            __in  void *pvValue,
-            /* [in] */ DWORD cbValue,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get4BRange )( 
-            IDeviceSpecificProperty * This,
-            /* [out] */ 
-            __deref_out  LONG *plMin,
-            /* [out] */ 
-            __deref_out  LONG *plMax,
-            /* [out] */ 
-            __deref_out  LONG *plStepping);
-        
-        END_INTERFACE
-    } IDeviceSpecificPropertyVtbl;
-
-    interface IDeviceSpecificProperty
-    {
-        CONST_VTBL struct IDeviceSpecificPropertyVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IDeviceSpecificProperty_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IDeviceSpecificProperty_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IDeviceSpecificProperty_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IDeviceSpecificProperty_GetType(This,pVType)	\
-    ( (This)->lpVtbl -> GetType(This,pVType) ) 
-
-#define IDeviceSpecificProperty_GetValue(This,pvValue,pcbValue)	\
-    ( (This)->lpVtbl -> GetValue(This,pvValue,pcbValue) ) 
-
-#define IDeviceSpecificProperty_SetValue(This,pvValue,cbValue,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetValue(This,pvValue,cbValue,pguidEventContext) ) 
-
-#define IDeviceSpecificProperty_Get4BRange(This,plMin,plMax,plStepping)	\
-    ( (This)->lpVtbl -> Get4BRange(This,plMin,plMax,plStepping) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IDeviceSpecificProperty_INTERFACE_DEFINED__ */
-
-
-#ifndef __IKsFormatSupport_INTERFACE_DEFINED__
-#define __IKsFormatSupport_INTERFACE_DEFINED__
-
-/* interface IKsFormatSupport */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IKsFormatSupport;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("3CB4A69D-BB6F-4D2B-95B7-452D2C155DB5")
-    IKsFormatSupport : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsFormatSupported( 
-            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
-            /* [in] */ 
-            __in  DWORD cbFormat,
-            /* [out] */ 
-            __out  BOOL *pbSupported) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevicePreferredFormat( 
-            /* [out] */ PKSDATAFORMAT *ppKsFormat) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IKsFormatSupportVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IKsFormatSupport * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IKsFormatSupport * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IKsFormatSupport * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
-            IKsFormatSupport * This,
-            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
-            /* [in] */ 
-            __in  DWORD cbFormat,
-            /* [out] */ 
-            __out  BOOL *pbSupported);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevicePreferredFormat )( 
-            IKsFormatSupport * This,
-            /* [out] */ PKSDATAFORMAT *ppKsFormat);
-        
-        END_INTERFACE
-    } IKsFormatSupportVtbl;
-
-    interface IKsFormatSupport
-    {
-        CONST_VTBL struct IKsFormatSupportVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IKsFormatSupport_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IKsFormatSupport_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IKsFormatSupport_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IKsFormatSupport_IsFormatSupported(This,pKsFormat,cbFormat,pbSupported)	\
-    ( (This)->lpVtbl -> IsFormatSupported(This,pKsFormat,cbFormat,pbSupported) ) 
-
-#define IKsFormatSupport_GetDevicePreferredFormat(This,ppKsFormat)	\
-    ( (This)->lpVtbl -> GetDevicePreferredFormat(This,ppKsFormat) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IKsFormatSupport_INTERFACE_DEFINED__ */
-
-
-#ifndef __IKsJackDescription_INTERFACE_DEFINED__
-#define __IKsJackDescription_INTERFACE_DEFINED__
-
-/* interface IKsJackDescription */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IKsJackDescription;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("4509F757-2D46-4637-8E62-CE7DB944F57B")
-    IKsJackDescription : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackCount( 
-            /* [out] */ 
-            __out  UINT *pcJacks) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackDescription( 
-            /* [in] */ UINT nJack,
-            /* [out] */ 
-            __out  KSJACK_DESCRIPTION *pDescription) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IKsJackDescriptionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IKsJackDescription * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IKsJackDescription * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IKsJackDescription * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackCount )( 
-            IKsJackDescription * This,
-            /* [out] */ 
-            __out  UINT *pcJacks);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackDescription )( 
-            IKsJackDescription * This,
-            /* [in] */ UINT nJack,
-            /* [out] */ 
-            __out  KSJACK_DESCRIPTION *pDescription);
-        
-        END_INTERFACE
-    } IKsJackDescriptionVtbl;
-
-    interface IKsJackDescription
-    {
-        CONST_VTBL struct IKsJackDescriptionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IKsJackDescription_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IKsJackDescription_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IKsJackDescription_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IKsJackDescription_GetJackCount(This,pcJacks)	\
-    ( (This)->lpVtbl -> GetJackCount(This,pcJacks) ) 
-
-#define IKsJackDescription_GetJackDescription(This,nJack,pDescription)	\
-    ( (This)->lpVtbl -> GetJackDescription(This,nJack,pDescription) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IKsJackDescription_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPartsList_INTERFACE_DEFINED__
-#define __IPartsList_INTERFACE_DEFINED__
-
-/* interface IPartsList */
-/* [object][unique][helpstring][uuid][local] */ 
-
-
-EXTERN_C const IID IID_IPartsList;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("6DAA848C-5EB0-45CC-AEA5-998A2CDA1FFB")
-    IPartsList : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ 
-            __out  UINT *pCount) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPart( 
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IPart **ppPart) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPartsListVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPartsList * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPartsList * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPartsList * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPartsList * This,
-            /* [out] */ 
-            __out  UINT *pCount);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPart )( 
-            IPartsList * This,
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IPart **ppPart);
-        
-        END_INTERFACE
-    } IPartsListVtbl;
-
-    interface IPartsList
-    {
-        CONST_VTBL struct IPartsListVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPartsList_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPartsList_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPartsList_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPartsList_GetCount(This,pCount)	\
-    ( (This)->lpVtbl -> GetCount(This,pCount) ) 
-
-#define IPartsList_GetPart(This,nIndex,ppPart)	\
-    ( (This)->lpVtbl -> GetPart(This,nIndex,ppPart) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPartsList_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPart_INTERFACE_DEFINED__
-#define __IPart_INTERFACE_DEFINED__
-
-/* interface IPart */
-/* [object][unique][helpstring][uuid][local] */ 
-
-
-EXTERN_C const IID IID_IPart;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9")
-    IPart : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrName) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalId( 
-            /* [out] */ 
-            __out  UINT *pnId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGlobalId( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrGlobalId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartType( 
-            /* [out] */ 
-            __out  PartType *pPartType) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubType( 
-            /* [out] */ GUID *pSubType) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterfaceCount( 
-            /* [out] */ 
-            __out  UINT *pCount) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterface( 
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IControlInterface **ppInterfaceDesc) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsIncoming( 
-            /* [out] */ 
-            __out  IPartsList **ppParts) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsOutgoing( 
-            /* [out] */ 
-            __out  IPartsList **ppParts) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTopologyObject( 
-            /* [out] */ 
-            __out  IDeviceTopology **ppTopology) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
-            /* [in] */ 
-            __in  DWORD dwClsContext,
-            /* [in] */ 
-            __in  REFIID refiid,
-            /* [iid_is][out] */ 
-            __out_opt  void **ppvObject) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeCallback( 
-            /* [in] */ 
-            __in  REFGUID riid,
-            /* [in] */ 
-            __in  IControlChangeNotify *pNotify) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeCallback( 
-            /* [in] */ 
-            __in  IControlChangeNotify *pNotify) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPartVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPart * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPart * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPart * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
-            IPart * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrName);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalId )( 
-            IPart * This,
-            /* [out] */ 
-            __out  UINT *pnId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGlobalId )( 
-            IPart * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrGlobalId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartType )( 
-            IPart * This,
-            /* [out] */ 
-            __out  PartType *pPartType);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubType )( 
-            IPart * This,
-            /* [out] */ GUID *pSubType);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterfaceCount )( 
-            IPart * This,
-            /* [out] */ 
-            __out  UINT *pCount);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
-            IPart * This,
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IControlInterface **ppInterfaceDesc);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsIncoming )( 
-            IPart * This,
-            /* [out] */ 
-            __out  IPartsList **ppParts);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsOutgoing )( 
-            IPart * This,
-            /* [out] */ 
-            __out  IPartsList **ppParts);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTopologyObject )( 
-            IPart * This,
-            /* [out] */ 
-            __out  IDeviceTopology **ppTopology);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
-            IPart * This,
-            /* [in] */ 
-            __in  DWORD dwClsContext,
-            /* [in] */ 
-            __in  REFIID refiid,
-            /* [iid_is][out] */ 
-            __out_opt  void **ppvObject);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeCallback )( 
-            IPart * This,
-            /* [in] */ 
-            __in  REFGUID riid,
-            /* [in] */ 
-            __in  IControlChangeNotify *pNotify);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeCallback )( 
-            IPart * This,
-            /* [in] */ 
-            __in  IControlChangeNotify *pNotify);
-        
-        END_INTERFACE
-    } IPartVtbl;
-
-    interface IPart
-    {
-        CONST_VTBL struct IPartVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPart_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPart_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPart_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPart_GetName(This,ppwstrName)	\
-    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 
-
-#define IPart_GetLocalId(This,pnId)	\
-    ( (This)->lpVtbl -> GetLocalId(This,pnId) ) 
-
-#define IPart_GetGlobalId(This,ppwstrGlobalId)	\
-    ( (This)->lpVtbl -> GetGlobalId(This,ppwstrGlobalId) ) 
-
-#define IPart_GetPartType(This,pPartType)	\
-    ( (This)->lpVtbl -> GetPartType(This,pPartType) ) 
-
-#define IPart_GetSubType(This,pSubType)	\
-    ( (This)->lpVtbl -> GetSubType(This,pSubType) ) 
-
-#define IPart_GetControlInterfaceCount(This,pCount)	\
-    ( (This)->lpVtbl -> GetControlInterfaceCount(This,pCount) ) 
-
-#define IPart_GetControlInterface(This,nIndex,ppInterfaceDesc)	\
-    ( (This)->lpVtbl -> GetControlInterface(This,nIndex,ppInterfaceDesc) ) 
-
-#define IPart_EnumPartsIncoming(This,ppParts)	\
-    ( (This)->lpVtbl -> EnumPartsIncoming(This,ppParts) ) 
-
-#define IPart_EnumPartsOutgoing(This,ppParts)	\
-    ( (This)->lpVtbl -> EnumPartsOutgoing(This,ppParts) ) 
-
-#define IPart_GetTopologyObject(This,ppTopology)	\
-    ( (This)->lpVtbl -> GetTopologyObject(This,ppTopology) ) 
-
-#define IPart_Activate(This,dwClsContext,refiid,ppvObject)	\
-    ( (This)->lpVtbl -> Activate(This,dwClsContext,refiid,ppvObject) ) 
-
-#define IPart_RegisterControlChangeCallback(This,riid,pNotify)	\
-    ( (This)->lpVtbl -> RegisterControlChangeCallback(This,riid,pNotify) ) 
-
-#define IPart_UnregisterControlChangeCallback(This,pNotify)	\
-    ( (This)->lpVtbl -> UnregisterControlChangeCallback(This,pNotify) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPart_INTERFACE_DEFINED__ */
-
-
-#ifndef __IConnector_INTERFACE_DEFINED__
-#define __IConnector_INTERFACE_DEFINED__
-
-/* interface IConnector */
-/* [object][unique][helpstring][uuid][local] */ 
-
-
-EXTERN_C const IID IID_IConnector;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("9c2c4058-23f5-41de-877a-df3af236a09e")
-    IConnector : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
-            /* [out] */ 
-            __out  ConnectorType *pType) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
-            /* [out] */ 
-            __out  DataFlow *pFlow) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectTo( 
-            /* [in] */ 
-            __in  IConnector *pConnectTo) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsConnected( 
-            /* [out] */ 
-            __out  BOOL *pbConnected) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectedTo( 
-            /* [out] */ 
-            __out  IConnector **ppConTo) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorIdConnectedTo( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrConnectorId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceIdConnectedTo( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IConnectorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IConnector * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IConnector * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IConnector * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
-            IConnector * This,
-            /* [out] */ 
-            __out  ConnectorType *pType);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
-            IConnector * This,
-            /* [out] */ 
-            __out  DataFlow *pFlow);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectTo )( 
-            IConnector * This,
-            /* [in] */ 
-            __in  IConnector *pConnectTo);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
-            IConnector * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
-            IConnector * This,
-            /* [out] */ 
-            __out  BOOL *pbConnected);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedTo )( 
-            IConnector * This,
-            /* [out] */ 
-            __out  IConnector **ppConTo);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorIdConnectedTo )( 
-            IConnector * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrConnectorId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceIdConnectedTo )( 
-            IConnector * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrDeviceId);
-        
-        END_INTERFACE
-    } IConnectorVtbl;
-
-    interface IConnector
-    {
-        CONST_VTBL struct IConnectorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IConnector_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IConnector_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IConnector_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IConnector_GetType(This,pType)	\
-    ( (This)->lpVtbl -> GetType(This,pType) ) 
-
-#define IConnector_GetDataFlow(This,pFlow)	\
-    ( (This)->lpVtbl -> GetDataFlow(This,pFlow) ) 
-
-#define IConnector_ConnectTo(This,pConnectTo)	\
-    ( (This)->lpVtbl -> ConnectTo(This,pConnectTo) ) 
-
-#define IConnector_Disconnect(This)	\
-    ( (This)->lpVtbl -> Disconnect(This) ) 
-
-#define IConnector_IsConnected(This,pbConnected)	\
-    ( (This)->lpVtbl -> IsConnected(This,pbConnected) ) 
-
-#define IConnector_GetConnectedTo(This,ppConTo)	\
-    ( (This)->lpVtbl -> GetConnectedTo(This,ppConTo) ) 
-
-#define IConnector_GetConnectorIdConnectedTo(This,ppwstrConnectorId)	\
-    ( (This)->lpVtbl -> GetConnectorIdConnectedTo(This,ppwstrConnectorId) ) 
-
-#define IConnector_GetDeviceIdConnectedTo(This,ppwstrDeviceId)	\
-    ( (This)->lpVtbl -> GetDeviceIdConnectedTo(This,ppwstrDeviceId) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IConnector_INTERFACE_DEFINED__ */
-
-
-#ifndef __ISubunit_INTERFACE_DEFINED__
-#define __ISubunit_INTERFACE_DEFINED__
-
-/* interface ISubunit */
-/* [object][unique][helpstring][uuid][local] */ 
-
-
-EXTERN_C const IID IID_ISubunit;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("82149A85-DBA6-4487-86BB-EA8F7FEFCC71")
-    ISubunit : public IUnknown
-    {
-    public:
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ISubunitVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ISubunit * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ISubunit * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ISubunit * This);
-        
-        END_INTERFACE
-    } ISubunitVtbl;
-
-    interface ISubunit
-    {
-        CONST_VTBL struct ISubunitVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ISubunit_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ISubunit_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ISubunit_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ISubunit_INTERFACE_DEFINED__ */
-
-
-#ifndef __IControlInterface_INTERFACE_DEFINED__
-#define __IControlInterface_INTERFACE_DEFINED__
-
-/* interface IControlInterface */
-/* [object][unique][helpstring][uuid][local] */ 
-
-
-EXTERN_C const IID IID_IControlInterface;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("45d37c3f-5140-444a-ae24-400789f3cbf3")
-    IControlInterface : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrName) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIID( 
-            /* [out] */ 
-            __out  GUID *pIID) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IControlInterfaceVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IControlInterface * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IControlInterface * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IControlInterface * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
-            IControlInterface * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrName);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIID )( 
-            IControlInterface * This,
-            /* [out] */ 
-            __out  GUID *pIID);
-        
-        END_INTERFACE
-    } IControlInterfaceVtbl;
-
-    interface IControlInterface
-    {
-        CONST_VTBL struct IControlInterfaceVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IControlInterface_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IControlInterface_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IControlInterface_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IControlInterface_GetName(This,ppwstrName)	\
-    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 
-
-#define IControlInterface_GetIID(This,pIID)	\
-    ( (This)->lpVtbl -> GetIID(This,pIID) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IControlInterface_INTERFACE_DEFINED__ */
-
-
-#ifndef __IControlChangeNotify_INTERFACE_DEFINED__
-#define __IControlChangeNotify_INTERFACE_DEFINED__
-
-/* interface IControlChangeNotify */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IControlChangeNotify;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("A09513ED-C709-4d21-BD7B-5F34C47F3947")
-    IControlChangeNotify : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnNotify( 
-            /* [in] */ 
-            __in  DWORD dwSenderProcessId,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IControlChangeNotifyVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IControlChangeNotify * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IControlChangeNotify * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IControlChangeNotify * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
-            IControlChangeNotify * This,
-            /* [in] */ 
-            __in  DWORD dwSenderProcessId,
-            /* [unique][in] */ 
-            __in_opt  LPCGUID pguidEventContext);
-        
-        END_INTERFACE
-    } IControlChangeNotifyVtbl;
-
-    interface IControlChangeNotify
-    {
-        CONST_VTBL struct IControlChangeNotifyVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IControlChangeNotify_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IControlChangeNotify_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IControlChangeNotify_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IControlChangeNotify_OnNotify(This,dwSenderProcessId,pguidEventContext)	\
-    ( (This)->lpVtbl -> OnNotify(This,dwSenderProcessId,pguidEventContext) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IControlChangeNotify_INTERFACE_DEFINED__ */
-
-
-#ifndef __IDeviceTopology_INTERFACE_DEFINED__
-#define __IDeviceTopology_INTERFACE_DEFINED__
-
-/* interface IDeviceTopology */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IDeviceTopology;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("2A07407E-6497-4A18-9787-32F79BD0D98F")
-    IDeviceTopology : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorCount( 
-            /* [out] */ 
-            __out  UINT *pCount) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnector( 
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IConnector **ppConnector) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunitCount( 
-            /* [out] */ 
-            __out  UINT *pCount) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunit( 
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __deref_out  ISubunit **ppSubunit) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartById( 
-            /* [in] */ 
-            __in  UINT nId,
-            /* [out] */ 
-            __deref_out  IPart **ppPart) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceId( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalPath( 
-            /* [in] */ 
-            __in  IPart *pIPartFrom,
-            /* [in] */ 
-            __in  IPart *pIPartTo,
-            /* [in] */ 
-            __in  BOOL bRejectMixedPaths,
-            /* [out] */ 
-            __deref_out  IPartsList **ppParts) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IDeviceTopologyVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IDeviceTopology * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IDeviceTopology * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IDeviceTopology * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorCount )( 
-            IDeviceTopology * This,
-            /* [out] */ 
-            __out  UINT *pCount);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnector )( 
-            IDeviceTopology * This,
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __out  IConnector **ppConnector);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunitCount )( 
-            IDeviceTopology * This,
-            /* [out] */ 
-            __out  UINT *pCount);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunit )( 
-            IDeviceTopology * This,
-            /* [in] */ 
-            __in  UINT nIndex,
-            /* [out] */ 
-            __deref_out  ISubunit **ppSubunit);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartById )( 
-            IDeviceTopology * This,
-            /* [in] */ 
-            __in  UINT nId,
-            /* [out] */ 
-            __deref_out  IPart **ppPart);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
-            IDeviceTopology * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppwstrDeviceId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalPath )( 
-            IDeviceTopology * This,
-            /* [in] */ 
-            __in  IPart *pIPartFrom,
-            /* [in] */ 
-            __in  IPart *pIPartTo,
-            /* [in] */ 
-            __in  BOOL bRejectMixedPaths,
-            /* [out] */ 
-            __deref_out  IPartsList **ppParts);
-        
-        END_INTERFACE
-    } IDeviceTopologyVtbl;
-
-    interface IDeviceTopology
-    {
-        CONST_VTBL struct IDeviceTopologyVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IDeviceTopology_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IDeviceTopology_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IDeviceTopology_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IDeviceTopology_GetConnectorCount(This,pCount)	\
-    ( (This)->lpVtbl -> GetConnectorCount(This,pCount) ) 
-
-#define IDeviceTopology_GetConnector(This,nIndex,ppConnector)	\
-    ( (This)->lpVtbl -> GetConnector(This,nIndex,ppConnector) ) 
-
-#define IDeviceTopology_GetSubunitCount(This,pCount)	\
-    ( (This)->lpVtbl -> GetSubunitCount(This,pCount) ) 
-
-#define IDeviceTopology_GetSubunit(This,nIndex,ppSubunit)	\
-    ( (This)->lpVtbl -> GetSubunit(This,nIndex,ppSubunit) ) 
-
-#define IDeviceTopology_GetPartById(This,nId,ppPart)	\
-    ( (This)->lpVtbl -> GetPartById(This,nId,ppPart) ) 
-
-#define IDeviceTopology_GetDeviceId(This,ppwstrDeviceId)	\
-    ( (This)->lpVtbl -> GetDeviceId(This,ppwstrDeviceId) ) 
-
-#define IDeviceTopology_GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts)	\
-    ( (This)->lpVtbl -> GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IDeviceTopology_INTERFACE_DEFINED__ */
-
-
-
-#ifndef __DevTopologyLib_LIBRARY_DEFINED__
-#define __DevTopologyLib_LIBRARY_DEFINED__
-
-/* library DevTopologyLib */
-/* [helpstring][version][uuid] */ 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-EXTERN_C const IID LIBID_DevTopologyLib;
-
-EXTERN_C const CLSID CLSID_DeviceTopology;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("1DF639D0-5EC1-47AA-9379-828DC1AA8C59")
-DeviceTopology;
-#endif
-#endif /* __DevTopologyLib_LIBRARY_DEFINED__ */
-
-/* Additional Prototypes for ALL interfaces */
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for devicetopology.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __devicetopology_h__
+#define __devicetopology_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IKsControl_FWD_DEFINED__
+#define __IKsControl_FWD_DEFINED__
+typedef interface IKsControl IKsControl;
+#endif 	/* __IKsControl_FWD_DEFINED__ */
+
+
+#ifndef __IPerChannelDbLevel_FWD_DEFINED__
+#define __IPerChannelDbLevel_FWD_DEFINED__
+typedef interface IPerChannelDbLevel IPerChannelDbLevel;
+#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */
+
+
+#ifndef __IAudioVolumeLevel_FWD_DEFINED__
+#define __IAudioVolumeLevel_FWD_DEFINED__
+typedef interface IAudioVolumeLevel IAudioVolumeLevel;
+#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */
+
+
+#ifndef __IAudioChannelConfig_FWD_DEFINED__
+#define __IAudioChannelConfig_FWD_DEFINED__
+typedef interface IAudioChannelConfig IAudioChannelConfig;
+#endif 	/* __IAudioChannelConfig_FWD_DEFINED__ */
+
+
+#ifndef __IAudioLoudness_FWD_DEFINED__
+#define __IAudioLoudness_FWD_DEFINED__
+typedef interface IAudioLoudness IAudioLoudness;
+#endif 	/* __IAudioLoudness_FWD_DEFINED__ */
+
+
+#ifndef __IAudioInputSelector_FWD_DEFINED__
+#define __IAudioInputSelector_FWD_DEFINED__
+typedef interface IAudioInputSelector IAudioInputSelector;
+#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */
+
+
+#ifndef __IAudioOutputSelector_FWD_DEFINED__
+#define __IAudioOutputSelector_FWD_DEFINED__
+typedef interface IAudioOutputSelector IAudioOutputSelector;
+#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */
+
+
+#ifndef __IAudioMute_FWD_DEFINED__
+#define __IAudioMute_FWD_DEFINED__
+typedef interface IAudioMute IAudioMute;
+#endif 	/* __IAudioMute_FWD_DEFINED__ */
+
+
+#ifndef __IAudioBass_FWD_DEFINED__
+#define __IAudioBass_FWD_DEFINED__
+typedef interface IAudioBass IAudioBass;
+#endif 	/* __IAudioBass_FWD_DEFINED__ */
+
+
+#ifndef __IAudioMidrange_FWD_DEFINED__
+#define __IAudioMidrange_FWD_DEFINED__
+typedef interface IAudioMidrange IAudioMidrange;
+#endif 	/* __IAudioMidrange_FWD_DEFINED__ */
+
+
+#ifndef __IAudioTreble_FWD_DEFINED__
+#define __IAudioTreble_FWD_DEFINED__
+typedef interface IAudioTreble IAudioTreble;
+#endif 	/* __IAudioTreble_FWD_DEFINED__ */
+
+
+#ifndef __IAudioAutoGainControl_FWD_DEFINED__
+#define __IAudioAutoGainControl_FWD_DEFINED__
+typedef interface IAudioAutoGainControl IAudioAutoGainControl;
+#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */
+
+
+#ifndef __IAudioPeakMeter_FWD_DEFINED__
+#define __IAudioPeakMeter_FWD_DEFINED__
+typedef interface IAudioPeakMeter IAudioPeakMeter;
+#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */
+
+
+#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
+#define __IDeviceSpecificProperty_FWD_DEFINED__
+typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
+#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */
+
+
+#ifndef __IKsFormatSupport_FWD_DEFINED__
+#define __IKsFormatSupport_FWD_DEFINED__
+typedef interface IKsFormatSupport IKsFormatSupport;
+#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */
+
+
+#ifndef __IKsJackDescription_FWD_DEFINED__
+#define __IKsJackDescription_FWD_DEFINED__
+typedef interface IKsJackDescription IKsJackDescription;
+#endif 	/* __IKsJackDescription_FWD_DEFINED__ */
+
+
+#ifndef __IPartsList_FWD_DEFINED__
+#define __IPartsList_FWD_DEFINED__
+typedef interface IPartsList IPartsList;
+#endif 	/* __IPartsList_FWD_DEFINED__ */
+
+
+#ifndef __IPart_FWD_DEFINED__
+#define __IPart_FWD_DEFINED__
+typedef interface IPart IPart;
+#endif 	/* __IPart_FWD_DEFINED__ */
+
+
+#ifndef __IConnector_FWD_DEFINED__
+#define __IConnector_FWD_DEFINED__
+typedef interface IConnector IConnector;
+#endif 	/* __IConnector_FWD_DEFINED__ */
+
+
+#ifndef __ISubunit_FWD_DEFINED__
+#define __ISubunit_FWD_DEFINED__
+typedef interface ISubunit ISubunit;
+#endif 	/* __ISubunit_FWD_DEFINED__ */
+
+
+#ifndef __IControlInterface_FWD_DEFINED__
+#define __IControlInterface_FWD_DEFINED__
+typedef interface IControlInterface IControlInterface;
+#endif 	/* __IControlInterface_FWD_DEFINED__ */
+
+
+#ifndef __IControlChangeNotify_FWD_DEFINED__
+#define __IControlChangeNotify_FWD_DEFINED__
+typedef interface IControlChangeNotify IControlChangeNotify;
+#endif 	/* __IControlChangeNotify_FWD_DEFINED__ */
+
+
+#ifndef __IDeviceTopology_FWD_DEFINED__
+#define __IDeviceTopology_FWD_DEFINED__
+typedef interface IDeviceTopology IDeviceTopology;
+#endif 	/* __IDeviceTopology_FWD_DEFINED__ */
+
+
+#ifndef __DeviceTopology_FWD_DEFINED__
+#define __DeviceTopology_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class DeviceTopology DeviceTopology;
+#else
+typedef struct DeviceTopology DeviceTopology;
+#endif /* __cplusplus */
+
+#endif 	/* __DeviceTopology_FWD_DEFINED__ */
+
+
+#ifndef __IPartsList_FWD_DEFINED__
+#define __IPartsList_FWD_DEFINED__
+typedef interface IPartsList IPartsList;
+#endif 	/* __IPartsList_FWD_DEFINED__ */
+
+
+#ifndef __IPerChannelDbLevel_FWD_DEFINED__
+#define __IPerChannelDbLevel_FWD_DEFINED__
+typedef interface IPerChannelDbLevel IPerChannelDbLevel;
+#endif 	/* __IPerChannelDbLevel_FWD_DEFINED__ */
+
+
+#ifndef __IAudioVolumeLevel_FWD_DEFINED__
+#define __IAudioVolumeLevel_FWD_DEFINED__
+typedef interface IAudioVolumeLevel IAudioVolumeLevel;
+#endif 	/* __IAudioVolumeLevel_FWD_DEFINED__ */
+
+
+#ifndef __IAudioLoudness_FWD_DEFINED__
+#define __IAudioLoudness_FWD_DEFINED__
+typedef interface IAudioLoudness IAudioLoudness;
+#endif 	/* __IAudioLoudness_FWD_DEFINED__ */
+
+
+#ifndef __IAudioInputSelector_FWD_DEFINED__
+#define __IAudioInputSelector_FWD_DEFINED__
+typedef interface IAudioInputSelector IAudioInputSelector;
+#endif 	/* __IAudioInputSelector_FWD_DEFINED__ */
+
+
+#ifndef __IAudioMute_FWD_DEFINED__
+#define __IAudioMute_FWD_DEFINED__
+typedef interface IAudioMute IAudioMute;
+#endif 	/* __IAudioMute_FWD_DEFINED__ */
+
+
+#ifndef __IAudioBass_FWD_DEFINED__
+#define __IAudioBass_FWD_DEFINED__
+typedef interface IAudioBass IAudioBass;
+#endif 	/* __IAudioBass_FWD_DEFINED__ */
+
+
+#ifndef __IAudioMidrange_FWD_DEFINED__
+#define __IAudioMidrange_FWD_DEFINED__
+typedef interface IAudioMidrange IAudioMidrange;
+#endif 	/* __IAudioMidrange_FWD_DEFINED__ */
+
+
+#ifndef __IAudioTreble_FWD_DEFINED__
+#define __IAudioTreble_FWD_DEFINED__
+typedef interface IAudioTreble IAudioTreble;
+#endif 	/* __IAudioTreble_FWD_DEFINED__ */
+
+
+#ifndef __IAudioAutoGainControl_FWD_DEFINED__
+#define __IAudioAutoGainControl_FWD_DEFINED__
+typedef interface IAudioAutoGainControl IAudioAutoGainControl;
+#endif 	/* __IAudioAutoGainControl_FWD_DEFINED__ */
+
+
+#ifndef __IAudioOutputSelector_FWD_DEFINED__
+#define __IAudioOutputSelector_FWD_DEFINED__
+typedef interface IAudioOutputSelector IAudioOutputSelector;
+#endif 	/* __IAudioOutputSelector_FWD_DEFINED__ */
+
+
+#ifndef __IAudioPeakMeter_FWD_DEFINED__
+#define __IAudioPeakMeter_FWD_DEFINED__
+typedef interface IAudioPeakMeter IAudioPeakMeter;
+#endif 	/* __IAudioPeakMeter_FWD_DEFINED__ */
+
+
+#ifndef __IDeviceSpecificProperty_FWD_DEFINED__
+#define __IDeviceSpecificProperty_FWD_DEFINED__
+typedef interface IDeviceSpecificProperty IDeviceSpecificProperty;
+#endif 	/* __IDeviceSpecificProperty_FWD_DEFINED__ */
+
+
+#ifndef __IKsFormatSupport_FWD_DEFINED__
+#define __IKsFormatSupport_FWD_DEFINED__
+typedef interface IKsFormatSupport IKsFormatSupport;
+#endif 	/* __IKsFormatSupport_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+#include "propidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_devicetopology_0000_0000 */
+/* [local] */ 
+
+#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
+//
+//   Flag for clients of IControlChangeNotify::OnNotify to allow those clients to identify hardware initiated notifications
+//
+#define DEVTOPO_HARDWARE_INITIATED_EVENTCONTEXT 'draH'
+/* E2C2E9DE-09B1-4B04-84E5-07931225EE04 */
+DEFINE_GUID(EVENTCONTEXT_VOLUMESLIDER, 0xE2C2E9DE,0x09B1,0x4B04,0x84, 0xE5, 0x07, 0x93, 0x12, 0x25, 0xEE, 0x04);
+#define _IKsControl_
+#include "ks.h"
+#include "ksmedia.h"
+#ifndef _KS_
+typedef /* [public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001
+    {
+    ULONG FormatSize;
+    ULONG Flags;
+    ULONG SampleSize;
+    ULONG Reserved;
+    GUID MajorFormat;
+    GUID SubFormat;
+    GUID Specifier;
+    } 	KSDATAFORMAT;
+
+typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0001 *PKSDATAFORMAT;
+
+typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002
+    {
+    union 
+        {
+        struct 
+            {
+            GUID Set;
+            ULONG Id;
+            ULONG Flags;
+            } 	;
+        LONGLONG Alignment;
+        } 	;
+    } 	KSIDENTIFIER;
+
+typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0002 *PKSIDENTIFIER;
+
+typedef /* [public][public][public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0005
+    {	ePcxChanMap_FL_FR	= 0,
+	ePcxChanMap_FC_LFE	= ( ePcxChanMap_FL_FR + 1 ) ,
+	ePcxChanMap_BL_BR	= ( ePcxChanMap_FC_LFE + 1 ) ,
+	ePcxChanMap_FLC_FRC	= ( ePcxChanMap_BL_BR + 1 ) ,
+	ePcxChanMap_SL_SR	= ( ePcxChanMap_FLC_FRC + 1 ) ,
+	ePcxChanMap_Unknown	= ( ePcxChanMap_SL_SR + 1 ) 
+    } 	EChannelMapping;
+
+typedef /* [public][public][public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0006
+    {	eConnTypeUnknown	= 0,
+	eConnTypeEighth	= ( eConnTypeUnknown + 1 ) ,
+	eConnTypeQuarter	= ( eConnTypeEighth + 1 ) ,
+	eConnTypeAtapiInternal	= ( eConnTypeQuarter + 1 ) ,
+	eConnTypeRCA	= ( eConnTypeAtapiInternal + 1 ) ,
+	eConnTypeOptical	= ( eConnTypeRCA + 1 ) ,
+	eConnTypeOtherDigital	= ( eConnTypeOptical + 1 ) ,
+	eConnTypeOtherAnalog	= ( eConnTypeOtherDigital + 1 ) ,
+	eConnTypeMultichannelAnalogDIN	= ( eConnTypeOtherAnalog + 1 ) ,
+	eConnTypeXlrProfessional	= ( eConnTypeMultichannelAnalogDIN + 1 ) ,
+	eConnTypeRJ11Modem	= ( eConnTypeXlrProfessional + 1 ) ,
+	eConnTypeCombination	= ( eConnTypeRJ11Modem + 1 ) 
+    } 	EPcxConnectionType;
+
+typedef /* [public][public][public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0007
+    {	eGeoLocRear	= 0x1,
+	eGeoLocFront	= ( eGeoLocRear + 1 ) ,
+	eGeoLocLeft	= ( eGeoLocFront + 1 ) ,
+	eGeoLocRight	= ( eGeoLocLeft + 1 ) ,
+	eGeoLocTop	= ( eGeoLocRight + 1 ) ,
+	eGeoLocBottom	= ( eGeoLocTop + 1 ) ,
+	eGeoLocRearOPanel	= ( eGeoLocBottom + 1 ) ,
+	eGeoLocRiser	= ( eGeoLocRearOPanel + 1 ) ,
+	eGeoLocInsideMobileLid	= ( eGeoLocRiser + 1 ) ,
+	eGeoLocDrivebay	= ( eGeoLocInsideMobileLid + 1 ) ,
+	eGeoLocHDMI	= ( eGeoLocDrivebay + 1 ) ,
+	eGeoLocOutsideMobileLid	= ( eGeoLocHDMI + 1 ) ,
+	eGeoLocATAPI	= ( eGeoLocOutsideMobileLid + 1 ) ,
+	eGeoLocReserved5	= ( eGeoLocATAPI + 1 ) ,
+	eGeoLocReserved6	= ( eGeoLocReserved5 + 1 ) 
+    } 	EPcxGeoLocation;
+
+typedef /* [public][public][public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0008
+    {	eGenLocPrimaryBox	= 0,
+	eGenLocInternal	= ( eGenLocPrimaryBox + 1 ) ,
+	eGenLocSeperate	= ( eGenLocInternal + 1 ) ,
+	eGenLocOther	= ( eGenLocSeperate + 1 ) 
+    } 	EPcxGenLocation;
+
+typedef /* [public][public][public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0009
+    {	ePortConnJack	= 0,
+	ePortConnIntegratedDevice	= ( ePortConnJack + 1 ) ,
+	ePortConnBothIntegratedAndJack	= ( ePortConnIntegratedDevice + 1 ) ,
+	ePortConnUnknown	= ( ePortConnBothIntegratedAndJack + 1 ) 
+    } 	EPxcPortConnection;
+
+typedef /* [public][public] */ struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010
+    {
+    EChannelMapping ChannelMapping;
+    COLORREF Color;
+    EPcxConnectionType ConnectionType;
+    EPcxGeoLocation GeoLocation;
+    EPcxGenLocation GenLocation;
+    EPxcPortConnection PortConnection;
+    BOOL IsConnected;
+    } 	KSJACK_DESCRIPTION;
+
+typedef struct __MIDL___MIDL_itf_devicetopology_0000_0000_0010 *PKSJACK_DESCRIPTION;
+
+typedef KSIDENTIFIER KSPROPERTY;
+
+typedef KSIDENTIFIER *PKSPROPERTY;
+
+typedef KSIDENTIFIER KSMETHOD;
+
+typedef KSIDENTIFIER *PKSMETHOD;
+
+typedef KSIDENTIFIER KSEVENT;
+
+typedef KSIDENTIFIER *PKSEVENT;
+
+#endif
+
+
+
+
+
+
+
+
+typedef /* [public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0011
+    {	In	= 0,
+	Out	= ( In + 1 ) 
+    } 	DataFlow;
+
+typedef /* [public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0012
+    {	Connector	= 0,
+	Subunit	= ( Connector + 1 ) 
+    } 	PartType;
+
+#define PARTTYPE_FLAG_CONNECTOR 0x00010000
+#define PARTTYPE_FLAG_SUBUNIT   0x00020000
+#define PARTTYPE_MASK           0x00030000
+#define PARTID_MASK             0x0000ffff
+typedef /* [public][public] */ 
+enum __MIDL___MIDL_itf_devicetopology_0000_0000_0013
+    {	Unknown_Connector	= 0,
+	Physical_Internal	= ( Unknown_Connector + 1 ) ,
+	Physical_External	= ( Physical_Internal + 1 ) ,
+	Software_IO	= ( Physical_External + 1 ) ,
+	Software_Fixed	= ( Software_IO + 1 ) ,
+	Network	= ( Software_Fixed + 1 ) 
+    } 	ConnectorType;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_devicetopology_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IKsControl_INTERFACE_DEFINED__
+#define __IKsControl_INTERFACE_DEFINED__
+
+/* interface IKsControl */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IKsControl;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("28F54685-06FD-11D2-B27A-00A0C9223196")
+    IKsControl : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE KsProperty( 
+            /* [in] */ PKSPROPERTY Property,
+            /* [in] */ ULONG PropertyLength,
+            /* [out][in] */ void *PropertyData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE KsMethod( 
+            /* [in] */ PKSMETHOD Method,
+            /* [in] */ ULONG MethodLength,
+            /* [out][in] */ void *MethodData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE KsEvent( 
+            /* [in] */ PKSEVENT Event,
+            /* [in] */ ULONG EventLength,
+            /* [out][in] */ void *EventData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IKsControlVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IKsControl * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IKsControl * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IKsControl * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *KsProperty )( 
+            IKsControl * This,
+            /* [in] */ PKSPROPERTY Property,
+            /* [in] */ ULONG PropertyLength,
+            /* [out][in] */ void *PropertyData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned);
+        
+        HRESULT ( STDMETHODCALLTYPE *KsMethod )( 
+            IKsControl * This,
+            /* [in] */ PKSMETHOD Method,
+            /* [in] */ ULONG MethodLength,
+            /* [out][in] */ void *MethodData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned);
+        
+        HRESULT ( STDMETHODCALLTYPE *KsEvent )( 
+            IKsControl * This,
+            /* [in] */ PKSEVENT Event,
+            /* [in] */ ULONG EventLength,
+            /* [out][in] */ void *EventData,
+            /* [in] */ ULONG DataLength,
+            /* [out] */ ULONG *BytesReturned);
+        
+        END_INTERFACE
+    } IKsControlVtbl;
+
+    interface IKsControl
+    {
+        CONST_VTBL struct IKsControlVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IKsControl_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IKsControl_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IKsControl_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IKsControl_KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned)	\
+    ( (This)->lpVtbl -> KsProperty(This,Property,PropertyLength,PropertyData,DataLength,BytesReturned) ) 
+
+#define IKsControl_KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned)	\
+    ( (This)->lpVtbl -> KsMethod(This,Method,MethodLength,MethodData,DataLength,BytesReturned) ) 
+
+#define IKsControl_KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned)	\
+    ( (This)->lpVtbl -> KsEvent(This,Event,EventLength,EventData,DataLength,BytesReturned) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IKsControl_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPerChannelDbLevel_INTERFACE_DEFINED__
+#define __IPerChannelDbLevel_INTERFACE_DEFINED__
+
+/* interface IPerChannelDbLevel */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IPerChannelDbLevel;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("C2F8E001-F205-4BC9-99BC-C13B1E048CCB")
+    IPerChannelDbLevel : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
+            /* [out] */ 
+            __out  UINT *pcChannels) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevelRange( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevel( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelUniform( 
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLevelAllChannels( 
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPerChannelDbLevelVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPerChannelDbLevel * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPerChannelDbLevel * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPerChannelDbLevel * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IPerChannelDbLevel * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
+            IPerChannelDbLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IPerChannelDbLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
+            IPerChannelDbLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
+            IPerChannelDbLevel * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
+            IPerChannelDbLevel * This,
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IPerChannelDbLevelVtbl;
+
+    interface IPerChannelDbLevel
+    {
+        CONST_VTBL struct IPerChannelDbLevelVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPerChannelDbLevel_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPerChannelDbLevel_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPerChannelDbLevel_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPerChannelDbLevel_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IPerChannelDbLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
+    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
+
+#define IPerChannelDbLevel_GetLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
+
+#define IPerChannelDbLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IPerChannelDbLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
+
+#define IPerChannelDbLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPerChannelDbLevel_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioVolumeLevel_INTERFACE_DEFINED__
+#define __IAudioVolumeLevel_INTERFACE_DEFINED__
+
+/* interface IAudioVolumeLevel */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioVolumeLevel;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7FB7B48F-531D-44A2-BCB3-5AD5A134B3DC")
+    IAudioVolumeLevel : public IPerChannelDbLevel
+    {
+    public:
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioVolumeLevelVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioVolumeLevel * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioVolumeLevel * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioVolumeLevel * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioVolumeLevel * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
+            IAudioVolumeLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IAudioVolumeLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
+            IAudioVolumeLevel * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
+            IAudioVolumeLevel * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
+            IAudioVolumeLevel * This,
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioVolumeLevelVtbl;
+
+    interface IAudioVolumeLevel
+    {
+        CONST_VTBL struct IAudioVolumeLevelVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioVolumeLevel_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioVolumeLevel_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioVolumeLevel_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioVolumeLevel_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IAudioVolumeLevel_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
+    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
+
+#define IAudioVolumeLevel_GetLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
+
+#define IAudioVolumeLevel_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IAudioVolumeLevel_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
+
+#define IAudioVolumeLevel_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioVolumeLevel_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioChannelConfig_INTERFACE_DEFINED__
+#define __IAudioChannelConfig_INTERFACE_DEFINED__
+
+/* interface IAudioChannelConfig */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioChannelConfig;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("BB11C46F-EC28-493C-B88A-5DB88062CE98")
+    IAudioChannelConfig : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetChannelConfig( 
+            /* [in] */ DWORD dwConfig,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelConfig( 
+            /* [retval][out] */ DWORD *pdwConfig) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioChannelConfigVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioChannelConfig * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioChannelConfig * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioChannelConfig * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetChannelConfig )( 
+            IAudioChannelConfig * This,
+            /* [in] */ DWORD dwConfig,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelConfig )( 
+            IAudioChannelConfig * This,
+            /* [retval][out] */ DWORD *pdwConfig);
+        
+        END_INTERFACE
+    } IAudioChannelConfigVtbl;
+
+    interface IAudioChannelConfig
+    {
+        CONST_VTBL struct IAudioChannelConfigVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioChannelConfig_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioChannelConfig_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioChannelConfig_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioChannelConfig_SetChannelConfig(This,dwConfig,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetChannelConfig(This,dwConfig,pguidEventContext) ) 
+
+#define IAudioChannelConfig_GetChannelConfig(This,pdwConfig)	\
+    ( (This)->lpVtbl -> GetChannelConfig(This,pdwConfig) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioChannelConfig_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioLoudness_INTERFACE_DEFINED__
+#define __IAudioLoudness_INTERFACE_DEFINED__
+
+/* interface IAudioLoudness */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioLoudness;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7D8B1437-DD53-4350-9C1B-1EE2890BD938")
+    IAudioLoudness : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
+            /* [out] */ 
+            __out  BOOL *pbEnabled) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
+            /* [in] */ 
+            __in  BOOL bEnable,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioLoudnessVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioLoudness * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioLoudness * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioLoudness * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
+            IAudioLoudness * This,
+            /* [out] */ 
+            __out  BOOL *pbEnabled);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
+            IAudioLoudness * This,
+            /* [in] */ 
+            __in  BOOL bEnable,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioLoudnessVtbl;
+
+    interface IAudioLoudness
+    {
+        CONST_VTBL struct IAudioLoudnessVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioLoudness_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioLoudness_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioLoudness_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioLoudness_GetEnabled(This,pbEnabled)	\
+    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 
+
+#define IAudioLoudness_SetEnabled(This,bEnable,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioLoudness_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioInputSelector_INTERFACE_DEFINED__
+#define __IAudioInputSelector_INTERFACE_DEFINED__
+
+/* interface IAudioInputSelector */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioInputSelector;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("4F03DC02-5E6E-4653-8F72-A030C123D598")
+    IAudioInputSelector : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
+            /* [out] */ 
+            __out  UINT *pnIdSelected) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
+            /* [in] */ 
+            __in  UINT nIdSelect,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioInputSelectorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioInputSelector * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioInputSelector * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioInputSelector * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
+            IAudioInputSelector * This,
+            /* [out] */ 
+            __out  UINT *pnIdSelected);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
+            IAudioInputSelector * This,
+            /* [in] */ 
+            __in  UINT nIdSelect,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioInputSelectorVtbl;
+
+    interface IAudioInputSelector
+    {
+        CONST_VTBL struct IAudioInputSelectorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioInputSelector_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioInputSelector_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioInputSelector_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioInputSelector_GetSelection(This,pnIdSelected)	\
+    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 
+
+#define IAudioInputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioInputSelector_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioOutputSelector_INTERFACE_DEFINED__
+#define __IAudioOutputSelector_INTERFACE_DEFINED__
+
+/* interface IAudioOutputSelector */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioOutputSelector;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("BB515F69-94A7-429e-8B9C-271B3F11A3AB")
+    IAudioOutputSelector : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
+            /* [out] */ 
+            __out  UINT *pnIdSelected) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSelection( 
+            /* [in] */ 
+            __in  UINT nIdSelect,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioOutputSelectorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioOutputSelector * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioOutputSelector * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioOutputSelector * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
+            IAudioOutputSelector * This,
+            /* [out] */ 
+            __out  UINT *pnIdSelected);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
+            IAudioOutputSelector * This,
+            /* [in] */ 
+            __in  UINT nIdSelect,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioOutputSelectorVtbl;
+
+    interface IAudioOutputSelector
+    {
+        CONST_VTBL struct IAudioOutputSelectorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioOutputSelector_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioOutputSelector_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioOutputSelector_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioOutputSelector_GetSelection(This,pnIdSelected)	\
+    ( (This)->lpVtbl -> GetSelection(This,pnIdSelected) ) 
+
+#define IAudioOutputSelector_SetSelection(This,nIdSelect,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetSelection(This,nIdSelect,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioOutputSelector_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioMute_INTERFACE_DEFINED__
+#define __IAudioMute_INTERFACE_DEFINED__
+
+/* interface IAudioMute */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioMute;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("DF45AEEA-B74A-4B6B-AFAD-2366B6AA012E")
+    IAudioMute : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMute( 
+            /* [in] */ 
+            __in  BOOL bMuted,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMute( 
+            /* [out] */ 
+            __out  BOOL *pbMuted) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioMuteVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioMute * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioMute * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioMute * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
+            IAudioMute * This,
+            /* [in] */ 
+            __in  BOOL bMuted,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
+            IAudioMute * This,
+            /* [out] */ 
+            __out  BOOL *pbMuted);
+        
+        END_INTERFACE
+    } IAudioMuteVtbl;
+
+    interface IAudioMute
+    {
+        CONST_VTBL struct IAudioMuteVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioMute_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioMute_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioMute_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioMute_SetMute(This,bMuted,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetMute(This,bMuted,pguidEventContext) ) 
+
+#define IAudioMute_GetMute(This,pbMuted)	\
+    ( (This)->lpVtbl -> GetMute(This,pbMuted) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioMute_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioBass_INTERFACE_DEFINED__
+#define __IAudioBass_INTERFACE_DEFINED__
+
+/* interface IAudioBass */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioBass;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A2B1A1D9-4DB3-425D-A2B2-BD335CB3E2E5")
+    IAudioBass : public IPerChannelDbLevel
+    {
+    public:
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioBassVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioBass * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioBass * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioBass * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioBass * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
+            IAudioBass * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IAudioBass * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
+            IAudioBass * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
+            IAudioBass * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
+            IAudioBass * This,
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioBassVtbl;
+
+    interface IAudioBass
+    {
+        CONST_VTBL struct IAudioBassVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioBass_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioBass_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioBass_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioBass_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IAudioBass_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
+    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
+
+#define IAudioBass_GetLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
+
+#define IAudioBass_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IAudioBass_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
+
+#define IAudioBass_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioBass_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioMidrange_INTERFACE_DEFINED__
+#define __IAudioMidrange_INTERFACE_DEFINED__
+
+/* interface IAudioMidrange */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioMidrange;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("5E54B6D7-B44B-40D9-9A9E-E691D9CE6EDF")
+    IAudioMidrange : public IPerChannelDbLevel
+    {
+    public:
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioMidrangeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioMidrange * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioMidrange * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioMidrange * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioMidrange * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
+            IAudioMidrange * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IAudioMidrange * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
+            IAudioMidrange * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
+            IAudioMidrange * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
+            IAudioMidrange * This,
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioMidrangeVtbl;
+
+    interface IAudioMidrange
+    {
+        CONST_VTBL struct IAudioMidrangeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioMidrange_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioMidrange_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioMidrange_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioMidrange_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IAudioMidrange_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
+    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
+
+#define IAudioMidrange_GetLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
+
+#define IAudioMidrange_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IAudioMidrange_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
+
+#define IAudioMidrange_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioMidrange_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioTreble_INTERFACE_DEFINED__
+#define __IAudioTreble_INTERFACE_DEFINED__
+
+/* interface IAudioTreble */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioTreble;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0A717812-694E-4907-B74B-BAFA5CFDCA7B")
+    IAudioTreble : public IPerChannelDbLevel
+    {
+    public:
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioTrebleVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioTreble * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioTreble * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioTreble * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioTreble * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevelRange )( 
+            IAudioTreble * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfMinLevelDB,
+            /* [out] */ 
+            __out  float *pfMaxLevelDB,
+            /* [out] */ 
+            __out  float *pfStepping);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IAudioTreble * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
+            IAudioTreble * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelUniform )( 
+            IAudioTreble * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLevelAllChannels )( 
+            IAudioTreble * This,
+            /* [size_is][in] */ 
+            __in_ecount(cChannels)  float aLevelsDB[  ],
+            /* [in] */ 
+            __in  ULONG cChannels,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioTrebleVtbl;
+
+    interface IAudioTreble
+    {
+        CONST_VTBL struct IAudioTrebleVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioTreble_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioTreble_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioTreble_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioTreble_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IAudioTreble_GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping)	\
+    ( (This)->lpVtbl -> GetLevelRange(This,nChannel,pfMinLevelDB,pfMaxLevelDB,pfStepping) ) 
+
+#define IAudioTreble_GetLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevelDB) ) 
+
+#define IAudioTreble_SetLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IAudioTreble_SetLevelUniform(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelUniform(This,fLevelDB,pguidEventContext) ) 
+
+#define IAudioTreble_SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetLevelAllChannels(This,aLevelsDB,cChannels,pguidEventContext) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioTreble_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioAutoGainControl_INTERFACE_DEFINED__
+#define __IAudioAutoGainControl_INTERFACE_DEFINED__
+
+/* interface IAudioAutoGainControl */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioAutoGainControl;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("85401FD4-6DE4-4b9d-9869-2D6753A82F3C")
+    IAudioAutoGainControl : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEnabled( 
+            /* [out] */ 
+            __out  BOOL *pbEnabled) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
+            /* [in] */ 
+            __in  BOOL bEnable,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioAutoGainControlVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioAutoGainControl * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioAutoGainControl * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioAutoGainControl * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
+            IAudioAutoGainControl * This,
+            /* [out] */ 
+            __out  BOOL *pbEnabled);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
+            IAudioAutoGainControl * This,
+            /* [in] */ 
+            __in  BOOL bEnable,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IAudioAutoGainControlVtbl;
+
+    interface IAudioAutoGainControl
+    {
+        CONST_VTBL struct IAudioAutoGainControlVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioAutoGainControl_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioAutoGainControl_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioAutoGainControl_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioAutoGainControl_GetEnabled(This,pbEnabled)	\
+    ( (This)->lpVtbl -> GetEnabled(This,pbEnabled) ) 
+
+#define IAudioAutoGainControl_SetEnabled(This,bEnable,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetEnabled(This,bEnable,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioAutoGainControl_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioPeakMeter_INTERFACE_DEFINED__
+#define __IAudioPeakMeter_INTERFACE_DEFINED__
+
+/* interface IAudioPeakMeter */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioPeakMeter;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("DD79923C-0599-45e0-B8B6-C8DF7DB6E796")
+    IAudioPeakMeter : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
+            /* [out] */ 
+            __out  UINT *pcChannels) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLevel( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioPeakMeterVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioPeakMeter * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioPeakMeter * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioPeakMeter * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioPeakMeter * This,
+            /* [out] */ 
+            __out  UINT *pcChannels);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
+            IAudioPeakMeter * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        END_INTERFACE
+    } IAudioPeakMeterVtbl;
+
+    interface IAudioPeakMeter
+    {
+        CONST_VTBL struct IAudioPeakMeterVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioPeakMeter_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioPeakMeter_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioPeakMeter_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioPeakMeter_GetChannelCount(This,pcChannels)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pcChannels) ) 
+
+#define IAudioPeakMeter_GetLevel(This,nChannel,pfLevel)	\
+    ( (This)->lpVtbl -> GetLevel(This,nChannel,pfLevel) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioPeakMeter_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDeviceSpecificProperty_INTERFACE_DEFINED__
+#define __IDeviceSpecificProperty_INTERFACE_DEFINED__
+
+/* interface IDeviceSpecificProperty */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IDeviceSpecificProperty;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3B22BCBF-2586-4af0-8583-205D391B807C")
+    IDeviceSpecificProperty : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
+            /* [out] */ 
+            __deref_out  VARTYPE *pVType) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetValue( 
+            /* [out] */ 
+            __out  void *pvValue,
+            /* [out][in] */ 
+            __inout  DWORD *pcbValue) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetValue( 
+            /* [in] */ 
+            __in  void *pvValue,
+            /* [in] */ DWORD cbValue,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get4BRange( 
+            /* [out] */ 
+            __deref_out  LONG *plMin,
+            /* [out] */ 
+            __deref_out  LONG *plMax,
+            /* [out] */ 
+            __deref_out  LONG *plStepping) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IDeviceSpecificPropertyVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDeviceSpecificProperty * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDeviceSpecificProperty * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDeviceSpecificProperty * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
+            IDeviceSpecificProperty * This,
+            /* [out] */ 
+            __deref_out  VARTYPE *pVType);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
+            IDeviceSpecificProperty * This,
+            /* [out] */ 
+            __out  void *pvValue,
+            /* [out][in] */ 
+            __inout  DWORD *pcbValue);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetValue )( 
+            IDeviceSpecificProperty * This,
+            /* [in] */ 
+            __in  void *pvValue,
+            /* [in] */ DWORD cbValue,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get4BRange )( 
+            IDeviceSpecificProperty * This,
+            /* [out] */ 
+            __deref_out  LONG *plMin,
+            /* [out] */ 
+            __deref_out  LONG *plMax,
+            /* [out] */ 
+            __deref_out  LONG *plStepping);
+        
+        END_INTERFACE
+    } IDeviceSpecificPropertyVtbl;
+
+    interface IDeviceSpecificProperty
+    {
+        CONST_VTBL struct IDeviceSpecificPropertyVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDeviceSpecificProperty_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDeviceSpecificProperty_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDeviceSpecificProperty_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDeviceSpecificProperty_GetType(This,pVType)	\
+    ( (This)->lpVtbl -> GetType(This,pVType) ) 
+
+#define IDeviceSpecificProperty_GetValue(This,pvValue,pcbValue)	\
+    ( (This)->lpVtbl -> GetValue(This,pvValue,pcbValue) ) 
+
+#define IDeviceSpecificProperty_SetValue(This,pvValue,cbValue,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetValue(This,pvValue,cbValue,pguidEventContext) ) 
+
+#define IDeviceSpecificProperty_Get4BRange(This,plMin,plMax,plStepping)	\
+    ( (This)->lpVtbl -> Get4BRange(This,plMin,plMax,plStepping) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IDeviceSpecificProperty_INTERFACE_DEFINED__ */
+
+
+#ifndef __IKsFormatSupport_INTERFACE_DEFINED__
+#define __IKsFormatSupport_INTERFACE_DEFINED__
+
+/* interface IKsFormatSupport */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IKsFormatSupport;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3CB4A69D-BB6F-4D2B-95B7-452D2C155DB5")
+    IKsFormatSupport : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsFormatSupported( 
+            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
+            /* [in] */ 
+            __in  DWORD cbFormat,
+            /* [out] */ 
+            __out  BOOL *pbSupported) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevicePreferredFormat( 
+            /* [out] */ PKSDATAFORMAT *ppKsFormat) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IKsFormatSupportVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IKsFormatSupport * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IKsFormatSupport * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IKsFormatSupport * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
+            IKsFormatSupport * This,
+            /* [size_is][in] */ PKSDATAFORMAT pKsFormat,
+            /* [in] */ 
+            __in  DWORD cbFormat,
+            /* [out] */ 
+            __out  BOOL *pbSupported);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevicePreferredFormat )( 
+            IKsFormatSupport * This,
+            /* [out] */ PKSDATAFORMAT *ppKsFormat);
+        
+        END_INTERFACE
+    } IKsFormatSupportVtbl;
+
+    interface IKsFormatSupport
+    {
+        CONST_VTBL struct IKsFormatSupportVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IKsFormatSupport_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IKsFormatSupport_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IKsFormatSupport_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IKsFormatSupport_IsFormatSupported(This,pKsFormat,cbFormat,pbSupported)	\
+    ( (This)->lpVtbl -> IsFormatSupported(This,pKsFormat,cbFormat,pbSupported) ) 
+
+#define IKsFormatSupport_GetDevicePreferredFormat(This,ppKsFormat)	\
+    ( (This)->lpVtbl -> GetDevicePreferredFormat(This,ppKsFormat) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IKsFormatSupport_INTERFACE_DEFINED__ */
+
+
+#ifndef __IKsJackDescription_INTERFACE_DEFINED__
+#define __IKsJackDescription_INTERFACE_DEFINED__
+
+/* interface IKsJackDescription */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IKsJackDescription;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("4509F757-2D46-4637-8E62-CE7DB944F57B")
+    IKsJackDescription : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackCount( 
+            /* [out] */ 
+            __out  UINT *pcJacks) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJackDescription( 
+            /* [in] */ UINT nJack,
+            /* [out] */ 
+            __out  KSJACK_DESCRIPTION *pDescription) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IKsJackDescriptionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IKsJackDescription * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IKsJackDescription * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IKsJackDescription * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackCount )( 
+            IKsJackDescription * This,
+            /* [out] */ 
+            __out  UINT *pcJacks);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetJackDescription )( 
+            IKsJackDescription * This,
+            /* [in] */ UINT nJack,
+            /* [out] */ 
+            __out  KSJACK_DESCRIPTION *pDescription);
+        
+        END_INTERFACE
+    } IKsJackDescriptionVtbl;
+
+    interface IKsJackDescription
+    {
+        CONST_VTBL struct IKsJackDescriptionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IKsJackDescription_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IKsJackDescription_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IKsJackDescription_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IKsJackDescription_GetJackCount(This,pcJacks)	\
+    ( (This)->lpVtbl -> GetJackCount(This,pcJacks) ) 
+
+#define IKsJackDescription_GetJackDescription(This,nJack,pDescription)	\
+    ( (This)->lpVtbl -> GetJackDescription(This,nJack,pDescription) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IKsJackDescription_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPartsList_INTERFACE_DEFINED__
+#define __IPartsList_INTERFACE_DEFINED__
+
+/* interface IPartsList */
+/* [object][unique][helpstring][uuid][local] */ 
+
+
+EXTERN_C const IID IID_IPartsList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6DAA848C-5EB0-45CC-AEA5-998A2CDA1FFB")
+    IPartsList : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ 
+            __out  UINT *pCount) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPart( 
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IPart **ppPart) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPartsListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPartsList * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPartsList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPartsList * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPartsList * This,
+            /* [out] */ 
+            __out  UINT *pCount);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPart )( 
+            IPartsList * This,
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IPart **ppPart);
+        
+        END_INTERFACE
+    } IPartsListVtbl;
+
+    interface IPartsList
+    {
+        CONST_VTBL struct IPartsListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPartsList_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPartsList_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPartsList_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPartsList_GetCount(This,pCount)	\
+    ( (This)->lpVtbl -> GetCount(This,pCount) ) 
+
+#define IPartsList_GetPart(This,nIndex,ppPart)	\
+    ( (This)->lpVtbl -> GetPart(This,nIndex,ppPart) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPartsList_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPart_INTERFACE_DEFINED__
+#define __IPart_INTERFACE_DEFINED__
+
+/* interface IPart */
+/* [object][unique][helpstring][uuid][local] */ 
+
+
+EXTERN_C const IID IID_IPart;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9")
+    IPart : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrName) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalId( 
+            /* [out] */ 
+            __out  UINT *pnId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGlobalId( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrGlobalId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartType( 
+            /* [out] */ 
+            __out  PartType *pPartType) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubType( 
+            /* [out] */ GUID *pSubType) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterfaceCount( 
+            /* [out] */ 
+            __out  UINT *pCount) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetControlInterface( 
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IControlInterface **ppInterfaceDesc) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsIncoming( 
+            /* [out] */ 
+            __out  IPartsList **ppParts) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumPartsOutgoing( 
+            /* [out] */ 
+            __out  IPartsList **ppParts) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTopologyObject( 
+            /* [out] */ 
+            __out  IDeviceTopology **ppTopology) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
+            /* [in] */ 
+            __in  DWORD dwClsContext,
+            /* [in] */ 
+            __in  REFIID refiid,
+            /* [iid_is][out] */ 
+            __out_opt  void **ppvObject) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeCallback( 
+            /* [in] */ 
+            __in  REFGUID riid,
+            /* [in] */ 
+            __in  IControlChangeNotify *pNotify) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeCallback( 
+            /* [in] */ 
+            __in  IControlChangeNotify *pNotify) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPartVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPart * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPart * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPart * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
+            IPart * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrName);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalId )( 
+            IPart * This,
+            /* [out] */ 
+            __out  UINT *pnId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGlobalId )( 
+            IPart * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrGlobalId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartType )( 
+            IPart * This,
+            /* [out] */ 
+            __out  PartType *pPartType);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubType )( 
+            IPart * This,
+            /* [out] */ GUID *pSubType);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterfaceCount )( 
+            IPart * This,
+            /* [out] */ 
+            __out  UINT *pCount);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
+            IPart * This,
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IControlInterface **ppInterfaceDesc);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsIncoming )( 
+            IPart * This,
+            /* [out] */ 
+            __out  IPartsList **ppParts);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumPartsOutgoing )( 
+            IPart * This,
+            /* [out] */ 
+            __out  IPartsList **ppParts);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTopologyObject )( 
+            IPart * This,
+            /* [out] */ 
+            __out  IDeviceTopology **ppTopology);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
+            IPart * This,
+            /* [in] */ 
+            __in  DWORD dwClsContext,
+            /* [in] */ 
+            __in  REFIID refiid,
+            /* [iid_is][out] */ 
+            __out_opt  void **ppvObject);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeCallback )( 
+            IPart * This,
+            /* [in] */ 
+            __in  REFGUID riid,
+            /* [in] */ 
+            __in  IControlChangeNotify *pNotify);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeCallback )( 
+            IPart * This,
+            /* [in] */ 
+            __in  IControlChangeNotify *pNotify);
+        
+        END_INTERFACE
+    } IPartVtbl;
+
+    interface IPart
+    {
+        CONST_VTBL struct IPartVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPart_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPart_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPart_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPart_GetName(This,ppwstrName)	\
+    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 
+
+#define IPart_GetLocalId(This,pnId)	\
+    ( (This)->lpVtbl -> GetLocalId(This,pnId) ) 
+
+#define IPart_GetGlobalId(This,ppwstrGlobalId)	\
+    ( (This)->lpVtbl -> GetGlobalId(This,ppwstrGlobalId) ) 
+
+#define IPart_GetPartType(This,pPartType)	\
+    ( (This)->lpVtbl -> GetPartType(This,pPartType) ) 
+
+#define IPart_GetSubType(This,pSubType)	\
+    ( (This)->lpVtbl -> GetSubType(This,pSubType) ) 
+
+#define IPart_GetControlInterfaceCount(This,pCount)	\
+    ( (This)->lpVtbl -> GetControlInterfaceCount(This,pCount) ) 
+
+#define IPart_GetControlInterface(This,nIndex,ppInterfaceDesc)	\
+    ( (This)->lpVtbl -> GetControlInterface(This,nIndex,ppInterfaceDesc) ) 
+
+#define IPart_EnumPartsIncoming(This,ppParts)	\
+    ( (This)->lpVtbl -> EnumPartsIncoming(This,ppParts) ) 
+
+#define IPart_EnumPartsOutgoing(This,ppParts)	\
+    ( (This)->lpVtbl -> EnumPartsOutgoing(This,ppParts) ) 
+
+#define IPart_GetTopologyObject(This,ppTopology)	\
+    ( (This)->lpVtbl -> GetTopologyObject(This,ppTopology) ) 
+
+#define IPart_Activate(This,dwClsContext,refiid,ppvObject)	\
+    ( (This)->lpVtbl -> Activate(This,dwClsContext,refiid,ppvObject) ) 
+
+#define IPart_RegisterControlChangeCallback(This,riid,pNotify)	\
+    ( (This)->lpVtbl -> RegisterControlChangeCallback(This,riid,pNotify) ) 
+
+#define IPart_UnregisterControlChangeCallback(This,pNotify)	\
+    ( (This)->lpVtbl -> UnregisterControlChangeCallback(This,pNotify) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPart_INTERFACE_DEFINED__ */
+
+
+#ifndef __IConnector_INTERFACE_DEFINED__
+#define __IConnector_INTERFACE_DEFINED__
+
+/* interface IConnector */
+/* [object][unique][helpstring][uuid][local] */ 
+
+
+EXTERN_C const IID IID_IConnector;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("9c2c4058-23f5-41de-877a-df3af236a09e")
+    IConnector : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetType( 
+            /* [out] */ 
+            __out  ConnectorType *pType) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
+            /* [out] */ 
+            __out  DataFlow *pFlow) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectTo( 
+            /* [in] */ 
+            __in  IConnector *pConnectTo) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsConnected( 
+            /* [out] */ 
+            __out  BOOL *pbConnected) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectedTo( 
+            /* [out] */ 
+            __out  IConnector **ppConTo) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorIdConnectedTo( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrConnectorId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceIdConnectedTo( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IConnectorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IConnector * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IConnector * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IConnector * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetType )( 
+            IConnector * This,
+            /* [out] */ 
+            __out  ConnectorType *pType);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
+            IConnector * This,
+            /* [out] */ 
+            __out  DataFlow *pFlow);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectTo )( 
+            IConnector * This,
+            /* [in] */ 
+            __in  IConnector *pConnectTo);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
+            IConnector * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
+            IConnector * This,
+            /* [out] */ 
+            __out  BOOL *pbConnected);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedTo )( 
+            IConnector * This,
+            /* [out] */ 
+            __out  IConnector **ppConTo);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorIdConnectedTo )( 
+            IConnector * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrConnectorId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceIdConnectedTo )( 
+            IConnector * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrDeviceId);
+        
+        END_INTERFACE
+    } IConnectorVtbl;
+
+    interface IConnector
+    {
+        CONST_VTBL struct IConnectorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IConnector_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IConnector_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IConnector_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IConnector_GetType(This,pType)	\
+    ( (This)->lpVtbl -> GetType(This,pType) ) 
+
+#define IConnector_GetDataFlow(This,pFlow)	\
+    ( (This)->lpVtbl -> GetDataFlow(This,pFlow) ) 
+
+#define IConnector_ConnectTo(This,pConnectTo)	\
+    ( (This)->lpVtbl -> ConnectTo(This,pConnectTo) ) 
+
+#define IConnector_Disconnect(This)	\
+    ( (This)->lpVtbl -> Disconnect(This) ) 
+
+#define IConnector_IsConnected(This,pbConnected)	\
+    ( (This)->lpVtbl -> IsConnected(This,pbConnected) ) 
+
+#define IConnector_GetConnectedTo(This,ppConTo)	\
+    ( (This)->lpVtbl -> GetConnectedTo(This,ppConTo) ) 
+
+#define IConnector_GetConnectorIdConnectedTo(This,ppwstrConnectorId)	\
+    ( (This)->lpVtbl -> GetConnectorIdConnectedTo(This,ppwstrConnectorId) ) 
+
+#define IConnector_GetDeviceIdConnectedTo(This,ppwstrDeviceId)	\
+    ( (This)->lpVtbl -> GetDeviceIdConnectedTo(This,ppwstrDeviceId) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IConnector_INTERFACE_DEFINED__ */
+
+
+#ifndef __ISubunit_INTERFACE_DEFINED__
+#define __ISubunit_INTERFACE_DEFINED__
+
+/* interface ISubunit */
+/* [object][unique][helpstring][uuid][local] */ 
+
+
+EXTERN_C const IID IID_ISubunit;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("82149A85-DBA6-4487-86BB-EA8F7FEFCC71")
+    ISubunit : public IUnknown
+    {
+    public:
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ISubunitVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ISubunit * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ISubunit * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ISubunit * This);
+        
+        END_INTERFACE
+    } ISubunitVtbl;
+
+    interface ISubunit
+    {
+        CONST_VTBL struct ISubunitVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ISubunit_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ISubunit_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ISubunit_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ISubunit_INTERFACE_DEFINED__ */
+
+
+#ifndef __IControlInterface_INTERFACE_DEFINED__
+#define __IControlInterface_INTERFACE_DEFINED__
+
+/* interface IControlInterface */
+/* [object][unique][helpstring][uuid][local] */ 
+
+
+EXTERN_C const IID IID_IControlInterface;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("45d37c3f-5140-444a-ae24-400789f3cbf3")
+    IControlInterface : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrName) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIID( 
+            /* [out] */ 
+            __out  GUID *pIID) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IControlInterfaceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IControlInterface * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IControlInterface * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IControlInterface * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
+            IControlInterface * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrName);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIID )( 
+            IControlInterface * This,
+            /* [out] */ 
+            __out  GUID *pIID);
+        
+        END_INTERFACE
+    } IControlInterfaceVtbl;
+
+    interface IControlInterface
+    {
+        CONST_VTBL struct IControlInterfaceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IControlInterface_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IControlInterface_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IControlInterface_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IControlInterface_GetName(This,ppwstrName)	\
+    ( (This)->lpVtbl -> GetName(This,ppwstrName) ) 
+
+#define IControlInterface_GetIID(This,pIID)	\
+    ( (This)->lpVtbl -> GetIID(This,pIID) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IControlInterface_INTERFACE_DEFINED__ */
+
+
+#ifndef __IControlChangeNotify_INTERFACE_DEFINED__
+#define __IControlChangeNotify_INTERFACE_DEFINED__
+
+/* interface IControlChangeNotify */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IControlChangeNotify;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A09513ED-C709-4d21-BD7B-5F34C47F3947")
+    IControlChangeNotify : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnNotify( 
+            /* [in] */ 
+            __in  DWORD dwSenderProcessId,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IControlChangeNotifyVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IControlChangeNotify * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IControlChangeNotify * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IControlChangeNotify * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
+            IControlChangeNotify * This,
+            /* [in] */ 
+            __in  DWORD dwSenderProcessId,
+            /* [unique][in] */ 
+            __in_opt  LPCGUID pguidEventContext);
+        
+        END_INTERFACE
+    } IControlChangeNotifyVtbl;
+
+    interface IControlChangeNotify
+    {
+        CONST_VTBL struct IControlChangeNotifyVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IControlChangeNotify_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IControlChangeNotify_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IControlChangeNotify_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IControlChangeNotify_OnNotify(This,dwSenderProcessId,pguidEventContext)	\
+    ( (This)->lpVtbl -> OnNotify(This,dwSenderProcessId,pguidEventContext) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IControlChangeNotify_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDeviceTopology_INTERFACE_DEFINED__
+#define __IDeviceTopology_INTERFACE_DEFINED__
+
+/* interface IDeviceTopology */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IDeviceTopology;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("2A07407E-6497-4A18-9787-32F79BD0D98F")
+    IDeviceTopology : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectorCount( 
+            /* [out] */ 
+            __out  UINT *pCount) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnector( 
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IConnector **ppConnector) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunitCount( 
+            /* [out] */ 
+            __out  UINT *pCount) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubunit( 
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __deref_out  ISubunit **ppSubunit) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartById( 
+            /* [in] */ 
+            __in  UINT nId,
+            /* [out] */ 
+            __deref_out  IPart **ppPart) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceId( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrDeviceId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalPath( 
+            /* [in] */ 
+            __in  IPart *pIPartFrom,
+            /* [in] */ 
+            __in  IPart *pIPartTo,
+            /* [in] */ 
+            __in  BOOL bRejectMixedPaths,
+            /* [out] */ 
+            __deref_out  IPartsList **ppParts) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IDeviceTopologyVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDeviceTopology * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDeviceTopology * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDeviceTopology * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectorCount )( 
+            IDeviceTopology * This,
+            /* [out] */ 
+            __out  UINT *pCount);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnector )( 
+            IDeviceTopology * This,
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __out  IConnector **ppConnector);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunitCount )( 
+            IDeviceTopology * This,
+            /* [out] */ 
+            __out  UINT *pCount);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubunit )( 
+            IDeviceTopology * This,
+            /* [in] */ 
+            __in  UINT nIndex,
+            /* [out] */ 
+            __deref_out  ISubunit **ppSubunit);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartById )( 
+            IDeviceTopology * This,
+            /* [in] */ 
+            __in  UINT nId,
+            /* [out] */ 
+            __deref_out  IPart **ppPart);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
+            IDeviceTopology * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppwstrDeviceId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalPath )( 
+            IDeviceTopology * This,
+            /* [in] */ 
+            __in  IPart *pIPartFrom,
+            /* [in] */ 
+            __in  IPart *pIPartTo,
+            /* [in] */ 
+            __in  BOOL bRejectMixedPaths,
+            /* [out] */ 
+            __deref_out  IPartsList **ppParts);
+        
+        END_INTERFACE
+    } IDeviceTopologyVtbl;
+
+    interface IDeviceTopology
+    {
+        CONST_VTBL struct IDeviceTopologyVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDeviceTopology_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDeviceTopology_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDeviceTopology_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDeviceTopology_GetConnectorCount(This,pCount)	\
+    ( (This)->lpVtbl -> GetConnectorCount(This,pCount) ) 
+
+#define IDeviceTopology_GetConnector(This,nIndex,ppConnector)	\
+    ( (This)->lpVtbl -> GetConnector(This,nIndex,ppConnector) ) 
+
+#define IDeviceTopology_GetSubunitCount(This,pCount)	\
+    ( (This)->lpVtbl -> GetSubunitCount(This,pCount) ) 
+
+#define IDeviceTopology_GetSubunit(This,nIndex,ppSubunit)	\
+    ( (This)->lpVtbl -> GetSubunit(This,nIndex,ppSubunit) ) 
+
+#define IDeviceTopology_GetPartById(This,nId,ppPart)	\
+    ( (This)->lpVtbl -> GetPartById(This,nId,ppPart) ) 
+
+#define IDeviceTopology_GetDeviceId(This,ppwstrDeviceId)	\
+    ( (This)->lpVtbl -> GetDeviceId(This,ppwstrDeviceId) ) 
+
+#define IDeviceTopology_GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts)	\
+    ( (This)->lpVtbl -> GetSignalPath(This,pIPartFrom,pIPartTo,bRejectMixedPaths,ppParts) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IDeviceTopology_INTERFACE_DEFINED__ */
+
+
+
+#ifndef __DevTopologyLib_LIBRARY_DEFINED__
+#define __DevTopologyLib_LIBRARY_DEFINED__
+
+/* library DevTopologyLib */
+/* [helpstring][version][uuid] */ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+EXTERN_C const IID LIBID_DevTopologyLib;
+
+EXTERN_C const CLSID CLSID_DeviceTopology;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("1DF639D0-5EC1-47AA-9379-828DC1AA8C59")
+DeviceTopology;
+#endif
+#endif /* __DevTopologyLib_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/mingw-include/endpointvolume.h
+++ b/src/hostapi/wasapi/mingw-include/endpointvolume.h
@@ -1,620 +1,620 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for endpointvolume.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 500
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __endpointvolume_h__
-#define __endpointvolume_h__
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IAudioEndpointVolumeCallback_FWD_DEFINED__
-#define __IAudioEndpointVolumeCallback_FWD_DEFINED__
-typedef interface IAudioEndpointVolumeCallback IAudioEndpointVolumeCallback;
-#endif 	/* __IAudioEndpointVolumeCallback_FWD_DEFINED__ */
-
-
-#ifndef __IAudioEndpointVolume_FWD_DEFINED__
-#define __IAudioEndpointVolume_FWD_DEFINED__
-typedef interface IAudioEndpointVolume IAudioEndpointVolume;
-#endif 	/* __IAudioEndpointVolume_FWD_DEFINED__ */
-
-
-#ifndef __IAudioMeterInformation_FWD_DEFINED__
-#define __IAudioMeterInformation_FWD_DEFINED__
-typedef interface IAudioMeterInformation IAudioMeterInformation;
-#endif 	/* __IAudioMeterInformation_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "unknwn.h"
-#include "devicetopology.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_endpointvolume_0000_0000 */
-/* [local] */ 
-
-typedef struct AUDIO_VOLUME_NOTIFICATION_DATA
-    {
-    GUID guidEventContext;
-    BOOL bMuted;
-    float fMasterVolume;
-    UINT nChannels;
-    float afChannelVolumes[ 1 ];
-    } 	AUDIO_VOLUME_NOTIFICATION_DATA;
-
-typedef struct AUDIO_VOLUME_NOTIFICATION_DATA *PAUDIO_VOLUME_NOTIFICATION_DATA;
-
-#define   ENDPOINT_HARDWARE_SUPPORT_VOLUME    0x00000001
-#define   ENDPOINT_HARDWARE_SUPPORT_MUTE      0x00000002
-#define   ENDPOINT_HARDWARE_SUPPORT_METER     0x00000004
-
-
-extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
-#define __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
-
-/* interface IAudioEndpointVolumeCallback */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioEndpointVolumeCallback;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("657804FA-D6AD-4496-8A60-352752AF4F89")
-    IAudioEndpointVolumeCallback : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE OnNotify( 
-            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioEndpointVolumeCallbackVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioEndpointVolumeCallback * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioEndpointVolumeCallback * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioEndpointVolumeCallback * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
-            IAudioEndpointVolumeCallback * This,
-            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify);
-        
-        END_INTERFACE
-    } IAudioEndpointVolumeCallbackVtbl;
-
-    interface IAudioEndpointVolumeCallback
-    {
-        CONST_VTBL struct IAudioEndpointVolumeCallbackVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioEndpointVolumeCallback_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioEndpointVolumeCallback_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioEndpointVolumeCallback_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioEndpointVolumeCallback_OnNotify(This,pNotify)	\
-    ( (This)->lpVtbl -> OnNotify(This,pNotify) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioEndpointVolume_INTERFACE_DEFINED__
-#define __IAudioEndpointVolume_INTERFACE_DEFINED__
-
-/* interface IAudioEndpointVolume */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioEndpointVolume;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("5CDF2C82-841E-4546-9722-0CF74078229A")
-    IAudioEndpointVolume : public IUnknown
-    {
-    public:
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeNotify( 
-            /* [in] */ 
-            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeNotify( 
-            /* [in] */ 
-            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
-            /* [out] */ 
-            __out  UINT *pnChannelCount) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevel( 
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevelScalar( 
-            /* [in] */ 
-            __in  float fLevel,
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevel( 
-            /* [out] */ 
-            __out  float *pfLevelDB) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevelScalar( 
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevel( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            float fLevelDB,
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevelScalar( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            float fLevel,
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevel( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevelScalar( 
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevel) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMute( 
-            /* [in] */ 
-            __in  BOOL bMute,
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMute( 
-            /* [out] */ 
-            __out  BOOL *pbMute) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeStepInfo( 
-            /* [out] */ 
-            __out  UINT *pnStep,
-            /* [out] */ 
-            __out  UINT *pnStepCount) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepUp( 
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepDown( 
-            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
-            /* [out] */ 
-            __out  DWORD *pdwHardwareSupportMask) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeRange( 
-            /* [out] */ 
-            __out  float *pflVolumeMindB,
-            /* [out] */ 
-            __out  float *pflVolumeMaxdB,
-            /* [out] */ 
-            __out  float *pflVolumeIncrementdB) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioEndpointVolumeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioEndpointVolume * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioEndpointVolume * This);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeNotify )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  IAudioEndpointVolumeCallback *pNotify);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeNotify )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  IAudioEndpointVolumeCallback *pNotify);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  UINT *pnChannelCount);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevel )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  float fLevelDB,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevelScalar )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  float fLevel,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevel )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevelScalar )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevel )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            float fLevelDB,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevelScalar )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            float fLevel,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevel )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevelDB);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevelScalar )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  UINT nChannel,
-            /* [out] */ 
-            __out  float *pfLevel);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
-            IAudioEndpointVolume * This,
-            /* [in] */ 
-            __in  BOOL bMute,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  BOOL *pbMute);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeStepInfo )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  UINT *pnStep,
-            /* [out] */ 
-            __out  UINT *pnStepCount);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepUp )( 
-            IAudioEndpointVolume * This,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepDown )( 
-            IAudioEndpointVolume * This,
-            /* [unique][in] */ LPCGUID pguidEventContext);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  DWORD *pdwHardwareSupportMask);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeRange )( 
-            IAudioEndpointVolume * This,
-            /* [out] */ 
-            __out  float *pflVolumeMindB,
-            /* [out] */ 
-            __out  float *pflVolumeMaxdB,
-            /* [out] */ 
-            __out  float *pflVolumeIncrementdB);
-        
-        END_INTERFACE
-    } IAudioEndpointVolumeVtbl;
-
-    interface IAudioEndpointVolume
-    {
-        CONST_VTBL struct IAudioEndpointVolumeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioEndpointVolume_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioEndpointVolume_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioEndpointVolume_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioEndpointVolume_RegisterControlChangeNotify(This,pNotify)	\
-    ( (This)->lpVtbl -> RegisterControlChangeNotify(This,pNotify) ) 
-
-#define IAudioEndpointVolume_UnregisterControlChangeNotify(This,pNotify)	\
-    ( (This)->lpVtbl -> UnregisterControlChangeNotify(This,pNotify) ) 
-
-#define IAudioEndpointVolume_GetChannelCount(This,pnChannelCount)	\
-    ( (This)->lpVtbl -> GetChannelCount(This,pnChannelCount) ) 
-
-#define IAudioEndpointVolume_SetMasterVolumeLevel(This,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetMasterVolumeLevel(This,fLevelDB,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_GetMasterVolumeLevel(This,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetMasterVolumeLevel(This,pfLevelDB) ) 
-
-#define IAudioEndpointVolume_GetMasterVolumeLevelScalar(This,pfLevel)	\
-    ( (This)->lpVtbl -> GetMasterVolumeLevelScalar(This,pfLevel) ) 
-
-#define IAudioEndpointVolume_SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_GetChannelVolumeLevel(This,nChannel,pfLevelDB)	\
-    ( (This)->lpVtbl -> GetChannelVolumeLevel(This,nChannel,pfLevelDB) ) 
-
-#define IAudioEndpointVolume_GetChannelVolumeLevelScalar(This,nChannel,pfLevel)	\
-    ( (This)->lpVtbl -> GetChannelVolumeLevelScalar(This,nChannel,pfLevel) ) 
-
-#define IAudioEndpointVolume_SetMute(This,bMute,pguidEventContext)	\
-    ( (This)->lpVtbl -> SetMute(This,bMute,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_GetMute(This,pbMute)	\
-    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 
-
-#define IAudioEndpointVolume_GetVolumeStepInfo(This,pnStep,pnStepCount)	\
-    ( (This)->lpVtbl -> GetVolumeStepInfo(This,pnStep,pnStepCount) ) 
-
-#define IAudioEndpointVolume_VolumeStepUp(This,pguidEventContext)	\
-    ( (This)->lpVtbl -> VolumeStepUp(This,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_VolumeStepDown(This,pguidEventContext)	\
-    ( (This)->lpVtbl -> VolumeStepDown(This,pguidEventContext) ) 
-
-#define IAudioEndpointVolume_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
-    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 
-
-#define IAudioEndpointVolume_GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB)	\
-    ( (This)->lpVtbl -> GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioEndpointVolume_INTERFACE_DEFINED__ */
-
-
-#ifndef __IAudioMeterInformation_INTERFACE_DEFINED__
-#define __IAudioMeterInformation_INTERFACE_DEFINED__
-
-/* interface IAudioMeterInformation */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IAudioMeterInformation;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("C02216F6-8C67-4B5B-9D00-D008E73E0064")
-    IAudioMeterInformation : public IUnknown
-    {
-    public:
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPeakValue( 
-            /* [out] */ float *pfPeak) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMeteringChannelCount( 
-            /* [out] */ 
-            __out  UINT *pnChannelCount) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelsPeakValues( 
-            /* [in] */ UINT32 u32ChannelCount,
-            /* [size_is][out] */ float *afPeakValues) = 0;
-        
-        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
-            /* [out] */ 
-            __out  DWORD *pdwHardwareSupportMask) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IAudioMeterInformationVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IAudioMeterInformation * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IAudioMeterInformation * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IAudioMeterInformation * This);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPeakValue )( 
-            IAudioMeterInformation * This,
-            /* [out] */ float *pfPeak);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringChannelCount )( 
-            IAudioMeterInformation * This,
-            /* [out] */ 
-            __out  UINT *pnChannelCount);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelsPeakValues )( 
-            IAudioMeterInformation * This,
-            /* [in] */ UINT32 u32ChannelCount,
-            /* [size_is][out] */ float *afPeakValues);
-        
-        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
-            IAudioMeterInformation * This,
-            /* [out] */ 
-            __out  DWORD *pdwHardwareSupportMask);
-        
-        END_INTERFACE
-    } IAudioMeterInformationVtbl;
-
-    interface IAudioMeterInformation
-    {
-        CONST_VTBL struct IAudioMeterInformationVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IAudioMeterInformation_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IAudioMeterInformation_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IAudioMeterInformation_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IAudioMeterInformation_GetPeakValue(This,pfPeak)	\
-    ( (This)->lpVtbl -> GetPeakValue(This,pfPeak) ) 
-
-#define IAudioMeterInformation_GetMeteringChannelCount(This,pnChannelCount)	\
-    ( (This)->lpVtbl -> GetMeteringChannelCount(This,pnChannelCount) ) 
-
-#define IAudioMeterInformation_GetChannelsPeakValues(This,u32ChannelCount,afPeakValues)	\
-    ( (This)->lpVtbl -> GetChannelsPeakValues(This,u32ChannelCount,afPeakValues) ) 
-
-#define IAudioMeterInformation_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
-    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IAudioMeterInformation_INTERFACE_DEFINED__ */
-
-
-/* Additional Prototypes for ALL interfaces */
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for endpointvolume.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __endpointvolume_h__
+#define __endpointvolume_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IAudioEndpointVolumeCallback_FWD_DEFINED__
+#define __IAudioEndpointVolumeCallback_FWD_DEFINED__
+typedef interface IAudioEndpointVolumeCallback IAudioEndpointVolumeCallback;
+#endif 	/* __IAudioEndpointVolumeCallback_FWD_DEFINED__ */
+
+
+#ifndef __IAudioEndpointVolume_FWD_DEFINED__
+#define __IAudioEndpointVolume_FWD_DEFINED__
+typedef interface IAudioEndpointVolume IAudioEndpointVolume;
+#endif 	/* __IAudioEndpointVolume_FWD_DEFINED__ */
+
+
+#ifndef __IAudioMeterInformation_FWD_DEFINED__
+#define __IAudioMeterInformation_FWD_DEFINED__
+typedef interface IAudioMeterInformation IAudioMeterInformation;
+#endif 	/* __IAudioMeterInformation_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "unknwn.h"
+#include "devicetopology.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_endpointvolume_0000_0000 */
+/* [local] */ 
+
+typedef struct AUDIO_VOLUME_NOTIFICATION_DATA
+    {
+    GUID guidEventContext;
+    BOOL bMuted;
+    float fMasterVolume;
+    UINT nChannels;
+    float afChannelVolumes[ 1 ];
+    } 	AUDIO_VOLUME_NOTIFICATION_DATA;
+
+typedef struct AUDIO_VOLUME_NOTIFICATION_DATA *PAUDIO_VOLUME_NOTIFICATION_DATA;
+
+#define   ENDPOINT_HARDWARE_SUPPORT_VOLUME    0x00000001
+#define   ENDPOINT_HARDWARE_SUPPORT_MUTE      0x00000002
+#define   ENDPOINT_HARDWARE_SUPPORT_METER     0x00000004
+
+
+extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_endpointvolume_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
+#define __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__
+
+/* interface IAudioEndpointVolumeCallback */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioEndpointVolumeCallback;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("657804FA-D6AD-4496-8A60-352752AF4F89")
+    IAudioEndpointVolumeCallback : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE OnNotify( 
+            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioEndpointVolumeCallbackVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioEndpointVolumeCallback * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioEndpointVolumeCallback * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioEndpointVolumeCallback * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
+            IAudioEndpointVolumeCallback * This,
+            PAUDIO_VOLUME_NOTIFICATION_DATA pNotify);
+        
+        END_INTERFACE
+    } IAudioEndpointVolumeCallbackVtbl;
+
+    interface IAudioEndpointVolumeCallback
+    {
+        CONST_VTBL struct IAudioEndpointVolumeCallbackVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioEndpointVolumeCallback_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioEndpointVolumeCallback_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioEndpointVolumeCallback_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioEndpointVolumeCallback_OnNotify(This,pNotify)	\
+    ( (This)->lpVtbl -> OnNotify(This,pNotify) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioEndpointVolumeCallback_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioEndpointVolume_INTERFACE_DEFINED__
+#define __IAudioEndpointVolume_INTERFACE_DEFINED__
+
+/* interface IAudioEndpointVolume */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioEndpointVolume;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("5CDF2C82-841E-4546-9722-0CF74078229A")
+    IAudioEndpointVolume : public IUnknown
+    {
+    public:
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterControlChangeNotify( 
+            /* [in] */ 
+            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterControlChangeNotify( 
+            /* [in] */ 
+            __in  IAudioEndpointVolumeCallback *pNotify) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelCount( 
+            /* [out] */ 
+            __out  UINT *pnChannelCount) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevel( 
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMasterVolumeLevelScalar( 
+            /* [in] */ 
+            __in  float fLevel,
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevel( 
+            /* [out] */ 
+            __out  float *pfLevelDB) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMasterVolumeLevelScalar( 
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevel( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            float fLevelDB,
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChannelVolumeLevelScalar( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            float fLevel,
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevel( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelVolumeLevelScalar( 
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevel) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMute( 
+            /* [in] */ 
+            __in  BOOL bMute,
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMute( 
+            /* [out] */ 
+            __out  BOOL *pbMute) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeStepInfo( 
+            /* [out] */ 
+            __out  UINT *pnStep,
+            /* [out] */ 
+            __out  UINT *pnStepCount) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepUp( 
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VolumeStepDown( 
+            /* [unique][in] */ LPCGUID pguidEventContext) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
+            /* [out] */ 
+            __out  DWORD *pdwHardwareSupportMask) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolumeRange( 
+            /* [out] */ 
+            __out  float *pflVolumeMindB,
+            /* [out] */ 
+            __out  float *pflVolumeMaxdB,
+            /* [out] */ 
+            __out  float *pflVolumeIncrementdB) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioEndpointVolumeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioEndpointVolume * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioEndpointVolume * This);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterControlChangeNotify )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  IAudioEndpointVolumeCallback *pNotify);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterControlChangeNotify )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  IAudioEndpointVolumeCallback *pNotify);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  UINT *pnChannelCount);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevel )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  float fLevelDB,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMasterVolumeLevelScalar )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  float fLevel,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevel )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMasterVolumeLevelScalar )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevel )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            float fLevelDB,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetChannelVolumeLevelScalar )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            float fLevel,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevel )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevelDB);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelVolumeLevelScalar )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  UINT nChannel,
+            /* [out] */ 
+            __out  float *pfLevel);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMute )( 
+            IAudioEndpointVolume * This,
+            /* [in] */ 
+            __in  BOOL bMute,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMute )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  BOOL *pbMute);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeStepInfo )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  UINT *pnStep,
+            /* [out] */ 
+            __out  UINT *pnStepCount);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepUp )( 
+            IAudioEndpointVolume * This,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VolumeStepDown )( 
+            IAudioEndpointVolume * This,
+            /* [unique][in] */ LPCGUID pguidEventContext);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  DWORD *pdwHardwareSupportMask);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolumeRange )( 
+            IAudioEndpointVolume * This,
+            /* [out] */ 
+            __out  float *pflVolumeMindB,
+            /* [out] */ 
+            __out  float *pflVolumeMaxdB,
+            /* [out] */ 
+            __out  float *pflVolumeIncrementdB);
+        
+        END_INTERFACE
+    } IAudioEndpointVolumeVtbl;
+
+    interface IAudioEndpointVolume
+    {
+        CONST_VTBL struct IAudioEndpointVolumeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioEndpointVolume_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioEndpointVolume_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioEndpointVolume_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioEndpointVolume_RegisterControlChangeNotify(This,pNotify)	\
+    ( (This)->lpVtbl -> RegisterControlChangeNotify(This,pNotify) ) 
+
+#define IAudioEndpointVolume_UnregisterControlChangeNotify(This,pNotify)	\
+    ( (This)->lpVtbl -> UnregisterControlChangeNotify(This,pNotify) ) 
+
+#define IAudioEndpointVolume_GetChannelCount(This,pnChannelCount)	\
+    ( (This)->lpVtbl -> GetChannelCount(This,pnChannelCount) ) 
+
+#define IAudioEndpointVolume_SetMasterVolumeLevel(This,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetMasterVolumeLevel(This,fLevelDB,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetMasterVolumeLevelScalar(This,fLevel,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_GetMasterVolumeLevel(This,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetMasterVolumeLevel(This,pfLevelDB) ) 
+
+#define IAudioEndpointVolume_GetMasterVolumeLevelScalar(This,pfLevel)	\
+    ( (This)->lpVtbl -> GetMasterVolumeLevelScalar(This,pfLevel) ) 
+
+#define IAudioEndpointVolume_SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetChannelVolumeLevel(This,nChannel,fLevelDB,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetChannelVolumeLevelScalar(This,nChannel,fLevel,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_GetChannelVolumeLevel(This,nChannel,pfLevelDB)	\
+    ( (This)->lpVtbl -> GetChannelVolumeLevel(This,nChannel,pfLevelDB) ) 
+
+#define IAudioEndpointVolume_GetChannelVolumeLevelScalar(This,nChannel,pfLevel)	\
+    ( (This)->lpVtbl -> GetChannelVolumeLevelScalar(This,nChannel,pfLevel) ) 
+
+#define IAudioEndpointVolume_SetMute(This,bMute,pguidEventContext)	\
+    ( (This)->lpVtbl -> SetMute(This,bMute,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_GetMute(This,pbMute)	\
+    ( (This)->lpVtbl -> GetMute(This,pbMute) ) 
+
+#define IAudioEndpointVolume_GetVolumeStepInfo(This,pnStep,pnStepCount)	\
+    ( (This)->lpVtbl -> GetVolumeStepInfo(This,pnStep,pnStepCount) ) 
+
+#define IAudioEndpointVolume_VolumeStepUp(This,pguidEventContext)	\
+    ( (This)->lpVtbl -> VolumeStepUp(This,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_VolumeStepDown(This,pguidEventContext)	\
+    ( (This)->lpVtbl -> VolumeStepDown(This,pguidEventContext) ) 
+
+#define IAudioEndpointVolume_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
+    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 
+
+#define IAudioEndpointVolume_GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB)	\
+    ( (This)->lpVtbl -> GetVolumeRange(This,pflVolumeMindB,pflVolumeMaxdB,pflVolumeIncrementdB) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioEndpointVolume_INTERFACE_DEFINED__ */
+
+
+#ifndef __IAudioMeterInformation_INTERFACE_DEFINED__
+#define __IAudioMeterInformation_INTERFACE_DEFINED__
+
+/* interface IAudioMeterInformation */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IAudioMeterInformation;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("C02216F6-8C67-4B5B-9D00-D008E73E0064")
+    IAudioMeterInformation : public IUnknown
+    {
+    public:
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPeakValue( 
+            /* [out] */ float *pfPeak) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMeteringChannelCount( 
+            /* [out] */ 
+            __out  UINT *pnChannelCount) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChannelsPeakValues( 
+            /* [in] */ UINT32 u32ChannelCount,
+            /* [size_is][out] */ float *afPeakValues) = 0;
+        
+        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHardwareSupport( 
+            /* [out] */ 
+            __out  DWORD *pdwHardwareSupportMask) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IAudioMeterInformationVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IAudioMeterInformation * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IAudioMeterInformation * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IAudioMeterInformation * This);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPeakValue )( 
+            IAudioMeterInformation * This,
+            /* [out] */ float *pfPeak);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMeteringChannelCount )( 
+            IAudioMeterInformation * This,
+            /* [out] */ 
+            __out  UINT *pnChannelCount);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetChannelsPeakValues )( 
+            IAudioMeterInformation * This,
+            /* [in] */ UINT32 u32ChannelCount,
+            /* [size_is][out] */ float *afPeakValues);
+        
+        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHardwareSupport )( 
+            IAudioMeterInformation * This,
+            /* [out] */ 
+            __out  DWORD *pdwHardwareSupportMask);
+        
+        END_INTERFACE
+    } IAudioMeterInformationVtbl;
+
+    interface IAudioMeterInformation
+    {
+        CONST_VTBL struct IAudioMeterInformationVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IAudioMeterInformation_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IAudioMeterInformation_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IAudioMeterInformation_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IAudioMeterInformation_GetPeakValue(This,pfPeak)	\
+    ( (This)->lpVtbl -> GetPeakValue(This,pfPeak) ) 
+
+#define IAudioMeterInformation_GetMeteringChannelCount(This,pnChannelCount)	\
+    ( (This)->lpVtbl -> GetMeteringChannelCount(This,pnChannelCount) ) 
+
+#define IAudioMeterInformation_GetChannelsPeakValues(This,u32ChannelCount,afPeakValues)	\
+    ( (This)->lpVtbl -> GetChannelsPeakValues(This,u32ChannelCount,afPeakValues) ) 
+
+#define IAudioMeterInformation_QueryHardwareSupport(This,pdwHardwareSupportMask)	\
+    ( (This)->lpVtbl -> QueryHardwareSupport(This,pdwHardwareSupportMask) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IAudioMeterInformation_INTERFACE_DEFINED__ */
+
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/mingw-include/functiondiscoverykeys.h
+++ b/src/hostapi/wasapi/mingw-include/functiondiscoverykeys.h
@@ -1,255 +1,255 @@
-#pragma once
-
-#if __GNUC__ >=3
-#pragma GCC system_header
-#endif
-
-#ifndef DEFINE_API_PKEY
-#include <propkey.h>
-#endif
-
-#include <FunctionDiscoveryKeys_devpkey.h>
-
-// FMTID_FD = {904b03a2-471d-423c-a584-f3483238a146}
-DEFINE_GUID(FMTID_FD, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46);
-DEFINE_API_PKEY(PKEY_FD_Visibility, VisibilityFlags, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000001); //    VT_UINT
-#define FD_Visibility_Default   0
-#define FD_Visibility_Hidden    1
-
-// FMTID_Device = {78C34FC8-104A-4aca-9EA4-524D52996E57}
-DEFINE_GUID(FMTID_Device, 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57);
-
-DEFINE_API_PKEY(PKEY_Device_NotPresent,     DeviceNotPresent   , 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000002); //    VT_UINT
-DEFINE_API_PKEY(PKEY_Device_QueueSize,      DeviceQueueSize    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000024); //    VT_UI4
-DEFINE_API_PKEY(PKEY_Device_Status,         DeviceStatus       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000025); //    VT_LPWSTR
-DEFINE_API_PKEY(PKEY_Device_Comment,        DeviceComment      , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000026); //    VT_LPWSTR
-DEFINE_API_PKEY(PKEY_Device_Model,          DeviceModel        , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000027); //    VT_LPWSTR
-
-//  Name:     System.Device.BIOSVersion -- PKEY_Device_BIOSVersion
-//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_BSTR.
-//  FormatID: EAEE7F1D-6A33-44D1-9441-5F46DEF23198, 9
-DEFINE_PROPERTYKEY(PKEY_Device_BIOSVersion, 0xEAEE7F1D, 0x6A33, 0x44D1, 0x94, 0x41, 0x5F, 0x46, 0xDE, 0xF2, 0x31, 0x98, 9);
-
-DEFINE_API_PKEY(PKEY_Write_Time,            WriteTime          , 0xf53b7e1c, 0x77e0, 0x4450, 0x8c, 0x5f, 0xa7, 0x6c, 0xc7, 0xfd, 0xe0, 0x58, 0x00000100); //    VT_FILETIME
-
-#ifdef FD_XP
-DEFINE_API_PKEY(PKEY_Device_InstanceId, DeviceInstanceId   , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000100); //    VT_LPWSTR
-#endif
-DEFINE_API_PKEY(PKEY_Device_Interface,  DeviceInterface    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000101); //    VT_CLSID
-
-DEFINE_API_PKEY(PKEY_ExposedIIDs,           ExposedIIDs       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003002); //  VT_VECTOR | VT_CLSID
-DEFINE_API_PKEY(PKEY_ExposedCLSIDs,         ExposedCLSIDs     , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003003); //  VT_VECTOR | VT_CLSID
-DEFINE_API_PKEY(PKEY_InstanceValidatorClsid,InstanceValidator , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003004); // VT_CLSID
-
-// FMTID_WSD = {92506491-FF95-4724-A05A-5B81885A7C92}
-DEFINE_GUID(FMTID_WSD, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92);
-
-DEFINE_API_PKEY(PKEY_WSD_AddressURI, WSD_AddressURI, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001000);   // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_WSD_Types, WSD_Types, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001001); // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_WSD_Scopes, WSD_Scopes, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001002);   // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_WSD_MetadataVersion, WSD_MetadataVersion, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001003); //VT_UI8
-DEFINE_API_PKEY(PKEY_WSD_AppSeqInstanceID, WSD_AppSeqInstanceID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001004);   // VT_UI8
-DEFINE_API_PKEY(PKEY_WSD_AppSeqSessionID, WSD_AppSeqSessionID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001005); // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_WSD_AppSeqMessageNumber, WSD_AppSeqMessageNumber, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001006); // VT_UI8
-DEFINE_API_PKEY(PKEY_WSD_XAddrs, WSD_XAddrs, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00002000); // VT_LPWSTR or VT_VECTOR | VT_LPWSTR
-
-DEFINE_API_PKEY(PKEY_WSD_MetadataClean, WSD_MetadataClean, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000001);   // VT_BOOL
-DEFINE_API_PKEY(PKEY_WSD_ServiceInfo, WSD_ServiceInfo, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000002);   // VT_VECTOR|VT_VARIANT (variants are VT_UNKNOWN)
-
-DEFINE_API_PKEY(PKEY_PUBSVCS_TYPE, PUBSVCS_TYPE, 0xF1B88AD3, 0x109C, 0x4FD2, 0xBA, 0x3F, 0x53, 0x5A, 0x76, 0x5F, 0x82, 0xF4, 0x00005001); // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_PUBSVCS_SCOPE, PUBSVCS_SCOPE, 0x2AE2B567, 0xEECB, 0x4A3E, 0xB7, 0x53, 0x54, 0xC7, 0x25, 0x49, 0x43, 0x66, 0x00005002);   // VT_LPWSTR | VT_VECTOR
-DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA, PUBSVCS_METADATA, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005003); // VT_LPWSTR
-DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA_VERSION, PUBSVCS_METADATA_VERSION, 0xC0C96C15, 0x1823, 0x4E5B, 0x93, 0x48, 0xE8, 0x25, 0x19, 0x92, 0x3F, 0x04, 0x00005004); // VT_UI8
-DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_ALLOWED, PUBSVCS_NETWORK_PROFILES_ALLOWED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005005); // VT_VECTOR | VT_LPWSTR
-DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DENIED, PUBSVCS_NETWORK_PROFILES_DENIED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005006); // VT_VECTOR | VT_LPWSTR
-DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DEFAULT, PUBSVCS_NETWORK_PROFILES_DEFAULT, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005007); // VT_BOOL
-
-// FMTID_PNPX = {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}
-DEFINE_GUID(FMTID_PNPX, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD);
-        // from Discovery messages
-DEFINE_PROPERTYKEY(PKEY_PNPX_GlobalIdentity, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001000);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_Types, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001001);   // VT_LPWSTR | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_PNPX_Scopes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001002);   // VT_LPWSTR | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_PNPX_XAddrs, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001003);   // VT_LPWSTR | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_PNPX_MetadataVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001004);   // VT_UI8
-DEFINE_PROPERTYKEY(PKEY_PNPX_ID, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001005);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_RootProxy, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_BOOL
-
-        // for Directed Discovery
-DEFINE_PROPERTYKEY(PKEY_PNPX_RemoteAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_LPWSTR
-
-        // from ThisModel metadata
-DEFINE_PROPERTYKEY(PKEY_PNPX_Manufacturer, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002000);   // VT_LPWSTR (localizable)
-DEFINE_PROPERTYKEY(PKEY_PNPX_ManufacturerUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002001);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_ModelName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002002);   // VT_LPWSTR (localizable)
-DEFINE_PROPERTYKEY(PKEY_PNPX_ModelNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002003);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_ModelUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002004);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_Upc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002005);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_PresentationUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002006);   // VT_LPWSTR
-        // from ThisDevice metadata
-DEFINE_PROPERTYKEY(PKEY_PNPX_FriendlyName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003000);   // VT_LPWSTR (localizable)
-DEFINE_PROPERTYKEY(PKEY_PNPX_FirmwareVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003001);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_SerialNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003002);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003004);   // VT_LPWSTR | VT_VECTOR
-        // DeviceCategory values
-#define PNPX_DEVICECATEGORY_COMPUTER                            L"Computers"
-#define PNPX_DEVICECATEGORY_INPUTDEVICE                         L"Input"
-#define PNPX_DEVICECATEGORY_PRINTER                             L"Printers"
-#define PNPX_DEVICECATEGORY_SCANNER                             L"Scanners"
-#define PNPX_DEVICECATEGORY_FAX                                 L"FAX"
-#define PNPX_DEVICECATEGORY_MFP                                 L"MFP"
-#define PNPX_DEVICECATEGORY_CAMERA                              L"Cameras"
-#define PNPX_DEVICECATEGORY_STORAGE                             L"Storage"
-#define PNPX_DEVICECATEGORY_NETWORK_INFRASTRUCTURE              L"NetworkInfrastructure"
-#define PNPX_DEVICECATEGORY_DISPLAYS                            L"Displays"
-#define PNPX_DEVICECATEGORY_MULTIMEDIA_DEVICE                   L"MediaDevices"
-#define PNPX_DEVICECATEGORY_GAMING_DEVICE                       L"Gaming"
-#define PNPX_DEVICECATEGORY_TELEPHONE                           L"Phones"
-#define PNPX_DEVICECATEGORY_HOME_AUTOMATION_SYSTEM              L"HomeAutomation"
-#define PNPX_DEVICECATEGORY_HOME_SECURITY_SYSTEM                L"HomeSecurity"
-#define PNPX_DEVICECATEGORY_OTHER                               L"Other"
-DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory_Desc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003005);   // VT_LPWSTR | VT_VECTOR
-
-DEFINE_PROPERTYKEY(PKEY_PNPX_PhysicalAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003006);   // VT_UI1 | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceLuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003007);   // VT_UI8
-DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceGuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003008);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_IpAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003009);   // VT_LPWSTR | VT_VECTOR
-        // from Relationship metadata
-DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004000);   // VT_LPWSTR | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004001);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceTypes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004002);   // VT_LPWSTR | VT_VECTOR
-        // Association DB PKEYs
-DEFINE_API_PKEY(PKEY_PNPX_Devnode, PnPXDevNode, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000001); // VT_BOOL
-DEFINE_API_PKEY(PKEY_PNPX_AssociationState, AssociationState, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000002); // VT_UINT
-DEFINE_API_PKEY(PKEY_PNPX_AssociatedInstanceId, AssociatedInstanceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000003); // VT_LPWSTR
-        // for Computer Discovery
-DEFINE_PROPERTYKEY(PKEY_PNPX_DomainName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005000);   // VT_LPWSTR
-// Use PKEY_ComputerName (propkey.h) DEFINE_PROPERTYKEY(PKEY_PNPX_MachineName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005001);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_PNPX_ShareName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005002);   // VT_LPWSTR
-
-    // SSDP Provider custom properties
-DEFINE_PROPERTYKEY(PKEY_SSDP_AltLocationInfo, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006000);   // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_SSDP_DevLifeTime, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006001);   // VT_UI4
-DEFINE_PROPERTYKEY(PKEY_SSDP_NetworkInterface, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006002);   // VT_BOOL
-
-// FMTID_PNPXDynamicProperty = {4FC5077E-B686-44BE-93E3-86CAFE368CCD}
-DEFINE_GUID(FMTID_PNPXDynamicProperty, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD);
-
-DEFINE_PROPERTYKEY(PKEY_PNPX_Installable, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000001); // VT_BOOL
-DEFINE_PROPERTYKEY(PKEY_PNPX_Associated, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000002); // VT_BOOL
-// PKEY_PNPX_Installed to be deprecated in Longhorn Server timeframe
-// this PKEY really represents Associated state
-#define PKEY_PNPX_Installed PKEY_PNPX_Associated    // Deprecated! Please use PKEY_PNPX_Associated
-DEFINE_PROPERTYKEY(PKEY_PNPX_CompatibleTypes, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000003); // VT_LPWSTR | VT_VECTOR
-
-    // WNET Provider properties
-DEFINE_PROPERTYKEY(PKEY_WNET_Scope, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000001); // VT_UINT
-DEFINE_PROPERTYKEY(PKEY_WNET_Type, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000002); // VT_UINT
-DEFINE_PROPERTYKEY(PKEY_WNET_DisplayType, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000003); // VT_UINT
-DEFINE_PROPERTYKEY(PKEY_WNET_Usage, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000004); // VT_UINT
-DEFINE_PROPERTYKEY(PKEY_WNET_LocalName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000005); // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_WNET_RemoteName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000006); // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_WNET_Comment, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000007); // VT_LPWSTR
-DEFINE_PROPERTYKEY(PKEY_WNET_Provider, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000008); // VT_LPWSTR
-
-
-    // WCN Provider properties
-
-DEFINE_PROPERTYKEY(PKEY_WCN_Version, 0x88190b80, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000001); // VT_UI1
-DEFINE_PROPERTYKEY(PKEY_WCN_RequestType, 0x88190b81, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000002); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_AuthType, 0x88190b82, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000003); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_EncryptType, 0x88190b83, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000004); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_ConnType, 0x88190b84, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000005); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_ConfigMethods, 0x88190b85, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000006); // VT_INT
-// map WCN DeviceType to PKEY_PNPX_DeviceCategory
-//DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType, 0x88190b86, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000007); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_RfBand, 0x88190b87, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000008); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_AssocState, 0x88190b88, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000009); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_ConfigError, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000a); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_ConfigState, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000b); // VT_UI1
-DEFINE_PROPERTYKEY(PKEY_WCN_DevicePasswordId, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000c); // VT_INT
-DEFINE_PROPERTYKEY(PKEY_WCN_OSVersion, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000d); // VT_UINT
-DEFINE_PROPERTYKEY(PKEY_WCN_VendorExtension, 0x88190b8a, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000e); // VT_UI1 | VT_VECTOR
-DEFINE_PROPERTYKEY(PKEY_WCN_RegistrarType, 0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000f); // VT_INT
-
-//-----------------------------------------------------------------------------
-// DriverPackage properties
-
-#define PKEY_DriverPackage_Model                PKEY_DrvPkg_Model
-#define PKEY_DriverPackage_VendorWebSite        PKEY_DrvPkg_VendorWebSite
-#define PKEY_DriverPackage_DetailedDescription  PKEY_DrvPkg_DetailedDescription
-#define PKEY_DriverPackage_DocumentationLink    PKEY_DrvPkg_DocumentationLink
-#define PKEY_DriverPackage_Icon                 PKEY_DrvPkg_Icon
-#define PKEY_DriverPackage_BrandingIcon         PKEY_DrvPkg_BrandingIcon
-
-//-----------------------------------------------------------------------------
-// Hardware properties
-
-DEFINE_PROPERTYKEY(PKEY_Hardware_Devinst, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4097);
-
-//  Name:     System.Hardware.DisplayAttribute -- PKEY_Hardware_DisplayAttribute
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 5
-DEFINE_PROPERTYKEY(PKEY_Hardware_DisplayAttribute, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 5);
-
-//  Name:     System.Hardware.DriverDate -- PKEY_Hardware_DriverDate
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 11
-DEFINE_PROPERTYKEY(PKEY_Hardware_DriverDate, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 11);
-
-//  Name:     System.Hardware.DriverProvider -- PKEY_Hardware_DriverProvider
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 10
-DEFINE_PROPERTYKEY(PKEY_Hardware_DriverProvider, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 10);
-
-//  Name:     System.Hardware.DriverVersion -- PKEY_Hardware_DriverVersion
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 9
-DEFINE_PROPERTYKEY(PKEY_Hardware_DriverVersion, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 9);
-
-//  Name:     System.Hardware.Function -- PKEY_Hardware_Function
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4099
-DEFINE_PROPERTYKEY(PKEY_Hardware_Function, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4099);
-
-//  Name:     System.Hardware.Icon -- PKEY_Hardware_Icon
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 3
-DEFINE_PROPERTYKEY(PKEY_Hardware_Icon, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 3);
-
-//  Name:     System.Hardware.Image -- PKEY_Hardware_Image
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4098
-DEFINE_PROPERTYKEY(PKEY_Hardware_Image, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4098);
-
-//  Name:     System.Hardware.Manufacturer -- PKEY_Hardware_Manufacturer
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 6
-DEFINE_PROPERTYKEY(PKEY_Hardware_Manufacturer, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 6);
-
-//  Name:     System.Hardware.Model -- PKEY_Hardware_Model
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 7
-DEFINE_PROPERTYKEY(PKEY_Hardware_Model, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 7);
-
-//  Name:     System.Hardware.Name -- PKEY_Hardware_Name
-//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 2
-DEFINE_PROPERTYKEY(PKEY_Hardware_Name, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 2);
-
-//  Name:     System.Hardware.SerialNumber -- PKEY_Hardware_SerialNumber
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 8
-DEFINE_PROPERTYKEY(PKEY_Hardware_SerialNumber, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 8);
-
-//  Name:     System.Hardware.ShellAttributes -- PKEY_Hardware_ShellAttributes
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4100
-DEFINE_PROPERTYKEY(PKEY_Hardware_ShellAttributes, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4100);
-
-//  Name:     System.Hardware.Status -- PKEY_Hardware_Status
-//  Type:     Unspecified -- VT_NULL
-//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4096
-DEFINE_PROPERTYKEY(PKEY_Hardware_Status, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4096);
-
-
+#pragma once
+
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+#ifndef DEFINE_API_PKEY
+#include <propkey.h>
+#endif
+
+#include <FunctionDiscoveryKeys_devpkey.h>
+
+// FMTID_FD = {904b03a2-471d-423c-a584-f3483238a146}
+DEFINE_GUID(FMTID_FD, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46);
+DEFINE_API_PKEY(PKEY_FD_Visibility, VisibilityFlags, 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000001); //    VT_UINT
+#define FD_Visibility_Default   0
+#define FD_Visibility_Hidden    1
+
+// FMTID_Device = {78C34FC8-104A-4aca-9EA4-524D52996E57}
+DEFINE_GUID(FMTID_Device, 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57);
+
+DEFINE_API_PKEY(PKEY_Device_NotPresent,     DeviceNotPresent   , 0x904b03a2, 0x471d, 0x423c, 0xa5, 0x84, 0xf3, 0x48, 0x32, 0x38, 0xa1, 0x46, 0x00000002); //    VT_UINT
+DEFINE_API_PKEY(PKEY_Device_QueueSize,      DeviceQueueSize    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000024); //    VT_UI4
+DEFINE_API_PKEY(PKEY_Device_Status,         DeviceStatus       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000025); //    VT_LPWSTR
+DEFINE_API_PKEY(PKEY_Device_Comment,        DeviceComment      , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000026); //    VT_LPWSTR
+DEFINE_API_PKEY(PKEY_Device_Model,          DeviceModel        , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000027); //    VT_LPWSTR
+
+//  Name:     System.Device.BIOSVersion -- PKEY_Device_BIOSVersion
+//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_BSTR.
+//  FormatID: EAEE7F1D-6A33-44D1-9441-5F46DEF23198, 9
+DEFINE_PROPERTYKEY(PKEY_Device_BIOSVersion, 0xEAEE7F1D, 0x6A33, 0x44D1, 0x94, 0x41, 0x5F, 0x46, 0xDE, 0xF2, 0x31, 0x98, 9);
+
+DEFINE_API_PKEY(PKEY_Write_Time,            WriteTime          , 0xf53b7e1c, 0x77e0, 0x4450, 0x8c, 0x5f, 0xa7, 0x6c, 0xc7, 0xfd, 0xe0, 0x58, 0x00000100); //    VT_FILETIME
+
+#ifdef FD_XP
+DEFINE_API_PKEY(PKEY_Device_InstanceId, DeviceInstanceId   , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000100); //    VT_LPWSTR
+#endif
+DEFINE_API_PKEY(PKEY_Device_Interface,  DeviceInterface    , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00000101); //    VT_CLSID
+
+DEFINE_API_PKEY(PKEY_ExposedIIDs,           ExposedIIDs       , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003002); //  VT_VECTOR | VT_CLSID
+DEFINE_API_PKEY(PKEY_ExposedCLSIDs,         ExposedCLSIDs     , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003003); //  VT_VECTOR | VT_CLSID
+DEFINE_API_PKEY(PKEY_InstanceValidatorClsid,InstanceValidator , 0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 0x00003004); // VT_CLSID
+
+// FMTID_WSD = {92506491-FF95-4724-A05A-5B81885A7C92}
+DEFINE_GUID(FMTID_WSD, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92);
+
+DEFINE_API_PKEY(PKEY_WSD_AddressURI, WSD_AddressURI, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001000);   // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_WSD_Types, WSD_Types, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001001); // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_WSD_Scopes, WSD_Scopes, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001002);   // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_WSD_MetadataVersion, WSD_MetadataVersion, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001003); //VT_UI8
+DEFINE_API_PKEY(PKEY_WSD_AppSeqInstanceID, WSD_AppSeqInstanceID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001004);   // VT_UI8
+DEFINE_API_PKEY(PKEY_WSD_AppSeqSessionID, WSD_AppSeqSessionID, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001005); // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_WSD_AppSeqMessageNumber, WSD_AppSeqMessageNumber, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00001006); // VT_UI8
+DEFINE_API_PKEY(PKEY_WSD_XAddrs, WSD_XAddrs, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00002000); // VT_LPWSTR or VT_VECTOR | VT_LPWSTR
+
+DEFINE_API_PKEY(PKEY_WSD_MetadataClean, WSD_MetadataClean, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000001);   // VT_BOOL
+DEFINE_API_PKEY(PKEY_WSD_ServiceInfo, WSD_ServiceInfo, 0x92506491, 0xFF95, 0x4724, 0xA0, 0x5A, 0x5B, 0x81, 0x88, 0x5A, 0x7C, 0x92, 0x00000002);   // VT_VECTOR|VT_VARIANT (variants are VT_UNKNOWN)
+
+DEFINE_API_PKEY(PKEY_PUBSVCS_TYPE, PUBSVCS_TYPE, 0xF1B88AD3, 0x109C, 0x4FD2, 0xBA, 0x3F, 0x53, 0x5A, 0x76, 0x5F, 0x82, 0xF4, 0x00005001); // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_PUBSVCS_SCOPE, PUBSVCS_SCOPE, 0x2AE2B567, 0xEECB, 0x4A3E, 0xB7, 0x53, 0x54, 0xC7, 0x25, 0x49, 0x43, 0x66, 0x00005002);   // VT_LPWSTR | VT_VECTOR
+DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA, PUBSVCS_METADATA, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005003); // VT_LPWSTR
+DEFINE_API_PKEY(PKEY_PUBSVCS_METADATA_VERSION, PUBSVCS_METADATA_VERSION, 0xC0C96C15, 0x1823, 0x4E5B, 0x93, 0x48, 0xE8, 0x25, 0x19, 0x92, 0x3F, 0x04, 0x00005004); // VT_UI8
+DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_ALLOWED, PUBSVCS_NETWORK_PROFILES_ALLOWED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005005); // VT_VECTOR | VT_LPWSTR
+DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DENIED, PUBSVCS_NETWORK_PROFILES_DENIED, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005006); // VT_VECTOR | VT_LPWSTR
+DEFINE_API_PKEY(PKEY_PUBSVCS_NETWORK_PROFILES_DEFAULT, PUBSVCS_NETWORK_PROFILES_DEFAULT, 0x63C6D5B8, 0xF73A, 0x4ACA, 0x96, 0x7E, 0x0C, 0xC7, 0x87, 0xE0, 0xB5, 0x59, 0x00005007); // VT_BOOL
+
+// FMTID_PNPX = {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}
+DEFINE_GUID(FMTID_PNPX, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD);
+        // from Discovery messages
+DEFINE_PROPERTYKEY(PKEY_PNPX_GlobalIdentity, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001000);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_Types, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001001);   // VT_LPWSTR | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_PNPX_Scopes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001002);   // VT_LPWSTR | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_PNPX_XAddrs, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001003);   // VT_LPWSTR | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_PNPX_MetadataVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001004);   // VT_UI8
+DEFINE_PROPERTYKEY(PKEY_PNPX_ID, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001005);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_RootProxy, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_BOOL
+
+        // for Directed Discovery
+DEFINE_PROPERTYKEY(PKEY_PNPX_RemoteAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00001006);   // VT_LPWSTR
+
+        // from ThisModel metadata
+DEFINE_PROPERTYKEY(PKEY_PNPX_Manufacturer, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002000);   // VT_LPWSTR (localizable)
+DEFINE_PROPERTYKEY(PKEY_PNPX_ManufacturerUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002001);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_ModelName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002002);   // VT_LPWSTR (localizable)
+DEFINE_PROPERTYKEY(PKEY_PNPX_ModelNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002003);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_ModelUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002004);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_Upc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002005);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_PresentationUrl, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00002006);   // VT_LPWSTR
+        // from ThisDevice metadata
+DEFINE_PROPERTYKEY(PKEY_PNPX_FriendlyName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003000);   // VT_LPWSTR (localizable)
+DEFINE_PROPERTYKEY(PKEY_PNPX_FirmwareVersion, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003001);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_SerialNumber, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003002);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003004);   // VT_LPWSTR | VT_VECTOR
+        // DeviceCategory values
+#define PNPX_DEVICECATEGORY_COMPUTER                            L"Computers"
+#define PNPX_DEVICECATEGORY_INPUTDEVICE                         L"Input"
+#define PNPX_DEVICECATEGORY_PRINTER                             L"Printers"
+#define PNPX_DEVICECATEGORY_SCANNER                             L"Scanners"
+#define PNPX_DEVICECATEGORY_FAX                                 L"FAX"
+#define PNPX_DEVICECATEGORY_MFP                                 L"MFP"
+#define PNPX_DEVICECATEGORY_CAMERA                              L"Cameras"
+#define PNPX_DEVICECATEGORY_STORAGE                             L"Storage"
+#define PNPX_DEVICECATEGORY_NETWORK_INFRASTRUCTURE              L"NetworkInfrastructure"
+#define PNPX_DEVICECATEGORY_DISPLAYS                            L"Displays"
+#define PNPX_DEVICECATEGORY_MULTIMEDIA_DEVICE                   L"MediaDevices"
+#define PNPX_DEVICECATEGORY_GAMING_DEVICE                       L"Gaming"
+#define PNPX_DEVICECATEGORY_TELEPHONE                           L"Phones"
+#define PNPX_DEVICECATEGORY_HOME_AUTOMATION_SYSTEM              L"HomeAutomation"
+#define PNPX_DEVICECATEGORY_HOME_SECURITY_SYSTEM                L"HomeSecurity"
+#define PNPX_DEVICECATEGORY_OTHER                               L"Other"
+DEFINE_PROPERTYKEY(PKEY_PNPX_DeviceCategory_Desc, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003005);   // VT_LPWSTR | VT_VECTOR
+
+DEFINE_PROPERTYKEY(PKEY_PNPX_PhysicalAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003006);   // VT_UI1 | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceLuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003007);   // VT_UI8
+DEFINE_PROPERTYKEY(PKEY_PNPX_NetworkInterfaceGuid, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003008);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_IpAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00003009);   // VT_LPWSTR | VT_VECTOR
+        // from Relationship metadata
+DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceAddress, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004000);   // VT_LPWSTR | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004001);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_ServiceTypes, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00004002);   // VT_LPWSTR | VT_VECTOR
+        // Association DB PKEYs
+DEFINE_API_PKEY(PKEY_PNPX_Devnode, PnPXDevNode, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000001); // VT_BOOL
+DEFINE_API_PKEY(PKEY_PNPX_AssociationState, AssociationState, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000002); // VT_UINT
+DEFINE_API_PKEY(PKEY_PNPX_AssociatedInstanceId, AssociatedInstanceId, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00000003); // VT_LPWSTR
+        // for Computer Discovery
+DEFINE_PROPERTYKEY(PKEY_PNPX_DomainName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005000);   // VT_LPWSTR
+// Use PKEY_ComputerName (propkey.h) DEFINE_PROPERTYKEY(PKEY_PNPX_MachineName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005001);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_PNPX_ShareName, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00005002);   // VT_LPWSTR
+
+    // SSDP Provider custom properties
+DEFINE_PROPERTYKEY(PKEY_SSDP_AltLocationInfo, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006000);   // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_SSDP_DevLifeTime, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006001);   // VT_UI4
+DEFINE_PROPERTYKEY(PKEY_SSDP_NetworkInterface, 0x656A3BB3, 0xECC0, 0x43FD, 0x84, 0x77, 0x4A, 0xE0, 0x40, 0x4A, 0x96, 0xCD, 0x00006002);   // VT_BOOL
+
+// FMTID_PNPXDynamicProperty = {4FC5077E-B686-44BE-93E3-86CAFE368CCD}
+DEFINE_GUID(FMTID_PNPXDynamicProperty, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD);
+
+DEFINE_PROPERTYKEY(PKEY_PNPX_Installable, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000001); // VT_BOOL
+DEFINE_PROPERTYKEY(PKEY_PNPX_Associated, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000002); // VT_BOOL
+// PKEY_PNPX_Installed to be deprecated in Longhorn Server timeframe
+// this PKEY really represents Associated state
+#define PKEY_PNPX_Installed PKEY_PNPX_Associated    // Deprecated! Please use PKEY_PNPX_Associated
+DEFINE_PROPERTYKEY(PKEY_PNPX_CompatibleTypes, 0x4FC5077E, 0xB686, 0x44BE, 0x93, 0xE3, 0x86, 0xCA, 0xFE, 0x36, 0x8C, 0xCD, 0x00000003); // VT_LPWSTR | VT_VECTOR
+
+    // WNET Provider properties
+DEFINE_PROPERTYKEY(PKEY_WNET_Scope, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000001); // VT_UINT
+DEFINE_PROPERTYKEY(PKEY_WNET_Type, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000002); // VT_UINT
+DEFINE_PROPERTYKEY(PKEY_WNET_DisplayType, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000003); // VT_UINT
+DEFINE_PROPERTYKEY(PKEY_WNET_Usage, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000004); // VT_UINT
+DEFINE_PROPERTYKEY(PKEY_WNET_LocalName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000005); // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_WNET_RemoteName, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000006); // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_WNET_Comment, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000007); // VT_LPWSTR
+DEFINE_PROPERTYKEY(PKEY_WNET_Provider, 0xdebda43a, 0x37b3, 0x4383, 0x91, 0xE7, 0x44, 0x98, 0xda, 0x29, 0x95, 0xab, 0x00000008); // VT_LPWSTR
+
+
+    // WCN Provider properties
+
+DEFINE_PROPERTYKEY(PKEY_WCN_Version, 0x88190b80, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000001); // VT_UI1
+DEFINE_PROPERTYKEY(PKEY_WCN_RequestType, 0x88190b81, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000002); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_AuthType, 0x88190b82, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000003); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_EncryptType, 0x88190b83, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000004); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_ConnType, 0x88190b84, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000005); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_ConfigMethods, 0x88190b85, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000006); // VT_INT
+// map WCN DeviceType to PKEY_PNPX_DeviceCategory
+//DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType, 0x88190b86, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000007); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_RfBand, 0x88190b87, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000008); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_AssocState, 0x88190b88, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000009); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_ConfigError, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000a); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_ConfigState, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000b); // VT_UI1
+DEFINE_PROPERTYKEY(PKEY_WCN_DevicePasswordId, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000c); // VT_INT
+DEFINE_PROPERTYKEY(PKEY_WCN_OSVersion, 0x88190b89, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000d); // VT_UINT
+DEFINE_PROPERTYKEY(PKEY_WCN_VendorExtension, 0x88190b8a, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000e); // VT_UI1 | VT_VECTOR
+DEFINE_PROPERTYKEY(PKEY_WCN_RegistrarType, 0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x0000000f); // VT_INT
+
+//-----------------------------------------------------------------------------
+// DriverPackage properties
+
+#define PKEY_DriverPackage_Model                PKEY_DrvPkg_Model
+#define PKEY_DriverPackage_VendorWebSite        PKEY_DrvPkg_VendorWebSite
+#define PKEY_DriverPackage_DetailedDescription  PKEY_DrvPkg_DetailedDescription
+#define PKEY_DriverPackage_DocumentationLink    PKEY_DrvPkg_DocumentationLink
+#define PKEY_DriverPackage_Icon                 PKEY_DrvPkg_Icon
+#define PKEY_DriverPackage_BrandingIcon         PKEY_DrvPkg_BrandingIcon
+
+//-----------------------------------------------------------------------------
+// Hardware properties
+
+DEFINE_PROPERTYKEY(PKEY_Hardware_Devinst, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4097);
+
+//  Name:     System.Hardware.DisplayAttribute -- PKEY_Hardware_DisplayAttribute
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 5
+DEFINE_PROPERTYKEY(PKEY_Hardware_DisplayAttribute, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 5);
+
+//  Name:     System.Hardware.DriverDate -- PKEY_Hardware_DriverDate
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 11
+DEFINE_PROPERTYKEY(PKEY_Hardware_DriverDate, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 11);
+
+//  Name:     System.Hardware.DriverProvider -- PKEY_Hardware_DriverProvider
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 10
+DEFINE_PROPERTYKEY(PKEY_Hardware_DriverProvider, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 10);
+
+//  Name:     System.Hardware.DriverVersion -- PKEY_Hardware_DriverVersion
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 9
+DEFINE_PROPERTYKEY(PKEY_Hardware_DriverVersion, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 9);
+
+//  Name:     System.Hardware.Function -- PKEY_Hardware_Function
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4099
+DEFINE_PROPERTYKEY(PKEY_Hardware_Function, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4099);
+
+//  Name:     System.Hardware.Icon -- PKEY_Hardware_Icon
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 3
+DEFINE_PROPERTYKEY(PKEY_Hardware_Icon, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 3);
+
+//  Name:     System.Hardware.Image -- PKEY_Hardware_Image
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4098
+DEFINE_PROPERTYKEY(PKEY_Hardware_Image, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4098);
+
+//  Name:     System.Hardware.Manufacturer -- PKEY_Hardware_Manufacturer
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 6
+DEFINE_PROPERTYKEY(PKEY_Hardware_Manufacturer, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 6);
+
+//  Name:     System.Hardware.Model -- PKEY_Hardware_Model
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 7
+DEFINE_PROPERTYKEY(PKEY_Hardware_Model, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 7);
+
+//  Name:     System.Hardware.Name -- PKEY_Hardware_Name
+//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 2
+DEFINE_PROPERTYKEY(PKEY_Hardware_Name, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 2);
+
+//  Name:     System.Hardware.SerialNumber -- PKEY_Hardware_SerialNumber
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 8
+DEFINE_PROPERTYKEY(PKEY_Hardware_SerialNumber, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 8);
+
+//  Name:     System.Hardware.ShellAttributes -- PKEY_Hardware_ShellAttributes
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4100
+DEFINE_PROPERTYKEY(PKEY_Hardware_ShellAttributes, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4100);
+
+//  Name:     System.Hardware.Status -- PKEY_Hardware_Status
+//  Type:     Unspecified -- VT_NULL
+//  FormatID: 5EAF3EF2-E0CA-4598-BF06-71ED1D9DD953, 4096
+DEFINE_PROPERTYKEY(PKEY_Hardware_Status, 0x5EAF3EF2, 0xE0CA, 0x4598, 0xBF, 0x06, 0x71, 0xED, 0x1D, 0x9D, 0xD9, 0x53, 4096);
+
+
--- a/src/hostapi/wasapi/mingw-include/ksmedia.h
+++ b/src/hostapi/wasapi/mingw-include/ksmedia.h
@@ -417,11 +417,11 @@ DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196",KSCATEGORY_AUDIO);
 DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196",KSCATEGORY_VIDEO);
 #define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)
 
-/* Added for Vista and later */
-#define STATIC_KSCATEGORY_REALTIME \
-    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
-DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", KSCATEGORY_REALTIME);
-#define KSCATEGORY_REALTIME DEFINE_GUIDNAMED(KSCATEGORY_REALTIME)
+/* Added for Vista and later */
+#define STATIC_KSCATEGORY_REALTIME \
+    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
+DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", KSCATEGORY_REALTIME);
+#define KSCATEGORY_REALTIME DEFINE_GUIDNAMED(KSCATEGORY_REALTIME)
 
 #define STATIC_KSCATEGORY_TEXT						\
 	0x6994AD06L,0x93EF,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96
--- a/src/hostapi/wasapi/mingw-include/mmdeviceapi.h
+++ b/src/hostapi/wasapi/mingw-include/mmdeviceapi.h
@@ -1,929 +1,929 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for mmdeviceapi.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 500
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __mmdeviceapi_h__
-#define __mmdeviceapi_h__
-
-#if __GNUC__ >=3
-#pragma GCC system_header
-#endif
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IMMNotificationClient_FWD_DEFINED__
-#define __IMMNotificationClient_FWD_DEFINED__
-typedef interface IMMNotificationClient IMMNotificationClient;
-#endif 	/* __IMMNotificationClient_FWD_DEFINED__ */
-
-
-#ifndef __IMMDevice_FWD_DEFINED__
-#define __IMMDevice_FWD_DEFINED__
-typedef interface IMMDevice IMMDevice;
-#endif 	/* __IMMDevice_FWD_DEFINED__ */
-
-
-#ifndef __IMMDeviceCollection_FWD_DEFINED__
-#define __IMMDeviceCollection_FWD_DEFINED__
-typedef interface IMMDeviceCollection IMMDeviceCollection;
-#endif 	/* __IMMDeviceCollection_FWD_DEFINED__ */
-
-
-#ifndef __IMMEndpoint_FWD_DEFINED__
-#define __IMMEndpoint_FWD_DEFINED__
-typedef interface IMMEndpoint IMMEndpoint;
-#endif 	/* __IMMEndpoint_FWD_DEFINED__ */
-
-
-#ifndef __IMMDeviceEnumerator_FWD_DEFINED__
-#define __IMMDeviceEnumerator_FWD_DEFINED__
-typedef interface IMMDeviceEnumerator IMMDeviceEnumerator;
-#endif 	/* __IMMDeviceEnumerator_FWD_DEFINED__ */
-
-
-#ifndef __IMMDeviceActivator_FWD_DEFINED__
-#define __IMMDeviceActivator_FWD_DEFINED__
-typedef interface IMMDeviceActivator IMMDeviceActivator;
-#endif 	/* __IMMDeviceActivator_FWD_DEFINED__ */
-
-
-#ifndef __MMDeviceEnumerator_FWD_DEFINED__
-#define __MMDeviceEnumerator_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class MMDeviceEnumerator MMDeviceEnumerator;
-#else
-typedef struct MMDeviceEnumerator MMDeviceEnumerator;
-#endif /* __cplusplus */
-
-#endif 	/* __MMDeviceEnumerator_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "unknwn.h"
-#include "propsys.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_mmdeviceapi_0000_0000 */
-/* [local] */ 
-
-#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
-#define E_UNSUPPORTED_TYPE HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE)
-#define DEVICE_STATE_ACTIVE      0x00000001
-#define DEVICE_STATE_DISABLED    0x00000002
-#define DEVICE_STATE_NOTPRESENT  0x00000004
-#define DEVICE_STATE_UNPLUGGED   0x00000008
-#define DEVICE_STATEMASK_ALL     0x0000000f
-#ifdef DEFINE_PROPERTYKEY
-#undef DEFINE_PROPERTYKEY
-#endif
-#ifdef INITGUID
-#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
-#else
-#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
-#endif // INITGUID
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FormFactor, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 0); 
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_ControlPanelPageProvider, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 1); 
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Association, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 2);
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_PhysicalSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 3);
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_GUID, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 4);
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Disable_SysFx, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 5);
-#define ENDPOINT_SYSFX_ENABLED          0x00000000  // System Effects are enabled.
-#define ENDPOINT_SYSFX_DISABLED         0x00000001  // System Effects are disabled.
-DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FullRangeSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 6);
-DEFINE_PROPERTYKEY(PKEY_AudioEngine_DeviceFormat, 0xf19f064d, 0x82c, 0x4e27, 0xbc, 0x73, 0x68, 0x82, 0xa1, 0xbb, 0x8e, 0x4c, 0); 
-typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS
-    {
-    DWORD cbDirectXAudioActivationParams;
-    GUID guidAudioSession;
-    DWORD dwAudioStreamFlags;
-    } 	DIRECTX_AUDIO_ACTIVATION_PARAMS;
-
-typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS *PDIRECTX_AUDIO_ACTIVATION_PARAMS;
-
-typedef /* [public][public][public][public][public] */ 
-enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0001
-    {	eRender	= 0,
-	eCapture	= ( eRender + 1 ) ,
-	eAll	= ( eCapture + 1 ) ,
-	EDataFlow_enum_count	= ( eAll + 1 ) 
-    } 	EDataFlow;
-
-typedef /* [public][public][public] */ 
-enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0002
-    {	eConsole	= 0,
-	eMultimedia	= ( eConsole + 1 ) ,
-	eCommunications	= ( eMultimedia + 1 ) ,
-	ERole_enum_count	= ( eCommunications + 1 ) 
-    } 	ERole;
-
-typedef /* [public] */ 
-enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0003
-    {	RemoteNetworkDevice	= 0,
-	Speakers	= ( RemoteNetworkDevice + 1 ) ,
-	LineLevel	= ( Speakers + 1 ) ,
-	Headphones	= ( LineLevel + 1 ) ,
-	Microphone	= ( Headphones + 1 ) ,
-	Headset	= ( Microphone + 1 ) ,
-	Handset	= ( Headset + 1 ) ,
-	UnknownDigitalPassthrough	= ( Handset + 1 ) ,
-	SPDIF	= ( UnknownDigitalPassthrough + 1 ) ,
-	HDMI	= ( SPDIF + 1 ) ,
-	UnknownFormFactor	= ( HDMI + 1 ) 
-    } 	EndpointFormFactor;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IMMNotificationClient_INTERFACE_DEFINED__
-#define __IMMNotificationClient_INTERFACE_DEFINED__
-
-/* interface IMMNotificationClient */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMNotificationClient;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("7991EEC9-7E89-4D85-8390-6C703CEC60C0")
-    IMMNotificationClient : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceStateChanged( 
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId,
-            /* [in] */ 
-            __in  DWORD dwNewState) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceAdded( 
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceRemoved( 
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged( 
-            /* [in] */ 
-            __in  EDataFlow flow,
-            /* [in] */ 
-            __in  ERole role,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDefaultDeviceId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPropertyValueChanged( 
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId,
-            /* [in] */ 
-            __in  const PROPERTYKEY key) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMNotificationClientVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMNotificationClient * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMNotificationClient * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMNotificationClient * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceStateChanged )( 
-            IMMNotificationClient * This,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId,
-            /* [in] */ 
-            __in  DWORD dwNewState);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceAdded )( 
-            IMMNotificationClient * This,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceRemoved )( 
-            IMMNotificationClient * This,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDefaultDeviceChanged )( 
-            IMMNotificationClient * This,
-            /* [in] */ 
-            __in  EDataFlow flow,
-            /* [in] */ 
-            __in  ERole role,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDefaultDeviceId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPropertyValueChanged )( 
-            IMMNotificationClient * This,
-            /* [in] */ 
-            __in  LPCWSTR pwstrDeviceId,
-            /* [in] */ 
-            __in  const PROPERTYKEY key);
-        
-        END_INTERFACE
-    } IMMNotificationClientVtbl;
-
-    interface IMMNotificationClient
-    {
-        CONST_VTBL struct IMMNotificationClientVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMNotificationClient_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMNotificationClient_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMNotificationClient_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMNotificationClient_OnDeviceStateChanged(This,pwstrDeviceId,dwNewState)	\
-    ( (This)->lpVtbl -> OnDeviceStateChanged(This,pwstrDeviceId,dwNewState) ) 
-
-#define IMMNotificationClient_OnDeviceAdded(This,pwstrDeviceId)	\
-    ( (This)->lpVtbl -> OnDeviceAdded(This,pwstrDeviceId) ) 
-
-#define IMMNotificationClient_OnDeviceRemoved(This,pwstrDeviceId)	\
-    ( (This)->lpVtbl -> OnDeviceRemoved(This,pwstrDeviceId) ) 
-
-#define IMMNotificationClient_OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId)	\
-    ( (This)->lpVtbl -> OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId) ) 
-
-#define IMMNotificationClient_OnPropertyValueChanged(This,pwstrDeviceId,key)	\
-    ( (This)->lpVtbl -> OnPropertyValueChanged(This,pwstrDeviceId,key) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMNotificationClient_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMMDevice_INTERFACE_DEFINED__
-#define __IMMDevice_INTERFACE_DEFINED__
-
-/* interface IMMDevice */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMDevice;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("D666063F-1587-4E43-81F1-B948E807363F")
-    IMMDevice : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
-            /* [in] */ 
-            __in  REFIID iid,
-            /* [in] */ 
-            __in  DWORD dwClsCtx,
-            /* [unique][in] */ 
-            __in_opt  PROPVARIANT *pActivationParams,
-            /* [iid_is][out] */ 
-            __out  void **ppInterface) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenPropertyStore( 
-            /* [in] */ 
-            __in  DWORD stgmAccess,
-            /* [out] */ 
-            __out  IPropertyStore **ppProperties) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetId( 
-            /* [out] */ 
-            __deref_out  LPWSTR *ppstrId) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetState( 
-            /* [out] */ 
-            __out  DWORD *pdwState) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMDeviceVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMDevice * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMDevice * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMDevice * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
-            IMMDevice * This,
-            /* [in] */ 
-            __in  REFIID iid,
-            /* [in] */ 
-            __in  DWORD dwClsCtx,
-            /* [unique][in] */ 
-            __in_opt  PROPVARIANT *pActivationParams,
-            /* [iid_is][out] */ 
-            __out  void **ppInterface);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OpenPropertyStore )( 
-            IMMDevice * This,
-            /* [in] */ 
-            __in  DWORD stgmAccess,
-            /* [out] */ 
-            __out  IPropertyStore **ppProperties);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetId )( 
-            IMMDevice * This,
-            /* [out] */ 
-            __deref_out  LPWSTR *ppstrId);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetState )( 
-            IMMDevice * This,
-            /* [out] */ 
-            __out  DWORD *pdwState);
-        
-        END_INTERFACE
-    } IMMDeviceVtbl;
-
-    interface IMMDevice
-    {
-        CONST_VTBL struct IMMDeviceVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMDevice_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMDevice_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMDevice_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMDevice_Activate(This,iid,dwClsCtx,pActivationParams,ppInterface)	\
-    ( (This)->lpVtbl -> Activate(This,iid,dwClsCtx,pActivationParams,ppInterface) ) 
-
-#define IMMDevice_OpenPropertyStore(This,stgmAccess,ppProperties)	\
-    ( (This)->lpVtbl -> OpenPropertyStore(This,stgmAccess,ppProperties) ) 
-
-#define IMMDevice_GetId(This,ppstrId)	\
-    ( (This)->lpVtbl -> GetId(This,ppstrId) ) 
-
-#define IMMDevice_GetState(This,pdwState)	\
-    ( (This)->lpVtbl -> GetState(This,pdwState) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMDevice_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMMDeviceCollection_INTERFACE_DEFINED__
-#define __IMMDeviceCollection_INTERFACE_DEFINED__
-
-/* interface IMMDeviceCollection */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMDeviceCollection;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("0BD7A1BE-7A1A-44DB-8397-CC5392387B5E")
-    IMMDeviceCollection : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ 
-            __out  UINT *pcDevices) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
-            /* [in] */ 
-            __in  UINT nDevice,
-            /* [out] */ 
-            __out  IMMDevice **ppDevice) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMDeviceCollectionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMDeviceCollection * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMDeviceCollection * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMDeviceCollection * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IMMDeviceCollection * This,
-            /* [out] */ 
-            __out  UINT *pcDevices);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
-            IMMDeviceCollection * This,
-            /* [in] */ 
-            __in  UINT nDevice,
-            /* [out] */ 
-            __out  IMMDevice **ppDevice);
-        
-        END_INTERFACE
-    } IMMDeviceCollectionVtbl;
-
-    interface IMMDeviceCollection
-    {
-        CONST_VTBL struct IMMDeviceCollectionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMDeviceCollection_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMDeviceCollection_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMDeviceCollection_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMDeviceCollection_GetCount(This,pcDevices)	\
-    ( (This)->lpVtbl -> GetCount(This,pcDevices) ) 
-
-#define IMMDeviceCollection_Item(This,nDevice,ppDevice)	\
-    ( (This)->lpVtbl -> Item(This,nDevice,ppDevice) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMDeviceCollection_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMMEndpoint_INTERFACE_DEFINED__
-#define __IMMEndpoint_INTERFACE_DEFINED__
-
-/* interface IMMEndpoint */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMEndpoint;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("1BE09788-6894-4089-8586-9A2A6C265AC5")
-    IMMEndpoint : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
-            /* [out] */ 
-            __out  EDataFlow *pDataFlow) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMEndpointVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMEndpoint * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMEndpoint * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMEndpoint * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
-            IMMEndpoint * This,
-            /* [out] */ 
-            __out  EDataFlow *pDataFlow);
-        
-        END_INTERFACE
-    } IMMEndpointVtbl;
-
-    interface IMMEndpoint
-    {
-        CONST_VTBL struct IMMEndpointVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMEndpoint_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMEndpoint_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMEndpoint_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMEndpoint_GetDataFlow(This,pDataFlow)	\
-    ( (This)->lpVtbl -> GetDataFlow(This,pDataFlow) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMEndpoint_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMMDeviceEnumerator_INTERFACE_DEFINED__
-#define __IMMDeviceEnumerator_INTERFACE_DEFINED__
-
-/* interface IMMDeviceEnumerator */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMDeviceEnumerator;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("A95664D2-9614-4F35-A746-DE8DB63617E6")
-    IMMDeviceEnumerator : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumAudioEndpoints( 
-            /* [in] */ 
-            __in  EDataFlow dataFlow,
-            /* [in] */ 
-            __in  DWORD dwStateMask,
-            /* [out] */ 
-            __out  IMMDeviceCollection **ppDevices) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultAudioEndpoint( 
-            /* [in] */ 
-            __in  EDataFlow dataFlow,
-            /* [in] */ 
-            __in  ERole role,
-            /* [out] */ 
-            __out  IMMDevice **ppEndpoint) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevice( 
-            /*  */ 
-            __in  LPCWSTR pwstrId,
-            /* [out] */ 
-            __out  IMMDevice **ppDevice) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterEndpointNotificationCallback( 
-            /* [in] */ 
-            __in  IMMNotificationClient *pClient) = 0;
-        
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterEndpointNotificationCallback( 
-            /* [in] */ 
-            __in  IMMNotificationClient *pClient) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMDeviceEnumeratorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMDeviceEnumerator * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMDeviceEnumerator * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMDeviceEnumerator * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumAudioEndpoints )( 
-            IMMDeviceEnumerator * This,
-            /* [in] */ 
-            __in  EDataFlow dataFlow,
-            /* [in] */ 
-            __in  DWORD dwStateMask,
-            /* [out] */ 
-            __out  IMMDeviceCollection **ppDevices);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioEndpoint )( 
-            IMMDeviceEnumerator * This,
-            /* [in] */ 
-            __in  EDataFlow dataFlow,
-            /* [in] */ 
-            __in  ERole role,
-            /* [out] */ 
-            __out  IMMDevice **ppEndpoint);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
-            IMMDeviceEnumerator * This,
-            /*  */ 
-            __in  LPCWSTR pwstrId,
-            /* [out] */ 
-            __out  IMMDevice **ppDevice);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterEndpointNotificationCallback )( 
-            IMMDeviceEnumerator * This,
-            /* [in] */ 
-            __in  IMMNotificationClient *pClient);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterEndpointNotificationCallback )( 
-            IMMDeviceEnumerator * This,
-            /* [in] */ 
-            __in  IMMNotificationClient *pClient);
-        
-        END_INTERFACE
-    } IMMDeviceEnumeratorVtbl;
-
-    interface IMMDeviceEnumerator
-    {
-        CONST_VTBL struct IMMDeviceEnumeratorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMDeviceEnumerator_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMDeviceEnumerator_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMDeviceEnumerator_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMDeviceEnumerator_EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices)	\
-    ( (This)->lpVtbl -> EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices) ) 
-
-#define IMMDeviceEnumerator_GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint)	\
-    ( (This)->lpVtbl -> GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint) ) 
-
-#define IMMDeviceEnumerator_GetDevice(This,pwstrId,ppDevice)	\
-    ( (This)->lpVtbl -> GetDevice(This,pwstrId,ppDevice) ) 
-
-#define IMMDeviceEnumerator_RegisterEndpointNotificationCallback(This,pClient)	\
-    ( (This)->lpVtbl -> RegisterEndpointNotificationCallback(This,pClient) ) 
-
-#define IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(This,pClient)	\
-    ( (This)->lpVtbl -> UnregisterEndpointNotificationCallback(This,pClient) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMDeviceEnumerator_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMMDeviceActivator_INTERFACE_DEFINED__
-#define __IMMDeviceActivator_INTERFACE_DEFINED__
-
-/* interface IMMDeviceActivator */
-/* [unique][helpstring][nonextensible][uuid][local][object] */ 
-
-
-EXTERN_C const IID IID_IMMDeviceActivator;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("3B0D0EA4-D0A9-4B0E-935B-09516746FAC0")
-    IMMDeviceActivator : public IUnknown
-    {
-    public:
-        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
-            /* [in] */ 
-            __in  REFIID iid,
-            /* [in] */ 
-            __in  IMMDevice *pDevice,
-            /* [in] */ 
-            __in_opt  PROPVARIANT *pActivationParams,
-            /* [iid_is][out] */ 
-            __out  void **ppInterface) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMMDeviceActivatorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMMDeviceActivator * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMMDeviceActivator * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMMDeviceActivator * This);
-        
-        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
-            IMMDeviceActivator * This,
-            /* [in] */ 
-            __in  REFIID iid,
-            /* [in] */ 
-            __in  IMMDevice *pDevice,
-            /* [in] */ 
-            __in_opt  PROPVARIANT *pActivationParams,
-            /* [iid_is][out] */ 
-            __out  void **ppInterface);
-        
-        END_INTERFACE
-    } IMMDeviceActivatorVtbl;
-
-    interface IMMDeviceActivator
-    {
-        CONST_VTBL struct IMMDeviceActivatorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMMDeviceActivator_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMMDeviceActivator_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMMDeviceActivator_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMMDeviceActivator_Activate(This,iid,pDevice,pActivationParams,ppInterface)	\
-    ( (This)->lpVtbl -> Activate(This,iid,pDevice,pActivationParams,ppInterface) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMMDeviceActivator_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_mmdeviceapi_0000_0006 */
-/* [local] */ 
-
-typedef /* [public] */ struct __MIDL___MIDL_itf_mmdeviceapi_0000_0006_0001
-    {
-    LPARAM AddPageParam;
-    IMMDevice *pEndpoint;
-    IMMDevice *pPnpInterface;
-    IMMDevice *pPnpDevnode;
-    } 	AudioExtensionParams;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_s_ifspec;
-
-
-#ifndef __MMDeviceAPILib_LIBRARY_DEFINED__
-#define __MMDeviceAPILib_LIBRARY_DEFINED__
-
-/* library MMDeviceAPILib */
-/* [helpstring][version][uuid] */ 
-
-
-EXTERN_C const IID LIBID_MMDeviceAPILib;
-
-EXTERN_C const CLSID CLSID_MMDeviceEnumerator;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("BCDE0395-E52F-467C-8E3D-C4579291692E")
-MMDeviceEnumerator;
-#endif
-#endif /* __MMDeviceAPILib_LIBRARY_DEFINED__ */
-
-/* Additional Prototypes for ALL interfaces */
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for mmdeviceapi.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 500
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __mmdeviceapi_h__
+#define __mmdeviceapi_h__
+
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IMMNotificationClient_FWD_DEFINED__
+#define __IMMNotificationClient_FWD_DEFINED__
+typedef interface IMMNotificationClient IMMNotificationClient;
+#endif 	/* __IMMNotificationClient_FWD_DEFINED__ */
+
+
+#ifndef __IMMDevice_FWD_DEFINED__
+#define __IMMDevice_FWD_DEFINED__
+typedef interface IMMDevice IMMDevice;
+#endif 	/* __IMMDevice_FWD_DEFINED__ */
+
+
+#ifndef __IMMDeviceCollection_FWD_DEFINED__
+#define __IMMDeviceCollection_FWD_DEFINED__
+typedef interface IMMDeviceCollection IMMDeviceCollection;
+#endif 	/* __IMMDeviceCollection_FWD_DEFINED__ */
+
+
+#ifndef __IMMEndpoint_FWD_DEFINED__
+#define __IMMEndpoint_FWD_DEFINED__
+typedef interface IMMEndpoint IMMEndpoint;
+#endif 	/* __IMMEndpoint_FWD_DEFINED__ */
+
+
+#ifndef __IMMDeviceEnumerator_FWD_DEFINED__
+#define __IMMDeviceEnumerator_FWD_DEFINED__
+typedef interface IMMDeviceEnumerator IMMDeviceEnumerator;
+#endif 	/* __IMMDeviceEnumerator_FWD_DEFINED__ */
+
+
+#ifndef __IMMDeviceActivator_FWD_DEFINED__
+#define __IMMDeviceActivator_FWD_DEFINED__
+typedef interface IMMDeviceActivator IMMDeviceActivator;
+#endif 	/* __IMMDeviceActivator_FWD_DEFINED__ */
+
+
+#ifndef __MMDeviceEnumerator_FWD_DEFINED__
+#define __MMDeviceEnumerator_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class MMDeviceEnumerator MMDeviceEnumerator;
+#else
+typedef struct MMDeviceEnumerator MMDeviceEnumerator;
+#endif /* __cplusplus */
+
+#endif 	/* __MMDeviceEnumerator_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "unknwn.h"
+#include "propsys.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_mmdeviceapi_0000_0000 */
+/* [local] */ 
+
+#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
+#define E_UNSUPPORTED_TYPE HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE)
+#define DEVICE_STATE_ACTIVE      0x00000001
+#define DEVICE_STATE_DISABLED    0x00000002
+#define DEVICE_STATE_NOTPRESENT  0x00000004
+#define DEVICE_STATE_UNPLUGGED   0x00000008
+#define DEVICE_STATEMASK_ALL     0x0000000f
+#ifdef DEFINE_PROPERTYKEY
+#undef DEFINE_PROPERTYKEY
+#endif
+#ifdef INITGUID
+#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
+#else
+#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
+#endif // INITGUID
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FormFactor, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 0); 
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_ControlPanelPageProvider, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 1); 
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Association, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 2);
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_PhysicalSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 3);
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_GUID, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 4);
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_Disable_SysFx, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 5);
+#define ENDPOINT_SYSFX_ENABLED          0x00000000  // System Effects are enabled.
+#define ENDPOINT_SYSFX_DISABLED         0x00000001  // System Effects are disabled.
+DEFINE_PROPERTYKEY(PKEY_AudioEndpoint_FullRangeSpeakers, 0x1da5d803, 0xd492, 0x4edd, 0x8c, 0x23, 0xe0, 0xc0, 0xff, 0xee, 0x7f, 0x0e, 6);
+DEFINE_PROPERTYKEY(PKEY_AudioEngine_DeviceFormat, 0xf19f064d, 0x82c, 0x4e27, 0xbc, 0x73, 0x68, 0x82, 0xa1, 0xbb, 0x8e, 0x4c, 0); 
+typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS
+    {
+    DWORD cbDirectXAudioActivationParams;
+    GUID guidAudioSession;
+    DWORD dwAudioStreamFlags;
+    } 	DIRECTX_AUDIO_ACTIVATION_PARAMS;
+
+typedef struct tagDIRECTX_AUDIO_ACTIVATION_PARAMS *PDIRECTX_AUDIO_ACTIVATION_PARAMS;
+
+typedef /* [public][public][public][public][public] */ 
+enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0001
+    {	eRender	= 0,
+	eCapture	= ( eRender + 1 ) ,
+	eAll	= ( eCapture + 1 ) ,
+	EDataFlow_enum_count	= ( eAll + 1 ) 
+    } 	EDataFlow;
+
+typedef /* [public][public][public] */ 
+enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0002
+    {	eConsole	= 0,
+	eMultimedia	= ( eConsole + 1 ) ,
+	eCommunications	= ( eMultimedia + 1 ) ,
+	ERole_enum_count	= ( eCommunications + 1 ) 
+    } 	ERole;
+
+typedef /* [public] */ 
+enum __MIDL___MIDL_itf_mmdeviceapi_0000_0000_0003
+    {	RemoteNetworkDevice	= 0,
+	Speakers	= ( RemoteNetworkDevice + 1 ) ,
+	LineLevel	= ( Speakers + 1 ) ,
+	Headphones	= ( LineLevel + 1 ) ,
+	Microphone	= ( Headphones + 1 ) ,
+	Headset	= ( Microphone + 1 ) ,
+	Handset	= ( Headset + 1 ) ,
+	UnknownDigitalPassthrough	= ( Handset + 1 ) ,
+	SPDIF	= ( UnknownDigitalPassthrough + 1 ) ,
+	HDMI	= ( SPDIF + 1 ) ,
+	UnknownFormFactor	= ( HDMI + 1 ) 
+    } 	EndpointFormFactor;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IMMNotificationClient_INTERFACE_DEFINED__
+#define __IMMNotificationClient_INTERFACE_DEFINED__
+
+/* interface IMMNotificationClient */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMNotificationClient;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("7991EEC9-7E89-4D85-8390-6C703CEC60C0")
+    IMMNotificationClient : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceStateChanged( 
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId,
+            /* [in] */ 
+            __in  DWORD dwNewState) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceAdded( 
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDeviceRemoved( 
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged( 
+            /* [in] */ 
+            __in  EDataFlow flow,
+            /* [in] */ 
+            __in  ERole role,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDefaultDeviceId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPropertyValueChanged( 
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId,
+            /* [in] */ 
+            __in  const PROPERTYKEY key) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMNotificationClientVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMNotificationClient * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMNotificationClient * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMNotificationClient * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceStateChanged )( 
+            IMMNotificationClient * This,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId,
+            /* [in] */ 
+            __in  DWORD dwNewState);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceAdded )( 
+            IMMNotificationClient * This,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDeviceRemoved )( 
+            IMMNotificationClient * This,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDefaultDeviceChanged )( 
+            IMMNotificationClient * This,
+            /* [in] */ 
+            __in  EDataFlow flow,
+            /* [in] */ 
+            __in  ERole role,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDefaultDeviceId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPropertyValueChanged )( 
+            IMMNotificationClient * This,
+            /* [in] */ 
+            __in  LPCWSTR pwstrDeviceId,
+            /* [in] */ 
+            __in  const PROPERTYKEY key);
+        
+        END_INTERFACE
+    } IMMNotificationClientVtbl;
+
+    interface IMMNotificationClient
+    {
+        CONST_VTBL struct IMMNotificationClientVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMNotificationClient_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMNotificationClient_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMNotificationClient_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMNotificationClient_OnDeviceStateChanged(This,pwstrDeviceId,dwNewState)	\
+    ( (This)->lpVtbl -> OnDeviceStateChanged(This,pwstrDeviceId,dwNewState) ) 
+
+#define IMMNotificationClient_OnDeviceAdded(This,pwstrDeviceId)	\
+    ( (This)->lpVtbl -> OnDeviceAdded(This,pwstrDeviceId) ) 
+
+#define IMMNotificationClient_OnDeviceRemoved(This,pwstrDeviceId)	\
+    ( (This)->lpVtbl -> OnDeviceRemoved(This,pwstrDeviceId) ) 
+
+#define IMMNotificationClient_OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId)	\
+    ( (This)->lpVtbl -> OnDefaultDeviceChanged(This,flow,role,pwstrDefaultDeviceId) ) 
+
+#define IMMNotificationClient_OnPropertyValueChanged(This,pwstrDeviceId,key)	\
+    ( (This)->lpVtbl -> OnPropertyValueChanged(This,pwstrDeviceId,key) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMNotificationClient_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMMDevice_INTERFACE_DEFINED__
+#define __IMMDevice_INTERFACE_DEFINED__
+
+/* interface IMMDevice */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMDevice;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("D666063F-1587-4E43-81F1-B948E807363F")
+    IMMDevice : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
+            /* [in] */ 
+            __in  REFIID iid,
+            /* [in] */ 
+            __in  DWORD dwClsCtx,
+            /* [unique][in] */ 
+            __in_opt  PROPVARIANT *pActivationParams,
+            /* [iid_is][out] */ 
+            __out  void **ppInterface) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenPropertyStore( 
+            /* [in] */ 
+            __in  DWORD stgmAccess,
+            /* [out] */ 
+            __out  IPropertyStore **ppProperties) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetId( 
+            /* [out] */ 
+            __deref_out  LPWSTR *ppstrId) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetState( 
+            /* [out] */ 
+            __out  DWORD *pdwState) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMDeviceVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMDevice * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMDevice * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMDevice * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
+            IMMDevice * This,
+            /* [in] */ 
+            __in  REFIID iid,
+            /* [in] */ 
+            __in  DWORD dwClsCtx,
+            /* [unique][in] */ 
+            __in_opt  PROPVARIANT *pActivationParams,
+            /* [iid_is][out] */ 
+            __out  void **ppInterface);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OpenPropertyStore )( 
+            IMMDevice * This,
+            /* [in] */ 
+            __in  DWORD stgmAccess,
+            /* [out] */ 
+            __out  IPropertyStore **ppProperties);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetId )( 
+            IMMDevice * This,
+            /* [out] */ 
+            __deref_out  LPWSTR *ppstrId);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetState )( 
+            IMMDevice * This,
+            /* [out] */ 
+            __out  DWORD *pdwState);
+        
+        END_INTERFACE
+    } IMMDeviceVtbl;
+
+    interface IMMDevice
+    {
+        CONST_VTBL struct IMMDeviceVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMDevice_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMDevice_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMDevice_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMDevice_Activate(This,iid,dwClsCtx,pActivationParams,ppInterface)	\
+    ( (This)->lpVtbl -> Activate(This,iid,dwClsCtx,pActivationParams,ppInterface) ) 
+
+#define IMMDevice_OpenPropertyStore(This,stgmAccess,ppProperties)	\
+    ( (This)->lpVtbl -> OpenPropertyStore(This,stgmAccess,ppProperties) ) 
+
+#define IMMDevice_GetId(This,ppstrId)	\
+    ( (This)->lpVtbl -> GetId(This,ppstrId) ) 
+
+#define IMMDevice_GetState(This,pdwState)	\
+    ( (This)->lpVtbl -> GetState(This,pdwState) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMDevice_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMMDeviceCollection_INTERFACE_DEFINED__
+#define __IMMDeviceCollection_INTERFACE_DEFINED__
+
+/* interface IMMDeviceCollection */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMDeviceCollection;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0BD7A1BE-7A1A-44DB-8397-CC5392387B5E")
+    IMMDeviceCollection : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ 
+            __out  UINT *pcDevices) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
+            /* [in] */ 
+            __in  UINT nDevice,
+            /* [out] */ 
+            __out  IMMDevice **ppDevice) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMDeviceCollectionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMDeviceCollection * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMDeviceCollection * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMDeviceCollection * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IMMDeviceCollection * This,
+            /* [out] */ 
+            __out  UINT *pcDevices);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
+            IMMDeviceCollection * This,
+            /* [in] */ 
+            __in  UINT nDevice,
+            /* [out] */ 
+            __out  IMMDevice **ppDevice);
+        
+        END_INTERFACE
+    } IMMDeviceCollectionVtbl;
+
+    interface IMMDeviceCollection
+    {
+        CONST_VTBL struct IMMDeviceCollectionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMDeviceCollection_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMDeviceCollection_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMDeviceCollection_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMDeviceCollection_GetCount(This,pcDevices)	\
+    ( (This)->lpVtbl -> GetCount(This,pcDevices) ) 
+
+#define IMMDeviceCollection_Item(This,nDevice,ppDevice)	\
+    ( (This)->lpVtbl -> Item(This,nDevice,ppDevice) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMDeviceCollection_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMMEndpoint_INTERFACE_DEFINED__
+#define __IMMEndpoint_INTERFACE_DEFINED__
+
+/* interface IMMEndpoint */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMEndpoint;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1BE09788-6894-4089-8586-9A2A6C265AC5")
+    IMMEndpoint : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataFlow( 
+            /* [out] */ 
+            __out  EDataFlow *pDataFlow) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMEndpointVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMEndpoint * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMEndpoint * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMEndpoint * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataFlow )( 
+            IMMEndpoint * This,
+            /* [out] */ 
+            __out  EDataFlow *pDataFlow);
+        
+        END_INTERFACE
+    } IMMEndpointVtbl;
+
+    interface IMMEndpoint
+    {
+        CONST_VTBL struct IMMEndpointVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMEndpoint_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMEndpoint_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMEndpoint_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMEndpoint_GetDataFlow(This,pDataFlow)	\
+    ( (This)->lpVtbl -> GetDataFlow(This,pDataFlow) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMEndpoint_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMMDeviceEnumerator_INTERFACE_DEFINED__
+#define __IMMDeviceEnumerator_INTERFACE_DEFINED__
+
+/* interface IMMDeviceEnumerator */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMDeviceEnumerator;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A95664D2-9614-4F35-A746-DE8DB63617E6")
+    IMMDeviceEnumerator : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumAudioEndpoints( 
+            /* [in] */ 
+            __in  EDataFlow dataFlow,
+            /* [in] */ 
+            __in  DWORD dwStateMask,
+            /* [out] */ 
+            __out  IMMDeviceCollection **ppDevices) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultAudioEndpoint( 
+            /* [in] */ 
+            __in  EDataFlow dataFlow,
+            /* [in] */ 
+            __in  ERole role,
+            /* [out] */ 
+            __out  IMMDevice **ppEndpoint) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDevice( 
+            /*  */ 
+            __in  LPCWSTR pwstrId,
+            /* [out] */ 
+            __out  IMMDevice **ppDevice) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterEndpointNotificationCallback( 
+            /* [in] */ 
+            __in  IMMNotificationClient *pClient) = 0;
+        
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterEndpointNotificationCallback( 
+            /* [in] */ 
+            __in  IMMNotificationClient *pClient) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMDeviceEnumeratorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMDeviceEnumerator * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMDeviceEnumerator * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMDeviceEnumerator * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnumAudioEndpoints )( 
+            IMMDeviceEnumerator * This,
+            /* [in] */ 
+            __in  EDataFlow dataFlow,
+            /* [in] */ 
+            __in  DWORD dwStateMask,
+            /* [out] */ 
+            __out  IMMDeviceCollection **ppDevices);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioEndpoint )( 
+            IMMDeviceEnumerator * This,
+            /* [in] */ 
+            __in  EDataFlow dataFlow,
+            /* [in] */ 
+            __in  ERole role,
+            /* [out] */ 
+            __out  IMMDevice **ppEndpoint);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
+            IMMDeviceEnumerator * This,
+            /*  */ 
+            __in  LPCWSTR pwstrId,
+            /* [out] */ 
+            __out  IMMDevice **ppDevice);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterEndpointNotificationCallback )( 
+            IMMDeviceEnumerator * This,
+            /* [in] */ 
+            __in  IMMNotificationClient *pClient);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterEndpointNotificationCallback )( 
+            IMMDeviceEnumerator * This,
+            /* [in] */ 
+            __in  IMMNotificationClient *pClient);
+        
+        END_INTERFACE
+    } IMMDeviceEnumeratorVtbl;
+
+    interface IMMDeviceEnumerator
+    {
+        CONST_VTBL struct IMMDeviceEnumeratorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMDeviceEnumerator_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMDeviceEnumerator_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMDeviceEnumerator_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMDeviceEnumerator_EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices)	\
+    ( (This)->lpVtbl -> EnumAudioEndpoints(This,dataFlow,dwStateMask,ppDevices) ) 
+
+#define IMMDeviceEnumerator_GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint)	\
+    ( (This)->lpVtbl -> GetDefaultAudioEndpoint(This,dataFlow,role,ppEndpoint) ) 
+
+#define IMMDeviceEnumerator_GetDevice(This,pwstrId,ppDevice)	\
+    ( (This)->lpVtbl -> GetDevice(This,pwstrId,ppDevice) ) 
+
+#define IMMDeviceEnumerator_RegisterEndpointNotificationCallback(This,pClient)	\
+    ( (This)->lpVtbl -> RegisterEndpointNotificationCallback(This,pClient) ) 
+
+#define IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(This,pClient)	\
+    ( (This)->lpVtbl -> UnregisterEndpointNotificationCallback(This,pClient) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMDeviceEnumerator_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMMDeviceActivator_INTERFACE_DEFINED__
+#define __IMMDeviceActivator_INTERFACE_DEFINED__
+
+/* interface IMMDeviceActivator */
+/* [unique][helpstring][nonextensible][uuid][local][object] */ 
+
+
+EXTERN_C const IID IID_IMMDeviceActivator;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3B0D0EA4-D0A9-4B0E-935B-09516746FAC0")
+    IMMDeviceActivator : public IUnknown
+    {
+    public:
+        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
+            /* [in] */ 
+            __in  REFIID iid,
+            /* [in] */ 
+            __in  IMMDevice *pDevice,
+            /* [in] */ 
+            __in_opt  PROPVARIANT *pActivationParams,
+            /* [iid_is][out] */ 
+            __out  void **ppInterface) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMMDeviceActivatorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMMDeviceActivator * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMMDeviceActivator * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMMDeviceActivator * This);
+        
+        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
+            IMMDeviceActivator * This,
+            /* [in] */ 
+            __in  REFIID iid,
+            /* [in] */ 
+            __in  IMMDevice *pDevice,
+            /* [in] */ 
+            __in_opt  PROPVARIANT *pActivationParams,
+            /* [iid_is][out] */ 
+            __out  void **ppInterface);
+        
+        END_INTERFACE
+    } IMMDeviceActivatorVtbl;
+
+    interface IMMDeviceActivator
+    {
+        CONST_VTBL struct IMMDeviceActivatorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMMDeviceActivator_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMMDeviceActivator_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMMDeviceActivator_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMMDeviceActivator_Activate(This,iid,pDevice,pActivationParams,ppInterface)	\
+    ( (This)->lpVtbl -> Activate(This,iid,pDevice,pActivationParams,ppInterface) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMMDeviceActivator_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_mmdeviceapi_0000_0006 */
+/* [local] */ 
+
+typedef /* [public] */ struct __MIDL___MIDL_itf_mmdeviceapi_0000_0006_0001
+    {
+    LPARAM AddPageParam;
+    IMMDevice *pEndpoint;
+    IMMDevice *pPnpInterface;
+    IMMDevice *pPnpDevnode;
+    } 	AudioExtensionParams;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_mmdeviceapi_0000_0006_v0_0_s_ifspec;
+
+
+#ifndef __MMDeviceAPILib_LIBRARY_DEFINED__
+#define __MMDeviceAPILib_LIBRARY_DEFINED__
+
+/* library MMDeviceAPILib */
+/* [helpstring][version][uuid] */ 
+
+
+EXTERN_C const IID LIBID_MMDeviceAPILib;
+
+EXTERN_C const CLSID CLSID_MMDeviceEnumerator;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("BCDE0395-E52F-467C-8E3D-C4579291692E")
+MMDeviceEnumerator;
+#endif
+#endif /* __MMDeviceAPILib_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/mingw-include/propkeydef.h
+++ b/src/hostapi/wasapi/mingw-include/propkeydef.h
@@ -1,26 +1,26 @@
-#ifndef PID_FIRST_USABLE
-#define PID_FIRST_USABLE 2
-#endif
-
-#ifndef REFPROPERTYKEY
-#ifdef __cplusplus
-#define REFPROPERTYKEY const PROPERTYKEY &
-#else // !__cplusplus
-#define REFPROPERTYKEY const PROPERTYKEY * __MIDL_CONST
-#endif // __cplusplus
-#endif //REFPROPERTYKEY
-
-#ifdef DEFINE_PROPERTYKEY
-#undef DEFINE_PROPERTYKEY
-#endif
-
-#ifdef INITGUID
-#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
-#else
-#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
-#endif // INITGUID
-
-#ifndef IsEqualPropertyKey
-#define IsEqualPropertyKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
-#endif  // IsEqualPropertyKey
-
+#ifndef PID_FIRST_USABLE
+#define PID_FIRST_USABLE 2
+#endif
+
+#ifndef REFPROPERTYKEY
+#ifdef __cplusplus
+#define REFPROPERTYKEY const PROPERTYKEY &
+#else // !__cplusplus
+#define REFPROPERTYKEY const PROPERTYKEY * __MIDL_CONST
+#endif // __cplusplus
+#endif //REFPROPERTYKEY
+
+#ifdef DEFINE_PROPERTYKEY
+#undef DEFINE_PROPERTYKEY
+#endif
+
+#ifdef INITGUID
+#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
+#else
+#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
+#endif // INITGUID
+
+#ifndef IsEqualPropertyKey
+#define IsEqualPropertyKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
+#endif  // IsEqualPropertyKey
+

--- a/src/hostapi/wasapi/mingw-include/propsys.h
+++ b/src/hostapi/wasapi/mingw-include/propsys.h
@@ -1,3605 +1,3605 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for propsys.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 475
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __propsys_h__
-#define __propsys_h__
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IInitializeWithFile_FWD_DEFINED__
-#define __IInitializeWithFile_FWD_DEFINED__
-typedef interface IInitializeWithFile IInitializeWithFile;
-#endif 	/* __IInitializeWithFile_FWD_DEFINED__ */
-
-
-#ifndef __IInitializeWithStream_FWD_DEFINED__
-#define __IInitializeWithStream_FWD_DEFINED__
-typedef interface IInitializeWithStream IInitializeWithStream;
-#endif 	/* __IInitializeWithStream_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyStore_FWD_DEFINED__
-#define __IPropertyStore_FWD_DEFINED__
-typedef interface IPropertyStore IPropertyStore;
-#endif 	/* __IPropertyStore_FWD_DEFINED__ */
-
-
-#ifndef __INamedPropertyStore_FWD_DEFINED__
-#define __INamedPropertyStore_FWD_DEFINED__
-typedef interface INamedPropertyStore INamedPropertyStore;
-#endif 	/* __INamedPropertyStore_FWD_DEFINED__ */
-
-
-#ifndef __IObjectWithPropertyKey_FWD_DEFINED__
-#define __IObjectWithPropertyKey_FWD_DEFINED__
-typedef interface IObjectWithPropertyKey IObjectWithPropertyKey;
-#endif 	/* __IObjectWithPropertyKey_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyChange_FWD_DEFINED__
-#define __IPropertyChange_FWD_DEFINED__
-typedef interface IPropertyChange IPropertyChange;
-#endif 	/* __IPropertyChange_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyChangeArray_FWD_DEFINED__
-#define __IPropertyChangeArray_FWD_DEFINED__
-typedef interface IPropertyChangeArray IPropertyChangeArray;
-#endif 	/* __IPropertyChangeArray_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyStoreCapabilities_FWD_DEFINED__
-#define __IPropertyStoreCapabilities_FWD_DEFINED__
-typedef interface IPropertyStoreCapabilities IPropertyStoreCapabilities;
-#endif 	/* __IPropertyStoreCapabilities_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyStoreCache_FWD_DEFINED__
-#define __IPropertyStoreCache_FWD_DEFINED__
-typedef interface IPropertyStoreCache IPropertyStoreCache;
-#endif 	/* __IPropertyStoreCache_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyEnumType_FWD_DEFINED__
-#define __IPropertyEnumType_FWD_DEFINED__
-typedef interface IPropertyEnumType IPropertyEnumType;
-#endif 	/* __IPropertyEnumType_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyEnumTypeList_FWD_DEFINED__
-#define __IPropertyEnumTypeList_FWD_DEFINED__
-typedef interface IPropertyEnumTypeList IPropertyEnumTypeList;
-#endif 	/* __IPropertyEnumTypeList_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyDescription_FWD_DEFINED__
-#define __IPropertyDescription_FWD_DEFINED__
-typedef interface IPropertyDescription IPropertyDescription;
-#endif 	/* __IPropertyDescription_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionAliasInfo_FWD_DEFINED__
-#define __IPropertyDescriptionAliasInfo_FWD_DEFINED__
-typedef interface IPropertyDescriptionAliasInfo IPropertyDescriptionAliasInfo;
-#endif 	/* __IPropertyDescriptionAliasInfo_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionSearchInfo_FWD_DEFINED__
-#define __IPropertyDescriptionSearchInfo_FWD_DEFINED__
-typedef interface IPropertyDescriptionSearchInfo IPropertyDescriptionSearchInfo;
-#endif 	/* __IPropertyDescriptionSearchInfo_FWD_DEFINED__ */
-
-
-#ifndef __IPropertySystem_FWD_DEFINED__
-#define __IPropertySystem_FWD_DEFINED__
-typedef interface IPropertySystem IPropertySystem;
-#endif 	/* __IPropertySystem_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionList_FWD_DEFINED__
-#define __IPropertyDescriptionList_FWD_DEFINED__
-typedef interface IPropertyDescriptionList IPropertyDescriptionList;
-#endif 	/* __IPropertyDescriptionList_FWD_DEFINED__ */
-
-
-#ifndef __IPropertyStoreFactory_FWD_DEFINED__
-#define __IPropertyStoreFactory_FWD_DEFINED__
-typedef interface IPropertyStoreFactory IPropertyStoreFactory;
-#endif 	/* __IPropertyStoreFactory_FWD_DEFINED__ */
-
-
-#ifndef __IDelayedPropertyStoreFactory_FWD_DEFINED__
-#define __IDelayedPropertyStoreFactory_FWD_DEFINED__
-typedef interface IDelayedPropertyStoreFactory IDelayedPropertyStoreFactory;
-#endif 	/* __IDelayedPropertyStoreFactory_FWD_DEFINED__ */
-
-
-#ifndef __IPersistSerializedPropStorage_FWD_DEFINED__
-#define __IPersistSerializedPropStorage_FWD_DEFINED__
-typedef interface IPersistSerializedPropStorage IPersistSerializedPropStorage;
-#endif 	/* __IPersistSerializedPropStorage_FWD_DEFINED__ */
-
-
-#ifndef __IPropertySystemChangeNotify_FWD_DEFINED__
-#define __IPropertySystemChangeNotify_FWD_DEFINED__
-typedef interface IPropertySystemChangeNotify IPropertySystemChangeNotify;
-#endif 	/* __IPropertySystemChangeNotify_FWD_DEFINED__ */
-
-
-#ifndef __ICreateObject_FWD_DEFINED__
-#define __ICreateObject_FWD_DEFINED__
-typedef interface ICreateObject ICreateObject;
-#endif 	/* __ICreateObject_FWD_DEFINED__ */
-
-
-#ifndef __InMemoryPropertyStore_FWD_DEFINED__
-#define __InMemoryPropertyStore_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class InMemoryPropertyStore InMemoryPropertyStore;
-#else
-typedef struct InMemoryPropertyStore InMemoryPropertyStore;
-#endif /* __cplusplus */
-
-#endif 	/* __InMemoryPropertyStore_FWD_DEFINED__ */
-
-
-#ifndef __PropertySystem_FWD_DEFINED__
-#define __PropertySystem_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class PropertySystem PropertySystem;
-#else
-typedef struct PropertySystem PropertySystem;
-#endif /* __cplusplus */
-
-#endif 	/* __PropertySystem_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "objidl.h"
-#include "oleidl.h"
-#include "ocidl.h"
-#include "shtypes.h"
-#include "structuredquery.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_propsys_0000_0000 */
-/* [local] */ 
-
-#ifndef PSSTDAPI
-#if defined(_PROPSYS_)
-#define PSSTDAPI          STDAPI
-#define PSSTDAPI_(type)   STDAPI_(type)
-#else
-#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
-#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
-#endif
-#endif // PSSTDAPI
-#if 0
-typedef PROPERTYKEY *REFPROPERTYKEY;
-
-#endif // 0
-#include <propkeydef.h>
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IInitializeWithFile_INTERFACE_DEFINED__
-#define __IInitializeWithFile_INTERFACE_DEFINED__
-
-/* interface IInitializeWithFile */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IInitializeWithFile;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("b7d14566-0509-4cce-a71f-0a554233bd9b")
-    IInitializeWithFile : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Initialize( 
-            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
-            /* [in] */ DWORD grfMode) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IInitializeWithFileVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IInitializeWithFile * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IInitializeWithFile * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IInitializeWithFile * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
-            IInitializeWithFile * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
-            /* [in] */ DWORD grfMode);
-        
-        END_INTERFACE
-    } IInitializeWithFileVtbl;
-
-    interface IInitializeWithFile
-    {
-        CONST_VTBL struct IInitializeWithFileVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IInitializeWithFile_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IInitializeWithFile_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IInitializeWithFile_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IInitializeWithFile_Initialize(This,pszFilePath,grfMode)	\
-    ( (This)->lpVtbl -> Initialize(This,pszFilePath,grfMode) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IInitializeWithFile_INTERFACE_DEFINED__ */
-
-
-#ifndef __IInitializeWithStream_INTERFACE_DEFINED__
-#define __IInitializeWithStream_INTERFACE_DEFINED__
-
-/* interface IInitializeWithStream */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IInitializeWithStream;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("b824b49d-22ac-4161-ac8a-9916e8fa3f7f")
-    IInitializeWithStream : public IUnknown
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
-            /* [in] */ IStream *pstream,
-            /* [in] */ DWORD grfMode) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IInitializeWithStreamVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IInitializeWithStream * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IInitializeWithStream * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IInitializeWithStream * This);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
-            IInitializeWithStream * This,
-            /* [in] */ IStream *pstream,
-            /* [in] */ DWORD grfMode);
-        
-        END_INTERFACE
-    } IInitializeWithStreamVtbl;
-
-    interface IInitializeWithStream
-    {
-        CONST_VTBL struct IInitializeWithStreamVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IInitializeWithStream_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IInitializeWithStream_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IInitializeWithStream_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IInitializeWithStream_Initialize(This,pstream,grfMode)	\
-    ( (This)->lpVtbl -> Initialize(This,pstream,grfMode) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_RemoteInitialize_Proxy( 
-    IInitializeWithStream * This,
-    /* [in] */ __RPC__in_opt IStream *pstream,
-    /* [in] */ DWORD grfMode);
-
-
-void __RPC_STUB IInitializeWithStream_RemoteInitialize_Stub(
-    IRpcStubBuffer *This,
-    IRpcChannelBuffer *_pRpcChannelBuffer,
-    PRPC_MESSAGE _pRpcMessage,
-    DWORD *_pdwStubPhase);
-
-
-
-#endif 	/* __IInitializeWithStream_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyStore_INTERFACE_DEFINED__
-#define __IPropertyStore_INTERFACE_DEFINED__
-
-/* interface IPropertyStore */
-/* [unique][object][helpstring][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyStore;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")
-    IPropertyStore : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ __RPC__out DWORD *cProps) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAt( 
-            /* [in] */ DWORD iProp,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetValue( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetValue( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyStoreVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyStore * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyStore * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyStore * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPropertyStore * This,
-            /* [out] */ __RPC__out DWORD *cProps);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
-            IPropertyStore * This,
-            /* [in] */ DWORD iProp,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
-            IPropertyStore * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PROPVARIANT *pv);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
-            IPropertyStore * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *Commit )( 
-            IPropertyStore * This);
-        
-        END_INTERFACE
-    } IPropertyStoreVtbl;
-
-    interface IPropertyStore
-    {
-        CONST_VTBL struct IPropertyStoreVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyStore_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyStore_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyStore_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyStore_GetCount(This,cProps)	\
-    ( (This)->lpVtbl -> GetCount(This,cProps) ) 
-
-#define IPropertyStore_GetAt(This,iProp,pkey)	\
-    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 
-
-#define IPropertyStore_GetValue(This,key,pv)	\
-    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 
-
-#define IPropertyStore_SetValue(This,key,propvar)	\
-    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 
-
-#define IPropertyStore_Commit(This)	\
-    ( (This)->lpVtbl -> Commit(This) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyStore_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0003 */
-/* [local] */ 
-
-typedef /* [unique] */  __RPC_unique_pointer IPropertyStore *LPPROPERTYSTORE;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_s_ifspec;
-
-#ifndef __INamedPropertyStore_INTERFACE_DEFINED__
-#define __INamedPropertyStore_INTERFACE_DEFINED__
-
-/* interface INamedPropertyStore */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_INamedPropertyStore;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("71604b0f-97b0-4764-8577-2f13e98a1422")
-    INamedPropertyStore : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetNamedValue( 
-            /* [string][in] */ __RPC__in LPCWSTR pszName,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetNamedValue( 
-            /* [string][in] */ __RPC__in LPCWSTR pszName,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
-            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetNameAt( 
-            /* [in] */ DWORD iProp,
-            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct INamedPropertyStoreVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            INamedPropertyStore * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            INamedPropertyStore * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            INamedPropertyStore * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetNamedValue )( 
-            INamedPropertyStore * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszName,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetNamedValue )( 
-            INamedPropertyStore * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszName,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
-            INamedPropertyStore * This,
-            /* [out] */ __RPC__out DWORD *pdwCount);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetNameAt )( 
-            INamedPropertyStore * This,
-            /* [in] */ DWORD iProp,
-            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
-        
-        END_INTERFACE
-    } INamedPropertyStoreVtbl;
-
-    interface INamedPropertyStore
-    {
-        CONST_VTBL struct INamedPropertyStoreVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define INamedPropertyStore_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define INamedPropertyStore_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define INamedPropertyStore_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define INamedPropertyStore_GetNamedValue(This,pszName,ppropvar)	\
-    ( (This)->lpVtbl -> GetNamedValue(This,pszName,ppropvar) ) 
-
-#define INamedPropertyStore_SetNamedValue(This,pszName,propvar)	\
-    ( (This)->lpVtbl -> SetNamedValue(This,pszName,propvar) ) 
-
-#define INamedPropertyStore_GetNameCount(This,pdwCount)	\
-    ( (This)->lpVtbl -> GetNameCount(This,pdwCount) ) 
-
-#define INamedPropertyStore_GetNameAt(This,iProp,pbstrName)	\
-    ( (This)->lpVtbl -> GetNameAt(This,iProp,pbstrName) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __INamedPropertyStore_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0004 */
-/* [local] */ 
-
-/* [v1_enum] */ 
-enum tagGETPROPERTYSTOREFLAGS
-    {	GPS_DEFAULT	= 0,
-	GPS_HANDLERPROPERTIESONLY	= 0x1,
-	GPS_READWRITE	= 0x2,
-	GPS_TEMPORARY	= 0x4,
-	GPS_FASTPROPERTIESONLY	= 0x8,
-	GPS_OPENSLOWITEM	= 0x10,
-	GPS_DELAYCREATION	= 0x20,
-	GPS_BESTEFFORT	= 0x40,
-	GPS_MASK_VALID	= 0x7f
-    } ;
-typedef int GETPROPERTYSTOREFLAGS;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_s_ifspec;
-
-#ifndef __IObjectWithPropertyKey_INTERFACE_DEFINED__
-#define __IObjectWithPropertyKey_INTERFACE_DEFINED__
-
-/* interface IObjectWithPropertyKey */
-/* [uuid][object] */ 
-
-
-EXTERN_C const IID IID_IObjectWithPropertyKey;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("fc0ca0a7-c316-4fd2-9031-3e628e6d4f23")
-    IObjectWithPropertyKey : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE SetPropertyKey( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
-            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IObjectWithPropertyKeyVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IObjectWithPropertyKey * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IObjectWithPropertyKey * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IObjectWithPropertyKey * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
-            IObjectWithPropertyKey * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
-            IObjectWithPropertyKey * This,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        END_INTERFACE
-    } IObjectWithPropertyKeyVtbl;
-
-    interface IObjectWithPropertyKey
-    {
-        CONST_VTBL struct IObjectWithPropertyKeyVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IObjectWithPropertyKey_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IObjectWithPropertyKey_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IObjectWithPropertyKey_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IObjectWithPropertyKey_SetPropertyKey(This,key)	\
-    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 
-
-#define IObjectWithPropertyKey_GetPropertyKey(This,pkey)	\
-    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IObjectWithPropertyKey_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0005 */
-/* [local] */ 
-
-typedef /* [v1_enum] */ 
-enum tagPKA_FLAGS
-    {	PKA_SET	= 0,
-	PKA_APPEND	= ( PKA_SET + 1 ) ,
-	PKA_DELETE	= ( PKA_APPEND + 1 ) 
-    } 	PKA_FLAGS;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_s_ifspec;
-
-#ifndef __IPropertyChange_INTERFACE_DEFINED__
-#define __IPropertyChange_INTERFACE_DEFINED__
-
-/* interface IPropertyChange */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyChange;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("f917bc8a-1bba-4478-a245-1bde03eb9431")
-    IPropertyChange : public IObjectWithPropertyKey
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE ApplyToPropVariant( 
-            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyChangeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyChange * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyChange * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyChange * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
-            IPropertyChange * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
-            IPropertyChange * This,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *ApplyToPropVariant )( 
-            IPropertyChange * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut);
-        
-        END_INTERFACE
-    } IPropertyChangeVtbl;
-
-    interface IPropertyChange
-    {
-        CONST_VTBL struct IPropertyChangeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyChange_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyChange_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyChange_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyChange_SetPropertyKey(This,key)	\
-    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 
-
-#define IPropertyChange_GetPropertyKey(This,pkey)	\
-    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
-
-
-#define IPropertyChange_ApplyToPropVariant(This,propvarIn,ppropvarOut)	\
-    ( (This)->lpVtbl -> ApplyToPropVariant(This,propvarIn,ppropvarOut) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyChange_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyChangeArray_INTERFACE_DEFINED__
-#define __IPropertyChangeArray_INTERFACE_DEFINED__
-
-/* interface IPropertyChangeArray */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyChangeArray;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("380f5cad-1b5e-42f2-805d-637fd392d31e")
-    IPropertyChangeArray : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ __RPC__out UINT *pcOperations) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAt( 
-            /* [in] */ UINT iIndex,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
-            /* [in] */ UINT iIndex,
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Append( 
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE AppendOrReplace( 
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
-            /* [in] */ UINT iIndex) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE IsKeyInArray( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyChangeArrayVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyChangeArray * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyChangeArray * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyChangeArray * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPropertyChangeArray * This,
-            /* [out] */ __RPC__out UINT *pcOperations);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
-            IPropertyChangeArray * This,
-            /* [in] */ UINT iIndex,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
-            IPropertyChangeArray * This,
-            /* [in] */ UINT iIndex,
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
-        
-        HRESULT ( STDMETHODCALLTYPE *Append )( 
-            IPropertyChangeArray * This,
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
-        
-        HRESULT ( STDMETHODCALLTYPE *AppendOrReplace )( 
-            IPropertyChangeArray * This,
-            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
-        
-        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
-            IPropertyChangeArray * This,
-            /* [in] */ UINT iIndex);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsKeyInArray )( 
-            IPropertyChangeArray * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key);
-        
-        END_INTERFACE
-    } IPropertyChangeArrayVtbl;
-
-    interface IPropertyChangeArray
-    {
-        CONST_VTBL struct IPropertyChangeArrayVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyChangeArray_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyChangeArray_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyChangeArray_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyChangeArray_GetCount(This,pcOperations)	\
-    ( (This)->lpVtbl -> GetCount(This,pcOperations) ) 
-
-#define IPropertyChangeArray_GetAt(This,iIndex,riid,ppv)	\
-    ( (This)->lpVtbl -> GetAt(This,iIndex,riid,ppv) ) 
-
-#define IPropertyChangeArray_InsertAt(This,iIndex,ppropChange)	\
-    ( (This)->lpVtbl -> InsertAt(This,iIndex,ppropChange) ) 
-
-#define IPropertyChangeArray_Append(This,ppropChange)	\
-    ( (This)->lpVtbl -> Append(This,ppropChange) ) 
-
-#define IPropertyChangeArray_AppendOrReplace(This,ppropChange)	\
-    ( (This)->lpVtbl -> AppendOrReplace(This,ppropChange) ) 
-
-#define IPropertyChangeArray_RemoveAt(This,iIndex)	\
-    ( (This)->lpVtbl -> RemoveAt(This,iIndex) ) 
-
-#define IPropertyChangeArray_IsKeyInArray(This,key)	\
-    ( (This)->lpVtbl -> IsKeyInArray(This,key) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyChangeArray_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyStoreCapabilities_INTERFACE_DEFINED__
-#define __IPropertyStoreCapabilities_INTERFACE_DEFINED__
-
-/* interface IPropertyStoreCapabilities */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyStoreCapabilities;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("c8e2d566-186e-4d49-bf41-6909ead56acc")
-    IPropertyStoreCapabilities : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE IsPropertyWritable( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyStoreCapabilitiesVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyStoreCapabilities * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyStoreCapabilities * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyStoreCapabilities * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsPropertyWritable )( 
-            IPropertyStoreCapabilities * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key);
-        
-        END_INTERFACE
-    } IPropertyStoreCapabilitiesVtbl;
-
-    interface IPropertyStoreCapabilities
-    {
-        CONST_VTBL struct IPropertyStoreCapabilitiesVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyStoreCapabilities_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyStoreCapabilities_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyStoreCapabilities_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyStoreCapabilities_IsPropertyWritable(This,key)	\
-    ( (This)->lpVtbl -> IsPropertyWritable(This,key) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyStoreCapabilities_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyStoreCache_INTERFACE_DEFINED__
-#define __IPropertyStoreCache_INTERFACE_DEFINED__
-
-/* interface IPropertyStoreCache */
-/* [unique][object][uuid] */ 
-
-typedef /* [v1_enum] */ 
-enum _PSC_STATE
-    {	PSC_NORMAL	= 0,
-	PSC_NOTINSOURCE	= 1,
-	PSC_DIRTY	= 2,
-	PSC_READONLY	= 3
-    } 	PSC_STATE;
-
-
-EXTERN_C const IID IID_IPropertyStoreCache;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("3017056d-9a91-4e90-937d-746c72abbf4f")
-    IPropertyStoreCache : public IPropertyStore
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetState( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetValueAndState( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
-            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetState( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ PSC_STATE state) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetValueAndState( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
-            /* [in] */ PSC_STATE state) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyStoreCacheVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyStoreCache * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyStoreCache * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPropertyStoreCache * This,
-            /* [out] */ __RPC__out DWORD *cProps);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
-            IPropertyStoreCache * This,
-            /* [in] */ DWORD iProp,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PROPVARIANT *pv);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *Commit )( 
-            IPropertyStoreCache * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetState )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PSC_STATE *pstate);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValueAndState )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
-            /* [out] */ __RPC__out PSC_STATE *pstate);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetState )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ PSC_STATE state);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetValueAndState )( 
-            IPropertyStoreCache * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
-            /* [in] */ PSC_STATE state);
-        
-        END_INTERFACE
-    } IPropertyStoreCacheVtbl;
-
-    interface IPropertyStoreCache
-    {
-        CONST_VTBL struct IPropertyStoreCacheVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyStoreCache_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyStoreCache_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyStoreCache_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyStoreCache_GetCount(This,cProps)	\
-    ( (This)->lpVtbl -> GetCount(This,cProps) ) 
-
-#define IPropertyStoreCache_GetAt(This,iProp,pkey)	\
-    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 
-
-#define IPropertyStoreCache_GetValue(This,key,pv)	\
-    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 
-
-#define IPropertyStoreCache_SetValue(This,key,propvar)	\
-    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 
-
-#define IPropertyStoreCache_Commit(This)	\
-    ( (This)->lpVtbl -> Commit(This) ) 
-
-
-#define IPropertyStoreCache_GetState(This,key,pstate)	\
-    ( (This)->lpVtbl -> GetState(This,key,pstate) ) 
-
-#define IPropertyStoreCache_GetValueAndState(This,key,ppropvar,pstate)	\
-    ( (This)->lpVtbl -> GetValueAndState(This,key,ppropvar,pstate) ) 
-
-#define IPropertyStoreCache_SetState(This,key,state)	\
-    ( (This)->lpVtbl -> SetState(This,key,state) ) 
-
-#define IPropertyStoreCache_SetValueAndState(This,key,ppropvar,state)	\
-    ( (This)->lpVtbl -> SetValueAndState(This,key,ppropvar,state) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyStoreCache_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyEnumType_INTERFACE_DEFINED__
-#define __IPropertyEnumType_INTERFACE_DEFINED__
-
-/* interface IPropertyEnumType */
-/* [unique][object][uuid] */ 
-
-/* [v1_enum] */ 
-enum tagPROPENUMTYPE
-    {	PET_DISCRETEVALUE	= 0,
-	PET_RANGEDVALUE	= 1,
-	PET_DEFAULTVALUE	= 2,
-	PET_ENDRANGE	= 3
-    } ;
-typedef enum tagPROPENUMTYPE PROPENUMTYPE;
-
-
-EXTERN_C const IID IID_IPropertyEnumType;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("11e1fbf9-2d56-4a6b-8db3-7cd193a471f2")
-    IPropertyEnumType : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetEnumType( 
-            /* [out] */ __RPC__out PROPENUMTYPE *penumtype) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetValue( 
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetRangeMinValue( 
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetRangeSetValue( 
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetDisplayText( 
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyEnumTypeVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyEnumType * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyEnumType * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyEnumType * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
-            IPropertyEnumType * This,
-            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
-            IPropertyEnumType * This,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
-            IPropertyEnumType * This,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
-            IPropertyEnumType * This,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
-            IPropertyEnumType * This,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
-        
-        END_INTERFACE
-    } IPropertyEnumTypeVtbl;
-
-    interface IPropertyEnumType
-    {
-        CONST_VTBL struct IPropertyEnumTypeVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyEnumType_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyEnumType_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyEnumType_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyEnumType_GetEnumType(This,penumtype)	\
-    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 
-
-#define IPropertyEnumType_GetValue(This,ppropvar)	\
-    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 
-
-#define IPropertyEnumType_GetRangeMinValue(This,ppropvarMin)	\
-    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 
-
-#define IPropertyEnumType_GetRangeSetValue(This,ppropvarSet)	\
-    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 
-
-#define IPropertyEnumType_GetDisplayText(This,ppszDisplay)	\
-    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyEnumType_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyEnumTypeList_INTERFACE_DEFINED__
-#define __IPropertyEnumTypeList_INTERFACE_DEFINED__
-
-/* interface IPropertyEnumTypeList */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyEnumTypeList;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("a99400f4-3d84-4557-94ba-1242fb2cc9a6")
-    IPropertyEnumTypeList : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ __RPC__out UINT *pctypes) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAt( 
-            /* [in] */ UINT itype,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetConditionAt( 
-            /* [in] */ UINT nIndex,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE FindMatchingIndex( 
-            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
-            /* [out] */ __RPC__out UINT *pnIndex) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyEnumTypeListVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyEnumTypeList * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyEnumTypeList * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyEnumTypeList * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPropertyEnumTypeList * This,
-            /* [out] */ __RPC__out UINT *pctypes);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
-            IPropertyEnumTypeList * This,
-            /* [in] */ UINT itype,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetConditionAt )( 
-            IPropertyEnumTypeList * This,
-            /* [in] */ UINT nIndex,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *FindMatchingIndex )( 
-            IPropertyEnumTypeList * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
-            /* [out] */ __RPC__out UINT *pnIndex);
-        
-        END_INTERFACE
-    } IPropertyEnumTypeListVtbl;
-
-    interface IPropertyEnumTypeList
-    {
-        CONST_VTBL struct IPropertyEnumTypeListVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyEnumTypeList_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyEnumTypeList_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyEnumTypeList_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyEnumTypeList_GetCount(This,pctypes)	\
-    ( (This)->lpVtbl -> GetCount(This,pctypes) ) 
-
-#define IPropertyEnumTypeList_GetAt(This,itype,riid,ppv)	\
-    ( (This)->lpVtbl -> GetAt(This,itype,riid,ppv) ) 
-
-#define IPropertyEnumTypeList_GetConditionAt(This,nIndex,riid,ppv)	\
-    ( (This)->lpVtbl -> GetConditionAt(This,nIndex,riid,ppv) ) 
-
-#define IPropertyEnumTypeList_FindMatchingIndex(This,propvarCmp,pnIndex)	\
-    ( (This)->lpVtbl -> FindMatchingIndex(This,propvarCmp,pnIndex) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyEnumTypeList_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyDescription_INTERFACE_DEFINED__
-#define __IPropertyDescription_INTERFACE_DEFINED__
-
-/* interface IPropertyDescription */
-/* [unique][object][uuid] */ 
-
-/* [v1_enum] */ 
-enum tagPROPDESC_TYPE_FLAGS
-    {	PDTF_DEFAULT	= 0,
-	PDTF_MULTIPLEVALUES	= 0x1,
-	PDTF_ISINNATE	= 0x2,
-	PDTF_ISGROUP	= 0x4,
-	PDTF_CANGROUPBY	= 0x8,
-	PDTF_CANSTACKBY	= 0x10,
-	PDTF_ISTREEPROPERTY	= 0x20,
-	PDTF_INCLUDEINFULLTEXTQUERY	= 0x40,
-	PDTF_ISVIEWABLE	= 0x80,
-	PDTF_ISQUERYABLE	= 0x100,
-	PDTF_ISSYSTEMPROPERTY	= 0x80000000,
-	PDTF_MASK_ALL	= 0x800001ff
-    } ;
-typedef int PROPDESC_TYPE_FLAGS;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_VIEW_FLAGS
-    {	PDVF_DEFAULT	= 0,
-	PDVF_CENTERALIGN	= 0x1,
-	PDVF_RIGHTALIGN	= 0x2,
-	PDVF_BEGINNEWGROUP	= 0x4,
-	PDVF_FILLAREA	= 0x8,
-	PDVF_SORTDESCENDING	= 0x10,
-	PDVF_SHOWONLYIFPRESENT	= 0x20,
-	PDVF_SHOWBYDEFAULT	= 0x40,
-	PDVF_SHOWINPRIMARYLIST	= 0x80,
-	PDVF_SHOWINSECONDARYLIST	= 0x100,
-	PDVF_HIDELABEL	= 0x200,
-	PDVF_HIDDEN	= 0x800,
-	PDVF_CANWRAP	= 0x1000,
-	PDVF_MASK_ALL	= 0x1bff
-    } ;
-typedef int PROPDESC_VIEW_FLAGS;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_DISPLAYTYPE
-    {	PDDT_STRING	= 0,
-	PDDT_NUMBER	= 1,
-	PDDT_BOOLEAN	= 2,
-	PDDT_DATETIME	= 3,
-	PDDT_ENUMERATED	= 4
-    } ;
-typedef enum tagPROPDESC_DISPLAYTYPE PROPDESC_DISPLAYTYPE;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_GROUPING_RANGE
-    {	PDGR_DISCRETE	= 0,
-	PDGR_ALPHANUMERIC	= 1,
-	PDGR_SIZE	= 2,
-	PDGR_DYNAMIC	= 3,
-	PDGR_DATE	= 4,
-	PDGR_PERCENT	= 5,
-	PDGR_ENUMERATED	= 6
-    } ;
-typedef enum tagPROPDESC_GROUPING_RANGE PROPDESC_GROUPING_RANGE;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_FORMAT_FLAGS
-    {	PDFF_DEFAULT	= 0,
-	PDFF_PREFIXNAME	= 0x1,
-	PDFF_FILENAME	= 0x2,
-	PDFF_ALWAYSKB	= 0x4,
-	PDFF_RESERVED_RIGHTTOLEFT	= 0x8,
-	PDFF_SHORTTIME	= 0x10,
-	PDFF_LONGTIME	= 0x20,
-	PDFF_HIDETIME	= 0x40,
-	PDFF_SHORTDATE	= 0x80,
-	PDFF_LONGDATE	= 0x100,
-	PDFF_HIDEDATE	= 0x200,
-	PDFF_RELATIVEDATE	= 0x400,
-	PDFF_USEEDITINVITATION	= 0x800,
-	PDFF_READONLY	= 0x1000,
-	PDFF_NOAUTOREADINGORDER	= 0x2000
-    } ;
-typedef int PROPDESC_FORMAT_FLAGS;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_SORTDESCRIPTION
-    {	PDSD_GENERAL	= 0,
-	PDSD_A_Z	= 1,
-	PDSD_LOWEST_HIGHEST	= 2,
-	PDSD_SMALLEST_BIGGEST	= 3,
-	PDSD_OLDEST_NEWEST	= 4
-    } ;
-typedef enum tagPROPDESC_SORTDESCRIPTION PROPDESC_SORTDESCRIPTION;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE
-    {	PDRDT_GENERAL	= 0,
-	PDRDT_DATE	= 1,
-	PDRDT_SIZE	= 2,
-	PDRDT_COUNT	= 3,
-	PDRDT_REVISION	= 4,
-	PDRDT_LENGTH	= 5,
-	PDRDT_DURATION	= 6,
-	PDRDT_SPEED	= 7,
-	PDRDT_RATE	= 8,
-	PDRDT_RATING	= 9,
-	PDRDT_PRIORITY	= 10
-    } ;
-typedef enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE PROPDESC_RELATIVEDESCRIPTION_TYPE;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_AGGREGATION_TYPE
-    {	PDAT_DEFAULT	= 0,
-	PDAT_FIRST	= 1,
-	PDAT_SUM	= 2,
-	PDAT_AVERAGE	= 3,
-	PDAT_DATERANGE	= 4,
-	PDAT_UNION	= 5,
-	PDAT_MAX	= 6,
-	PDAT_MIN	= 7
-    } ;
-typedef enum tagPROPDESC_AGGREGATION_TYPE PROPDESC_AGGREGATION_TYPE;
-
-/* [v1_enum] */ 
-enum tagPROPDESC_CONDITION_TYPE
-    {	PDCOT_NONE	= 0,
-	PDCOT_STRING	= 1,
-	PDCOT_SIZE	= 2,
-	PDCOT_DATETIME	= 3,
-	PDCOT_BOOLEAN	= 4,
-	PDCOT_NUMBER	= 5
-    } ;
-typedef enum tagPROPDESC_CONDITION_TYPE PROPDESC_CONDITION_TYPE;
-
-
-EXTERN_C const IID IID_IPropertyDescription;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("6f79d558-3e96-4549-a1d1-7d75d2288814")
-    IPropertyDescription : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
-            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
-            /* [out] */ __RPC__out VARTYPE *pvartype) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetEditInvitation( 
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
-            /* [in] */ PROPDESC_TYPE_FLAGS mask,
-            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
-            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnWidth( 
-            /* [out] */ __RPC__out UINT *pcxChars) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetDisplayType( 
-            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetColumnState( 
-            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetGroupingRange( 
-            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescriptionType( 
-            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescription( 
-            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetSortDescription( 
-            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetSortDescriptionLabel( 
-            /* [in] */ BOOL fDescending,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAggregationType( 
-            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
-            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
-            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetEnumTypeList( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CoerceToCanonicalValue( 
-            /* [out][in] */ PROPVARIANT *ppropvar) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE IsValueCanonical( 
-            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyDescriptionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyDescription * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyDescription * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyDescription * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
-            IPropertyDescription * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out VARTYPE *pvartype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
-            IPropertyDescription * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
-            IPropertyDescription * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
-            IPropertyDescription * This,
-            /* [in] */ PROPDESC_TYPE_FLAGS mask,
-            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out UINT *pcxChars);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
-            IPropertyDescription * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
-            IPropertyDescription * This,
-            /* [in] */ BOOL fDescending,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
-            IPropertyDescription * This,
-            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
-            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
-            IPropertyDescription * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
-            IPropertyDescription * This,
-            /* [out][in] */ PROPVARIANT *ppropvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
-            IPropertyDescription * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
-            IPropertyDescription * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        END_INTERFACE
-    } IPropertyDescriptionVtbl;
-
-    interface IPropertyDescription
-    {
-        CONST_VTBL struct IPropertyDescriptionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyDescription_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyDescription_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyDescription_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyDescription_GetPropertyKey(This,pkey)	\
-    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
-
-#define IPropertyDescription_GetCanonicalName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
-
-#define IPropertyDescription_GetPropertyType(This,pvartype)	\
-    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
-
-#define IPropertyDescription_GetDisplayName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
-
-#define IPropertyDescription_GetEditInvitation(This,ppszInvite)	\
-    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
-
-#define IPropertyDescription_GetTypeFlags(This,mask,ppdtFlags)	\
-    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
-
-#define IPropertyDescription_GetViewFlags(This,ppdvFlags)	\
-    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
-
-#define IPropertyDescription_GetDefaultColumnWidth(This,pcxChars)	\
-    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
-
-#define IPropertyDescription_GetDisplayType(This,pdisplaytype)	\
-    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
-
-#define IPropertyDescription_GetColumnState(This,pcsFlags)	\
-    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
-
-#define IPropertyDescription_GetGroupingRange(This,pgr)	\
-    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
-
-#define IPropertyDescription_GetRelativeDescriptionType(This,prdt)	\
-    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
-
-#define IPropertyDescription_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
-    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
-
-#define IPropertyDescription_GetSortDescription(This,psd)	\
-    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
-
-#define IPropertyDescription_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
-    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
-
-#define IPropertyDescription_GetAggregationType(This,paggtype)	\
-    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
-
-#define IPropertyDescription_GetConditionType(This,pcontype,popDefault)	\
-    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
-
-#define IPropertyDescription_GetEnumTypeList(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
-
-#define IPropertyDescription_CoerceToCanonicalValue(This,ppropvar)	\
-    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
-
-#define IPropertyDescription_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
-    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
-
-#define IPropertyDescription_IsValueCanonical(This,propvar)	\
-    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_RemoteCoerceToCanonicalValue_Proxy( 
-    IPropertyDescription * This,
-    /* [in] */ __RPC__in REFPROPVARIANT propvar,
-    /* [out] */ __RPC__out PROPVARIANT *ppropvar);
-
-
-void __RPC_STUB IPropertyDescription_RemoteCoerceToCanonicalValue_Stub(
-    IRpcStubBuffer *This,
-    IRpcChannelBuffer *_pRpcChannelBuffer,
-    PRPC_MESSAGE _pRpcMessage,
-    DWORD *_pdwStubPhase);
-
-
-
-#endif 	/* __IPropertyDescription_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
-#define __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
-
-/* interface IPropertyDescriptionAliasInfo */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyDescriptionAliasInfo;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("f67104fc-2af9-46fd-b32d-243c1404f3d1")
-    IPropertyDescriptionAliasInfo : public IPropertyDescription
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetSortByAlias( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAdditionalSortByAliases( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyDescriptionAliasInfoVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyDescriptionAliasInfo * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyDescriptionAliasInfo * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out VARTYPE *pvartype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ PROPDESC_TYPE_FLAGS mask,
-            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out UINT *pcxChars);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ BOOL fDescending,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
-            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [out][in] */ PROPVARIANT *ppropvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortByAlias )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAdditionalSortByAliases )( 
-            IPropertyDescriptionAliasInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        END_INTERFACE
-    } IPropertyDescriptionAliasInfoVtbl;
-
-    interface IPropertyDescriptionAliasInfo
-    {
-        CONST_VTBL struct IPropertyDescriptionAliasInfoVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyDescriptionAliasInfo_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyDescriptionAliasInfo_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyDescriptionAliasInfo_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyDescriptionAliasInfo_GetPropertyKey(This,pkey)	\
-    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
-
-#define IPropertyDescriptionAliasInfo_GetCanonicalName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
-
-#define IPropertyDescriptionAliasInfo_GetPropertyType(This,pvartype)	\
-    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
-
-#define IPropertyDescriptionAliasInfo_GetDisplayName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
-
-#define IPropertyDescriptionAliasInfo_GetEditInvitation(This,ppszInvite)	\
-    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
-
-#define IPropertyDescriptionAliasInfo_GetTypeFlags(This,mask,ppdtFlags)	\
-    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
-
-#define IPropertyDescriptionAliasInfo_GetViewFlags(This,ppdvFlags)	\
-    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
-
-#define IPropertyDescriptionAliasInfo_GetDefaultColumnWidth(This,pcxChars)	\
-    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
-
-#define IPropertyDescriptionAliasInfo_GetDisplayType(This,pdisplaytype)	\
-    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
-
-#define IPropertyDescriptionAliasInfo_GetColumnState(This,pcsFlags)	\
-    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
-
-#define IPropertyDescriptionAliasInfo_GetGroupingRange(This,pgr)	\
-    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
-
-#define IPropertyDescriptionAliasInfo_GetRelativeDescriptionType(This,prdt)	\
-    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
-
-#define IPropertyDescriptionAliasInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
-    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
-
-#define IPropertyDescriptionAliasInfo_GetSortDescription(This,psd)	\
-    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
-
-#define IPropertyDescriptionAliasInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
-    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
-
-#define IPropertyDescriptionAliasInfo_GetAggregationType(This,paggtype)	\
-    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
-
-#define IPropertyDescriptionAliasInfo_GetConditionType(This,pcontype,popDefault)	\
-    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
-
-#define IPropertyDescriptionAliasInfo_GetEnumTypeList(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
-
-#define IPropertyDescriptionAliasInfo_CoerceToCanonicalValue(This,ppropvar)	\
-    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
-
-#define IPropertyDescriptionAliasInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
-    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
-
-#define IPropertyDescriptionAliasInfo_IsValueCanonical(This,propvar)	\
-    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
-
-
-#define IPropertyDescriptionAliasInfo_GetSortByAlias(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetSortByAlias(This,riid,ppv) ) 
-
-#define IPropertyDescriptionAliasInfo_GetAdditionalSortByAliases(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetAdditionalSortByAliases(This,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
-#define __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
-
-/* interface IPropertyDescriptionSearchInfo */
-/* [unique][object][uuid] */ 
-
-/* [v1_enum] */ 
-enum tagPROPDESC_SEARCHINFO_FLAGS
-    {	PDSIF_DEFAULT	= 0,
-	PDSIF_ININVERTEDINDEX	= 0x1,
-	PDSIF_ISCOLUMN	= 0x2,
-	PDSIF_ISCOLUMNSPARSE	= 0x4
-    } ;
-typedef int PROPDESC_SEARCHINFO_FLAGS;
-
-typedef /* [v1_enum] */ 
-enum tagPROPDESC_COLUMNINDEX_TYPE
-    {	PDCIT_NONE	= 0,
-	PDCIT_ONDISK	= 1,
-	PDCIT_INMEMORY	= 2
-    } 	PROPDESC_COLUMNINDEX_TYPE;
-
-
-EXTERN_C const IID IID_IPropertyDescriptionSearchInfo;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("078f91bd-29a2-440f-924e-46a291524520")
-    IPropertyDescriptionSearchInfo : public IPropertyDescription
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetSearchInfoFlags( 
-            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetColumnIndexType( 
-            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetProjectionString( 
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
-            /* [out] */ __RPC__out UINT *pcbMaxSize) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyDescriptionSearchInfoVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyDescriptionSearchInfo * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyDescriptionSearchInfo * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPERTYKEY *pkey);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out VARTYPE *pvartype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ PROPDESC_TYPE_FLAGS mask,
-            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out UINT *pcxChars);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ BOOL fDescending,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
-            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out][in] */ PROPVARIANT *ppropvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSearchInfoFlags )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetColumnIndexType )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetProjectionString )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
-            IPropertyDescriptionSearchInfo * This,
-            /* [out] */ __RPC__out UINT *pcbMaxSize);
-        
-        END_INTERFACE
-    } IPropertyDescriptionSearchInfoVtbl;
-
-    interface IPropertyDescriptionSearchInfo
-    {
-        CONST_VTBL struct IPropertyDescriptionSearchInfoVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyDescriptionSearchInfo_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyDescriptionSearchInfo_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyDescriptionSearchInfo_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyDescriptionSearchInfo_GetPropertyKey(This,pkey)	\
-    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
-
-#define IPropertyDescriptionSearchInfo_GetCanonicalName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
-
-#define IPropertyDescriptionSearchInfo_GetPropertyType(This,pvartype)	\
-    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
-
-#define IPropertyDescriptionSearchInfo_GetDisplayName(This,ppszName)	\
-    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
-
-#define IPropertyDescriptionSearchInfo_GetEditInvitation(This,ppszInvite)	\
-    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
-
-#define IPropertyDescriptionSearchInfo_GetTypeFlags(This,mask,ppdtFlags)	\
-    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
-
-#define IPropertyDescriptionSearchInfo_GetViewFlags(This,ppdvFlags)	\
-    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
-
-#define IPropertyDescriptionSearchInfo_GetDefaultColumnWidth(This,pcxChars)	\
-    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
-
-#define IPropertyDescriptionSearchInfo_GetDisplayType(This,pdisplaytype)	\
-    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
-
-#define IPropertyDescriptionSearchInfo_GetColumnState(This,pcsFlags)	\
-    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
-
-#define IPropertyDescriptionSearchInfo_GetGroupingRange(This,pgr)	\
-    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
-
-#define IPropertyDescriptionSearchInfo_GetRelativeDescriptionType(This,prdt)	\
-    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
-
-#define IPropertyDescriptionSearchInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
-    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
-
-#define IPropertyDescriptionSearchInfo_GetSortDescription(This,psd)	\
-    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
-
-#define IPropertyDescriptionSearchInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
-    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
-
-#define IPropertyDescriptionSearchInfo_GetAggregationType(This,paggtype)	\
-    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
-
-#define IPropertyDescriptionSearchInfo_GetConditionType(This,pcontype,popDefault)	\
-    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
-
-#define IPropertyDescriptionSearchInfo_GetEnumTypeList(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
-
-#define IPropertyDescriptionSearchInfo_CoerceToCanonicalValue(This,ppropvar)	\
-    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
-
-#define IPropertyDescriptionSearchInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
-    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
-
-#define IPropertyDescriptionSearchInfo_IsValueCanonical(This,propvar)	\
-    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
-
-
-#define IPropertyDescriptionSearchInfo_GetSearchInfoFlags(This,ppdsiFlags)	\
-    ( (This)->lpVtbl -> GetSearchInfoFlags(This,ppdsiFlags) ) 
-
-#define IPropertyDescriptionSearchInfo_GetColumnIndexType(This,ppdciType)	\
-    ( (This)->lpVtbl -> GetColumnIndexType(This,ppdciType) ) 
-
-#define IPropertyDescriptionSearchInfo_GetProjectionString(This,ppszProjection)	\
-    ( (This)->lpVtbl -> GetProjectionString(This,ppszProjection) ) 
-
-#define IPropertyDescriptionSearchInfo_GetMaxSize(This,pcbMaxSize)	\
-    ( (This)->lpVtbl -> GetMaxSize(This,pcbMaxSize) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0014 */
-/* [local] */ 
-
-/* [v1_enum] */ 
-enum tagPROPDESC_ENUMFILTER
-    {	PDEF_ALL	= 0,
-	PDEF_SYSTEM	= 1,
-	PDEF_NONSYSTEM	= 2,
-	PDEF_VIEWABLE	= 3,
-	PDEF_QUERYABLE	= 4,
-	PDEF_INFULLTEXTQUERY	= 5,
-	PDEF_COLUMN	= 6
-    } ;
-typedef enum tagPROPDESC_ENUMFILTER PROPDESC_ENUMFILTER;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_s_ifspec;
-
-#ifndef __IPropertySystem_INTERFACE_DEFINED__
-#define __IPropertySystem_INTERFACE_DEFINED__
-
-/* interface IPropertySystem */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertySystem;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("ca724e8a-c3e6-442b-88a4-6fb0db8035a3")
-    IPropertySystem : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
-            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionByName( 
-            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionListFromString( 
-            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE EnumeratePropertyDescriptions( 
-            /* [in] */ PROPDESC_ENUMFILTER filterOn,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
-            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
-            /* [in] */ DWORD cchText) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE FormatForDisplayAlloc( 
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RegisterPropertySchema( 
-            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE UnregisterPropertySchema( 
-            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RefreshPropertySchema( void) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertySystemVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertySystem * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertySystem * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertySystem * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
-            IPropertySystem * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionByName )( 
-            IPropertySystem * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionListFromString )( 
-            IPropertySystem * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *EnumeratePropertyDescriptions )( 
-            IPropertySystem * This,
-            /* [in] */ PROPDESC_ENUMFILTER filterOn,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
-            IPropertySystem * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
-            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
-            /* [in] */ DWORD cchText);
-        
-        HRESULT ( STDMETHODCALLTYPE *FormatForDisplayAlloc )( 
-            IPropertySystem * This,
-            /* [in] */ __RPC__in REFPROPERTYKEY key,
-            /* [in] */ __RPC__in REFPROPVARIANT propvar,
-            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
-            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
-        
-        HRESULT ( STDMETHODCALLTYPE *RegisterPropertySchema )( 
-            IPropertySystem * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszPath);
-        
-        HRESULT ( STDMETHODCALLTYPE *UnregisterPropertySchema )( 
-            IPropertySystem * This,
-            /* [string][in] */ __RPC__in LPCWSTR pszPath);
-        
-        HRESULT ( STDMETHODCALLTYPE *RefreshPropertySchema )( 
-            IPropertySystem * This);
-        
-        END_INTERFACE
-    } IPropertySystemVtbl;
-
-    interface IPropertySystem
-    {
-        CONST_VTBL struct IPropertySystemVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertySystem_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertySystem_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertySystem_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertySystem_GetPropertyDescription(This,propkey,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyDescription(This,propkey,riid,ppv) ) 
-
-#define IPropertySystem_GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv) ) 
-
-#define IPropertySystem_GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv) ) 
-
-#define IPropertySystem_EnumeratePropertyDescriptions(This,filterOn,riid,ppv)	\
-    ( (This)->lpVtbl -> EnumeratePropertyDescriptions(This,filterOn,riid,ppv) ) 
-
-#define IPropertySystem_FormatForDisplay(This,key,propvar,pdff,pszText,cchText)	\
-    ( (This)->lpVtbl -> FormatForDisplay(This,key,propvar,pdff,pszText,cchText) ) 
-
-#define IPropertySystem_FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay)	\
-    ( (This)->lpVtbl -> FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay) ) 
-
-#define IPropertySystem_RegisterPropertySchema(This,pszPath)	\
-    ( (This)->lpVtbl -> RegisterPropertySchema(This,pszPath) ) 
-
-#define IPropertySystem_UnregisterPropertySchema(This,pszPath)	\
-    ( (This)->lpVtbl -> UnregisterPropertySchema(This,pszPath) ) 
-
-#define IPropertySystem_RefreshPropertySchema(This)	\
-    ( (This)->lpVtbl -> RefreshPropertySchema(This) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertySystem_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyDescriptionList_INTERFACE_DEFINED__
-#define __IPropertyDescriptionList_INTERFACE_DEFINED__
-
-/* interface IPropertyDescriptionList */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyDescriptionList;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("1f9fc1d0-c39b-4b26-817f-011967d3440e")
-    IPropertyDescriptionList : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetCount( 
-            /* [out] */ __RPC__out UINT *pcElem) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetAt( 
-            /* [in] */ UINT iElem,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyDescriptionListVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyDescriptionList * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyDescriptionList * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyDescriptionList * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
-            IPropertyDescriptionList * This,
-            /* [out] */ __RPC__out UINT *pcElem);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
-            IPropertyDescriptionList * This,
-            /* [in] */ UINT iElem,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        END_INTERFACE
-    } IPropertyDescriptionListVtbl;
-
-    interface IPropertyDescriptionList
-    {
-        CONST_VTBL struct IPropertyDescriptionListVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyDescriptionList_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyDescriptionList_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyDescriptionList_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyDescriptionList_GetCount(This,pcElem)	\
-    ( (This)->lpVtbl -> GetCount(This,pcElem) ) 
-
-#define IPropertyDescriptionList_GetAt(This,iElem,riid,ppv)	\
-    ( (This)->lpVtbl -> GetAt(This,iElem,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyDescriptionList_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertyStoreFactory_INTERFACE_DEFINED__
-#define __IPropertyStoreFactory_INTERFACE_DEFINED__
-
-/* interface IPropertyStoreFactory */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertyStoreFactory;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("bc110b6d-57e8-4148-a9c6-91015ab2f3a5")
-    IPropertyStoreFactory : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
-            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
-            /* [in] */ UINT cKeys,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertyStoreFactoryVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertyStoreFactory * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertyStoreFactory * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertyStoreFactory * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
-            IPropertyStoreFactory * This,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
-            IPropertyStoreFactory * This,
-            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
-            /* [in] */ UINT cKeys,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        END_INTERFACE
-    } IPropertyStoreFactoryVtbl;
-
-    interface IPropertyStoreFactory
-    {
-        CONST_VTBL struct IPropertyStoreFactoryVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertyStoreFactory_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertyStoreFactory_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 
-
-#define IPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertyStoreFactory_INTERFACE_DEFINED__ */
-
-
-#ifndef __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
-#define __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
-
-/* interface IDelayedPropertyStoreFactory */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IDelayedPropertyStoreFactory;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("40d4577f-e237-4bdb-bd69-58f089431b6a")
-    IDelayedPropertyStoreFactory : public IPropertyStoreFactory
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetDelayedPropertyStore( 
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [in] */ DWORD dwStoreId,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IDelayedPropertyStoreFactoryVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IDelayedPropertyStoreFactory * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IDelayedPropertyStoreFactory * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IDelayedPropertyStoreFactory * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
-            IDelayedPropertyStoreFactory * This,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
-            IDelayedPropertyStoreFactory * This,
-            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
-            /* [in] */ UINT cKeys,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetDelayedPropertyStore )( 
-            IDelayedPropertyStoreFactory * This,
-            /* [in] */ GETPROPERTYSTOREFLAGS flags,
-            /* [in] */ DWORD dwStoreId,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        END_INTERFACE
-    } IDelayedPropertyStoreFactoryVtbl;
-
-    interface IDelayedPropertyStoreFactory
-    {
-        CONST_VTBL struct IDelayedPropertyStoreFactoryVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IDelayedPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IDelayedPropertyStoreFactory_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IDelayedPropertyStoreFactory_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IDelayedPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 
-
-#define IDelayedPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
-    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 
-
-
-#define IDelayedPropertyStoreFactory_GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv)	\
-    ( (This)->lpVtbl -> GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0018 */
-/* [local] */ 
-
-/* [v1_enum] */ 
-enum tagPERSIST_SPROPSTORE_FLAGS
-    {	FPSPS_READONLY	= 0x1
-    } ;
-typedef int PERSIST_SPROPSTORE_FLAGS;
-
-typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE;
-
-typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;
-
-typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_s_ifspec;
-
-#ifndef __IPersistSerializedPropStorage_INTERFACE_DEFINED__
-#define __IPersistSerializedPropStorage_INTERFACE_DEFINED__
-
-/* interface IPersistSerializedPropStorage */
-/* [object][local][unique][uuid] */ 
-
-
-EXTERN_C const IID IID_IPersistSerializedPropStorage;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("e318ad57-0aa0-450f-aca5-6fab7103d917")
-    IPersistSerializedPropStorage : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
-            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetPropertyStorage( 
-            /* [in] */ 
-            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
-            /* [in] */ 
-            __in  DWORD cb) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorage( 
-            /* [out] */ 
-            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
-            /* [out] */ 
-            __out  DWORD *pcb) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPersistSerializedPropStorageVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPersistSerializedPropStorage * This,
-            /* [in] */ REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPersistSerializedPropStorage * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPersistSerializedPropStorage * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
-            IPersistSerializedPropStorage * This,
-            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
-            IPersistSerializedPropStorage * This,
-            /* [in] */ 
-            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
-            /* [in] */ 
-            __in  DWORD cb);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
-            IPersistSerializedPropStorage * This,
-            /* [out] */ 
-            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
-            /* [out] */ 
-            __out  DWORD *pcb);
-        
-        END_INTERFACE
-    } IPersistSerializedPropStorageVtbl;
-
-    interface IPersistSerializedPropStorage
-    {
-        CONST_VTBL struct IPersistSerializedPropStorageVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPersistSerializedPropStorage_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPersistSerializedPropStorage_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPersistSerializedPropStorage_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPersistSerializedPropStorage_SetFlags(This,flags)	\
-    ( (This)->lpVtbl -> SetFlags(This,flags) ) 
-
-#define IPersistSerializedPropStorage_SetPropertyStorage(This,psps,cb)	\
-    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 
-
-#define IPersistSerializedPropStorage_GetPropertyStorage(This,ppsps,pcb)	\
-    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPersistSerializedPropStorage_INTERFACE_DEFINED__ */
-
-
-#ifndef __IPropertySystemChangeNotify_INTERFACE_DEFINED__
-#define __IPropertySystemChangeNotify_INTERFACE_DEFINED__
-
-/* interface IPropertySystemChangeNotify */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IPropertySystemChangeNotify;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("fa955fd9-38be-4879-a6ce-824cf52d609f")
-    IPropertySystemChangeNotify : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE SchemaRefreshed( void) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IPropertySystemChangeNotifyVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IPropertySystemChangeNotify * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IPropertySystemChangeNotify * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IPropertySystemChangeNotify * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *SchemaRefreshed )( 
-            IPropertySystemChangeNotify * This);
-        
-        END_INTERFACE
-    } IPropertySystemChangeNotifyVtbl;
-
-    interface IPropertySystemChangeNotify
-    {
-        CONST_VTBL struct IPropertySystemChangeNotifyVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IPropertySystemChangeNotify_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IPropertySystemChangeNotify_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IPropertySystemChangeNotify_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IPropertySystemChangeNotify_SchemaRefreshed(This)	\
-    ( (This)->lpVtbl -> SchemaRefreshed(This) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IPropertySystemChangeNotify_INTERFACE_DEFINED__ */
-
-
-#ifndef __ICreateObject_INTERFACE_DEFINED__
-#define __ICreateObject_INTERFACE_DEFINED__
-
-/* interface ICreateObject */
-/* [object][unique][uuid] */ 
-
-
-EXTERN_C const IID IID_ICreateObject;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("75121952-e0d0-43e5-9380-1d80483acf72")
-    ICreateObject : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
-            /* [in] */ __RPC__in REFCLSID clsid,
-            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ICreateObjectVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ICreateObject * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ICreateObject * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ICreateObject * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
-            ICreateObject * This,
-            /* [in] */ __RPC__in REFCLSID clsid,
-            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
-        
-        END_INTERFACE
-    } ICreateObjectVtbl;
-
-    interface ICreateObject
-    {
-        CONST_VTBL struct ICreateObjectVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ICreateObject_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ICreateObject_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ICreateObject_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ICreateObject_CreateObject(This,clsid,pUnkOuter,riid,ppv)	\
-    ( (This)->lpVtbl -> CreateObject(This,clsid,pUnkOuter,riid,ppv) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ICreateObject_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_propsys_0000_0021 */
-/* [local] */ 
-
-// Format a property value for display purposes
-PSSTDAPI PSFormatForDisplay(
-    __in REFPROPERTYKEY propkey,
-    __in REFPROPVARIANT propvar,
-    __in PROPDESC_FORMAT_FLAGS pdfFlags,
-    __out_ecount(cchText) LPWSTR pwszText,
-    __in DWORD cchText);
-
-PSSTDAPI PSFormatForDisplayAlloc(
-    __in REFPROPERTYKEY key,
-    __in REFPROPVARIANT propvar,
-    __in PROPDESC_FORMAT_FLAGS pdff,
-    __deref_out PWSTR *ppszDisplay);
-
-PSSTDAPI PSFormatPropertyValue(
-    __in IPropertyStore *pps,
-    __in IPropertyDescription *ppd,
-    __in PROPDESC_FORMAT_FLAGS pdff,
-    __deref_out LPWSTR *ppszDisplay);
-
-
-#define PKEY_PIDSTR_MAX     10   // will take care of any long integer value
-#define GUIDSTRING_MAX      (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)  // "{12345678-1234-1234-1234-123456789012}"
-#define PKEYSTR_MAX         (GUIDSTRING_MAX + 1 + PKEY_PIDSTR_MAX)
-
-// Convert a PROPERTYKEY to and from a PWSTR
-PSSTDAPI PSStringFromPropertyKey(
-    __in REFPROPERTYKEY pkey,
-    __out_ecount(cch) LPWSTR psz,
-    __in UINT cch);
-
-PSSTDAPI PSPropertyKeyFromString(
-    __in LPCWSTR pszString,
-    __out PROPERTYKEY *pkey);
-
-
-// Creates an in-memory property store
-// Returns an IPropertyStore, IPersistSerializedPropStorage, and related interfaces interface
-PSSTDAPI PSCreateMemoryPropertyStore(
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Create a read-only, delay-bind multiplexing property store
-// Returns an IPropertyStore interface or related interfaces
-PSSTDAPI PSCreateDelayedMultiplexPropertyStore(
-    __in GETPROPERTYSTOREFLAGS flags,
-    __in IDelayedPropertyStoreFactory *pdpsf,
-    __in_ecount(cStores) const DWORD *rgStoreIds,
-    __in DWORD cStores,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Create a read-only property store from one or more sources (which each must support either IPropertyStore or IPropertySetStorage)
-// Returns an IPropertyStore interface or related interfaces
-PSSTDAPI PSCreateMultiplexPropertyStore(
-    __in_ecount(cStores) IUnknown **prgpunkStores,
-    __in DWORD cStores,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Create a container for IPropertyChanges
-// Returns an IPropertyChangeArray interface
-PSSTDAPI PSCreatePropertyChangeArray(
-    __in_ecount_opt(cChanges) const PROPERTYKEY *rgpropkey,
-    __in_ecount_opt(cChanges) const PKA_FLAGS *rgflags,
-    __in_ecount_opt(cChanges) const PROPVARIANT *rgpropvar,
-    __in UINT cChanges,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Create a simple property change
-// Returns an IPropertyChange interface
-PSSTDAPI PSCreateSimplePropertyChange(
-    __in PKA_FLAGS flags,
-    __in REFPROPERTYKEY key,
-    __in REFPROPVARIANT propvar,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Get a property description
-// Returns an IPropertyDescription interface
-PSSTDAPI PSGetPropertyDescription(
-    __in REFPROPERTYKEY propkey,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-PSSTDAPI PSGetPropertyDescriptionByName(
-    __in LPCWSTR pszCanonicalName,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Lookup a per-machine registered file property handler
-PSSTDAPI PSLookupPropertyHandlerCLSID(
-    __in PCWSTR pszFilePath,
-    __out CLSID *pclsid);
-// Get a property handler, on Vista or downlevel to XP
-// punkItem is a shell item created with an SHCreateItemXXX API
-// Returns an IPropertyStore
-PSSTDAPI PSGetItemPropertyHandler(
-    __in IUnknown *punkItem,
-    __in BOOL fReadWrite,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Get a property handler, on Vista or downlevel to XP
-// punkItem is a shell item created with an SHCreateItemXXX API
-// punkCreateObject supports ICreateObject
-// Returns an IPropertyStore
-PSSTDAPI PSGetItemPropertyHandlerWithCreateObject(
-    __in IUnknown *punkItem,
-    __in BOOL fReadWrite,
-    __in IUnknown *punkCreateObject,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Get or set a property value from a store
-PSSTDAPI PSGetPropertyValue(
-    __in IPropertyStore *pps,
-    __in IPropertyDescription *ppd,
-    __out PROPVARIANT *ppropvar);
-
-PSSTDAPI PSSetPropertyValue(
-    __in IPropertyStore *pps,
-    __in IPropertyDescription *ppd,
-    __in REFPROPVARIANT propvar);
-
-
-// Interact with the set of property descriptions
-PSSTDAPI PSRegisterPropertySchema(
-    __in PCWSTR pszPath);
-
-PSSTDAPI PSUnregisterPropertySchema(
-    __in PCWSTR pszPath);
-
-PSSTDAPI PSRefreshPropertySchema();
-
-// Returns either: IPropertyDescriptionList or IEnumUnknown interfaces
-PSSTDAPI PSEnumeratePropertyDescriptions(
-    __in PROPDESC_ENUMFILTER filterOn,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Convert between a PROPERTYKEY and its canonical name
-PSSTDAPI PSGetPropertyKeyFromName(
-    __in PCWSTR pszName,
-    __out PROPERTYKEY *ppropkey);
-
-PSSTDAPI PSGetNameFromPropertyKey(
-    __in REFPROPERTYKEY propkey,
-    __deref_out PWSTR *ppszCanonicalName);
-
-
-// Coerce and canonicalize a property value
-PSSTDAPI PSCoerceToCanonicalValue(
-    __in REFPROPERTYKEY key,
-    __inout PROPVARIANT *ppropvar);
-
-
-// Convert a 'prop:' string into a list of property descriptions
-// Returns an IPropertyDescriptionList interface
-PSSTDAPI PSGetPropertyDescriptionListFromString(
-    __in LPCWSTR pszPropList,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Wrap an IPropertySetStorage interface in an IPropertyStore interface
-// Returns an IPropertyStore or related interface
-PSSTDAPI PSCreatePropertyStoreFromPropertySetStorage(
-    __in IPropertySetStorage *ppss,
-    DWORD grfMode,
-    REFIID riid,
-    __deref_out void **ppv);
-
-
-// punkSource must support IPropertyStore or IPropertySetStorage
-// On success, the returned ppv is guaranteed to support IPropertyStore.
-// If punkSource already supports IPropertyStore, no wrapper is created.
-PSSTDAPI PSCreatePropertyStoreFromObject(
-    __in IUnknown *punk,
-    __in DWORD grfMode,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// punkSource must support IPropertyStore
-// riid may be IPropertyStore, IPropertySetStorage, IPropertyStoreCapabilities, or IObjectProvider
-PSSTDAPI PSCreateAdapterFromPropertyStore(
-    __in IPropertyStore *pps,
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Talk to the property system using an interface
-// Returns an IPropertySystem interface
-PSSTDAPI PSGetPropertySystem(
-    __in REFIID riid,
-    __deref_out void **ppv);
-
-
-// Obtain a value from serialized property storage
-PSSTDAPI PSGetPropertyFromPropertyStorage(
-    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
-    __in DWORD cb, 
-    __in REFPROPERTYKEY rpkey, 
-    __out PROPVARIANT *ppropvar);
-
-
-// Obtain a named value from serialized property storage
-PSSTDAPI PSGetNamedPropertyFromPropertyStorage(
-    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
-    __in DWORD cb, 
-    __in LPCWSTR pszName, 
-    __out PROPVARIANT *ppropvar);
-
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_s_ifspec;
-
-
-#ifndef __PropSysObjects_LIBRARY_DEFINED__
-#define __PropSysObjects_LIBRARY_DEFINED__
-
-/* library PropSysObjects */
-/* [version][lcid][uuid] */ 
-
-
-EXTERN_C const IID LIBID_PropSysObjects;
-
-EXTERN_C const CLSID CLSID_InMemoryPropertyStore;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("9a02e012-6303-4e1e-b9a1-630f802592c5")
-InMemoryPropertyStore;
-#endif
-
-EXTERN_C const CLSID CLSID_PropertySystem;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("b8967f85-58ae-4f46-9fb2-5d7904798f4b")
-PropertySystem;
-#endif
-#endif /* __PropSysObjects_LIBRARY_DEFINED__ */
-
-/* Additional Prototypes for ALL interfaces */
-
-unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
-void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
-
-unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 
-
-unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
-void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 
-
-unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 
-
-/* [local] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Proxy( 
-    IInitializeWithStream * This,
-    /* [in] */ IStream *pstream,
-    /* [in] */ DWORD grfMode);
-
-
-/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Stub( 
-    IInitializeWithStream * This,
-    /* [in] */ __RPC__in_opt IStream *pstream,
-    /* [in] */ DWORD grfMode);
-
-/* [local] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Proxy( 
-    IPropertyDescription * This,
-    /* [out][in] */ PROPVARIANT *ppropvar);
-
-
-/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Stub( 
-    IPropertyDescription * This,
-    /* [in] */ __RPC__in REFPROPVARIANT propvar,
-    /* [out] */ __RPC__out PROPVARIANT *ppropvar);
-
-
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for propsys.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __propsys_h__
+#define __propsys_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IInitializeWithFile_FWD_DEFINED__
+#define __IInitializeWithFile_FWD_DEFINED__
+typedef interface IInitializeWithFile IInitializeWithFile;
+#endif 	/* __IInitializeWithFile_FWD_DEFINED__ */
+
+
+#ifndef __IInitializeWithStream_FWD_DEFINED__
+#define __IInitializeWithStream_FWD_DEFINED__
+typedef interface IInitializeWithStream IInitializeWithStream;
+#endif 	/* __IInitializeWithStream_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyStore_FWD_DEFINED__
+#define __IPropertyStore_FWD_DEFINED__
+typedef interface IPropertyStore IPropertyStore;
+#endif 	/* __IPropertyStore_FWD_DEFINED__ */
+
+
+#ifndef __INamedPropertyStore_FWD_DEFINED__
+#define __INamedPropertyStore_FWD_DEFINED__
+typedef interface INamedPropertyStore INamedPropertyStore;
+#endif 	/* __INamedPropertyStore_FWD_DEFINED__ */
+
+
+#ifndef __IObjectWithPropertyKey_FWD_DEFINED__
+#define __IObjectWithPropertyKey_FWD_DEFINED__
+typedef interface IObjectWithPropertyKey IObjectWithPropertyKey;
+#endif 	/* __IObjectWithPropertyKey_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyChange_FWD_DEFINED__
+#define __IPropertyChange_FWD_DEFINED__
+typedef interface IPropertyChange IPropertyChange;
+#endif 	/* __IPropertyChange_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyChangeArray_FWD_DEFINED__
+#define __IPropertyChangeArray_FWD_DEFINED__
+typedef interface IPropertyChangeArray IPropertyChangeArray;
+#endif 	/* __IPropertyChangeArray_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyStoreCapabilities_FWD_DEFINED__
+#define __IPropertyStoreCapabilities_FWD_DEFINED__
+typedef interface IPropertyStoreCapabilities IPropertyStoreCapabilities;
+#endif 	/* __IPropertyStoreCapabilities_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyStoreCache_FWD_DEFINED__
+#define __IPropertyStoreCache_FWD_DEFINED__
+typedef interface IPropertyStoreCache IPropertyStoreCache;
+#endif 	/* __IPropertyStoreCache_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyEnumType_FWD_DEFINED__
+#define __IPropertyEnumType_FWD_DEFINED__
+typedef interface IPropertyEnumType IPropertyEnumType;
+#endif 	/* __IPropertyEnumType_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyEnumTypeList_FWD_DEFINED__
+#define __IPropertyEnumTypeList_FWD_DEFINED__
+typedef interface IPropertyEnumTypeList IPropertyEnumTypeList;
+#endif 	/* __IPropertyEnumTypeList_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyDescription_FWD_DEFINED__
+#define __IPropertyDescription_FWD_DEFINED__
+typedef interface IPropertyDescription IPropertyDescription;
+#endif 	/* __IPropertyDescription_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionAliasInfo_FWD_DEFINED__
+#define __IPropertyDescriptionAliasInfo_FWD_DEFINED__
+typedef interface IPropertyDescriptionAliasInfo IPropertyDescriptionAliasInfo;
+#endif 	/* __IPropertyDescriptionAliasInfo_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionSearchInfo_FWD_DEFINED__
+#define __IPropertyDescriptionSearchInfo_FWD_DEFINED__
+typedef interface IPropertyDescriptionSearchInfo IPropertyDescriptionSearchInfo;
+#endif 	/* __IPropertyDescriptionSearchInfo_FWD_DEFINED__ */
+
+
+#ifndef __IPropertySystem_FWD_DEFINED__
+#define __IPropertySystem_FWD_DEFINED__
+typedef interface IPropertySystem IPropertySystem;
+#endif 	/* __IPropertySystem_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionList_FWD_DEFINED__
+#define __IPropertyDescriptionList_FWD_DEFINED__
+typedef interface IPropertyDescriptionList IPropertyDescriptionList;
+#endif 	/* __IPropertyDescriptionList_FWD_DEFINED__ */
+
+
+#ifndef __IPropertyStoreFactory_FWD_DEFINED__
+#define __IPropertyStoreFactory_FWD_DEFINED__
+typedef interface IPropertyStoreFactory IPropertyStoreFactory;
+#endif 	/* __IPropertyStoreFactory_FWD_DEFINED__ */
+
+
+#ifndef __IDelayedPropertyStoreFactory_FWD_DEFINED__
+#define __IDelayedPropertyStoreFactory_FWD_DEFINED__
+typedef interface IDelayedPropertyStoreFactory IDelayedPropertyStoreFactory;
+#endif 	/* __IDelayedPropertyStoreFactory_FWD_DEFINED__ */
+
+
+#ifndef __IPersistSerializedPropStorage_FWD_DEFINED__
+#define __IPersistSerializedPropStorage_FWD_DEFINED__
+typedef interface IPersistSerializedPropStorage IPersistSerializedPropStorage;
+#endif 	/* __IPersistSerializedPropStorage_FWD_DEFINED__ */
+
+
+#ifndef __IPropertySystemChangeNotify_FWD_DEFINED__
+#define __IPropertySystemChangeNotify_FWD_DEFINED__
+typedef interface IPropertySystemChangeNotify IPropertySystemChangeNotify;
+#endif 	/* __IPropertySystemChangeNotify_FWD_DEFINED__ */
+
+
+#ifndef __ICreateObject_FWD_DEFINED__
+#define __ICreateObject_FWD_DEFINED__
+typedef interface ICreateObject ICreateObject;
+#endif 	/* __ICreateObject_FWD_DEFINED__ */
+
+
+#ifndef __InMemoryPropertyStore_FWD_DEFINED__
+#define __InMemoryPropertyStore_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class InMemoryPropertyStore InMemoryPropertyStore;
+#else
+typedef struct InMemoryPropertyStore InMemoryPropertyStore;
+#endif /* __cplusplus */
+
+#endif 	/* __InMemoryPropertyStore_FWD_DEFINED__ */
+
+
+#ifndef __PropertySystem_FWD_DEFINED__
+#define __PropertySystem_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class PropertySystem PropertySystem;
+#else
+typedef struct PropertySystem PropertySystem;
+#endif /* __cplusplus */
+
+#endif 	/* __PropertySystem_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "objidl.h"
+#include "oleidl.h"
+#include "ocidl.h"
+#include "shtypes.h"
+#include "structuredquery.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_propsys_0000_0000 */
+/* [local] */ 
+
+#ifndef PSSTDAPI
+#if defined(_PROPSYS_)
+#define PSSTDAPI          STDAPI
+#define PSSTDAPI_(type)   STDAPI_(type)
+#else
+#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
+#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
+#endif
+#endif // PSSTDAPI
+#if 0
+typedef PROPERTYKEY *REFPROPERTYKEY;
+
+#endif // 0
+#include <propkeydef.h>
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IInitializeWithFile_INTERFACE_DEFINED__
+#define __IInitializeWithFile_INTERFACE_DEFINED__
+
+/* interface IInitializeWithFile */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IInitializeWithFile;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("b7d14566-0509-4cce-a71f-0a554233bd9b")
+    IInitializeWithFile : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Initialize( 
+            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
+            /* [in] */ DWORD grfMode) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IInitializeWithFileVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IInitializeWithFile * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IInitializeWithFile * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IInitializeWithFile * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
+            IInitializeWithFile * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
+            /* [in] */ DWORD grfMode);
+        
+        END_INTERFACE
+    } IInitializeWithFileVtbl;
+
+    interface IInitializeWithFile
+    {
+        CONST_VTBL struct IInitializeWithFileVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IInitializeWithFile_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IInitializeWithFile_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IInitializeWithFile_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IInitializeWithFile_Initialize(This,pszFilePath,grfMode)	\
+    ( (This)->lpVtbl -> Initialize(This,pszFilePath,grfMode) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IInitializeWithFile_INTERFACE_DEFINED__ */
+
+
+#ifndef __IInitializeWithStream_INTERFACE_DEFINED__
+#define __IInitializeWithStream_INTERFACE_DEFINED__
+
+/* interface IInitializeWithStream */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IInitializeWithStream;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("b824b49d-22ac-4161-ac8a-9916e8fa3f7f")
+    IInitializeWithStream : public IUnknown
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
+            /* [in] */ IStream *pstream,
+            /* [in] */ DWORD grfMode) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IInitializeWithStreamVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IInitializeWithStream * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IInitializeWithStream * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IInitializeWithStream * This);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
+            IInitializeWithStream * This,
+            /* [in] */ IStream *pstream,
+            /* [in] */ DWORD grfMode);
+        
+        END_INTERFACE
+    } IInitializeWithStreamVtbl;
+
+    interface IInitializeWithStream
+    {
+        CONST_VTBL struct IInitializeWithStreamVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IInitializeWithStream_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IInitializeWithStream_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IInitializeWithStream_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IInitializeWithStream_Initialize(This,pstream,grfMode)	\
+    ( (This)->lpVtbl -> Initialize(This,pstream,grfMode) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_RemoteInitialize_Proxy( 
+    IInitializeWithStream * This,
+    /* [in] */ __RPC__in_opt IStream *pstream,
+    /* [in] */ DWORD grfMode);
+
+
+void __RPC_STUB IInitializeWithStream_RemoteInitialize_Stub(
+    IRpcStubBuffer *This,
+    IRpcChannelBuffer *_pRpcChannelBuffer,
+    PRPC_MESSAGE _pRpcMessage,
+    DWORD *_pdwStubPhase);
+
+
+
+#endif 	/* __IInitializeWithStream_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyStore_INTERFACE_DEFINED__
+#define __IPropertyStore_INTERFACE_DEFINED__
+
+/* interface IPropertyStore */
+/* [unique][object][helpstring][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyStore;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")
+    IPropertyStore : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ __RPC__out DWORD *cProps) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAt( 
+            /* [in] */ DWORD iProp,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetValue( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetValue( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyStoreVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyStore * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyStore * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyStore * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPropertyStore * This,
+            /* [out] */ __RPC__out DWORD *cProps);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
+            IPropertyStore * This,
+            /* [in] */ DWORD iProp,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
+            IPropertyStore * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PROPVARIANT *pv);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
+            IPropertyStore * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *Commit )( 
+            IPropertyStore * This);
+        
+        END_INTERFACE
+    } IPropertyStoreVtbl;
+
+    interface IPropertyStore
+    {
+        CONST_VTBL struct IPropertyStoreVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyStore_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyStore_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyStore_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyStore_GetCount(This,cProps)	\
+    ( (This)->lpVtbl -> GetCount(This,cProps) ) 
+
+#define IPropertyStore_GetAt(This,iProp,pkey)	\
+    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 
+
+#define IPropertyStore_GetValue(This,key,pv)	\
+    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 
+
+#define IPropertyStore_SetValue(This,key,propvar)	\
+    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 
+
+#define IPropertyStore_Commit(This)	\
+    ( (This)->lpVtbl -> Commit(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyStore_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0003 */
+/* [local] */ 
+
+typedef /* [unique] */  __RPC_unique_pointer IPropertyStore *LPPROPERTYSTORE;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_s_ifspec;
+
+#ifndef __INamedPropertyStore_INTERFACE_DEFINED__
+#define __INamedPropertyStore_INTERFACE_DEFINED__
+
+/* interface INamedPropertyStore */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_INamedPropertyStore;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("71604b0f-97b0-4764-8577-2f13e98a1422")
+    INamedPropertyStore : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetNamedValue( 
+            /* [string][in] */ __RPC__in LPCWSTR pszName,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetNamedValue( 
+            /* [string][in] */ __RPC__in LPCWSTR pszName,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
+            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetNameAt( 
+            /* [in] */ DWORD iProp,
+            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct INamedPropertyStoreVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            INamedPropertyStore * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            INamedPropertyStore * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            INamedPropertyStore * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetNamedValue )( 
+            INamedPropertyStore * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszName,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetNamedValue )( 
+            INamedPropertyStore * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszName,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
+            INamedPropertyStore * This,
+            /* [out] */ __RPC__out DWORD *pdwCount);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetNameAt )( 
+            INamedPropertyStore * This,
+            /* [in] */ DWORD iProp,
+            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
+        
+        END_INTERFACE
+    } INamedPropertyStoreVtbl;
+
+    interface INamedPropertyStore
+    {
+        CONST_VTBL struct INamedPropertyStoreVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define INamedPropertyStore_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define INamedPropertyStore_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define INamedPropertyStore_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define INamedPropertyStore_GetNamedValue(This,pszName,ppropvar)	\
+    ( (This)->lpVtbl -> GetNamedValue(This,pszName,ppropvar) ) 
+
+#define INamedPropertyStore_SetNamedValue(This,pszName,propvar)	\
+    ( (This)->lpVtbl -> SetNamedValue(This,pszName,propvar) ) 
+
+#define INamedPropertyStore_GetNameCount(This,pdwCount)	\
+    ( (This)->lpVtbl -> GetNameCount(This,pdwCount) ) 
+
+#define INamedPropertyStore_GetNameAt(This,iProp,pbstrName)	\
+    ( (This)->lpVtbl -> GetNameAt(This,iProp,pbstrName) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __INamedPropertyStore_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0004 */
+/* [local] */ 
+
+/* [v1_enum] */ 
+enum tagGETPROPERTYSTOREFLAGS
+    {	GPS_DEFAULT	= 0,
+	GPS_HANDLERPROPERTIESONLY	= 0x1,
+	GPS_READWRITE	= 0x2,
+	GPS_TEMPORARY	= 0x4,
+	GPS_FASTPROPERTIESONLY	= 0x8,
+	GPS_OPENSLOWITEM	= 0x10,
+	GPS_DELAYCREATION	= 0x20,
+	GPS_BESTEFFORT	= 0x40,
+	GPS_MASK_VALID	= 0x7f
+    } ;
+typedef int GETPROPERTYSTOREFLAGS;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_s_ifspec;
+
+#ifndef __IObjectWithPropertyKey_INTERFACE_DEFINED__
+#define __IObjectWithPropertyKey_INTERFACE_DEFINED__
+
+/* interface IObjectWithPropertyKey */
+/* [uuid][object] */ 
+
+
+EXTERN_C const IID IID_IObjectWithPropertyKey;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("fc0ca0a7-c316-4fd2-9031-3e628e6d4f23")
+    IObjectWithPropertyKey : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetPropertyKey( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
+            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IObjectWithPropertyKeyVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IObjectWithPropertyKey * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IObjectWithPropertyKey * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IObjectWithPropertyKey * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
+            IObjectWithPropertyKey * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
+            IObjectWithPropertyKey * This,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        END_INTERFACE
+    } IObjectWithPropertyKeyVtbl;
+
+    interface IObjectWithPropertyKey
+    {
+        CONST_VTBL struct IObjectWithPropertyKeyVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IObjectWithPropertyKey_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IObjectWithPropertyKey_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IObjectWithPropertyKey_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IObjectWithPropertyKey_SetPropertyKey(This,key)	\
+    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 
+
+#define IObjectWithPropertyKey_GetPropertyKey(This,pkey)	\
+    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IObjectWithPropertyKey_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0005 */
+/* [local] */ 
+
+typedef /* [v1_enum] */ 
+enum tagPKA_FLAGS
+    {	PKA_SET	= 0,
+	PKA_APPEND	= ( PKA_SET + 1 ) ,
+	PKA_DELETE	= ( PKA_APPEND + 1 ) 
+    } 	PKA_FLAGS;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_s_ifspec;
+
+#ifndef __IPropertyChange_INTERFACE_DEFINED__
+#define __IPropertyChange_INTERFACE_DEFINED__
+
+/* interface IPropertyChange */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyChange;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("f917bc8a-1bba-4478-a245-1bde03eb9431")
+    IPropertyChange : public IObjectWithPropertyKey
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE ApplyToPropVariant( 
+            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyChangeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyChange * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyChange * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyChange * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
+            IPropertyChange * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
+            IPropertyChange * This,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *ApplyToPropVariant )( 
+            IPropertyChange * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut);
+        
+        END_INTERFACE
+    } IPropertyChangeVtbl;
+
+    interface IPropertyChange
+    {
+        CONST_VTBL struct IPropertyChangeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyChange_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyChange_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyChange_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyChange_SetPropertyKey(This,key)	\
+    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 
+
+#define IPropertyChange_GetPropertyKey(This,pkey)	\
+    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
+
+
+#define IPropertyChange_ApplyToPropVariant(This,propvarIn,ppropvarOut)	\
+    ( (This)->lpVtbl -> ApplyToPropVariant(This,propvarIn,ppropvarOut) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyChange_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyChangeArray_INTERFACE_DEFINED__
+#define __IPropertyChangeArray_INTERFACE_DEFINED__
+
+/* interface IPropertyChangeArray */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyChangeArray;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("380f5cad-1b5e-42f2-805d-637fd392d31e")
+    IPropertyChangeArray : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ __RPC__out UINT *pcOperations) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAt( 
+            /* [in] */ UINT iIndex,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
+            /* [in] */ UINT iIndex,
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Append( 
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE AppendOrReplace( 
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
+            /* [in] */ UINT iIndex) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE IsKeyInArray( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyChangeArrayVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyChangeArray * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyChangeArray * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyChangeArray * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPropertyChangeArray * This,
+            /* [out] */ __RPC__out UINT *pcOperations);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
+            IPropertyChangeArray * This,
+            /* [in] */ UINT iIndex,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
+            IPropertyChangeArray * This,
+            /* [in] */ UINT iIndex,
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
+        
+        HRESULT ( STDMETHODCALLTYPE *Append )( 
+            IPropertyChangeArray * This,
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
+        
+        HRESULT ( STDMETHODCALLTYPE *AppendOrReplace )( 
+            IPropertyChangeArray * This,
+            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
+        
+        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
+            IPropertyChangeArray * This,
+            /* [in] */ UINT iIndex);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsKeyInArray )( 
+            IPropertyChangeArray * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key);
+        
+        END_INTERFACE
+    } IPropertyChangeArrayVtbl;
+
+    interface IPropertyChangeArray
+    {
+        CONST_VTBL struct IPropertyChangeArrayVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyChangeArray_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyChangeArray_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyChangeArray_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyChangeArray_GetCount(This,pcOperations)	\
+    ( (This)->lpVtbl -> GetCount(This,pcOperations) ) 
+
+#define IPropertyChangeArray_GetAt(This,iIndex,riid,ppv)	\
+    ( (This)->lpVtbl -> GetAt(This,iIndex,riid,ppv) ) 
+
+#define IPropertyChangeArray_InsertAt(This,iIndex,ppropChange)	\
+    ( (This)->lpVtbl -> InsertAt(This,iIndex,ppropChange) ) 
+
+#define IPropertyChangeArray_Append(This,ppropChange)	\
+    ( (This)->lpVtbl -> Append(This,ppropChange) ) 
+
+#define IPropertyChangeArray_AppendOrReplace(This,ppropChange)	\
+    ( (This)->lpVtbl -> AppendOrReplace(This,ppropChange) ) 
+
+#define IPropertyChangeArray_RemoveAt(This,iIndex)	\
+    ( (This)->lpVtbl -> RemoveAt(This,iIndex) ) 
+
+#define IPropertyChangeArray_IsKeyInArray(This,key)	\
+    ( (This)->lpVtbl -> IsKeyInArray(This,key) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyChangeArray_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyStoreCapabilities_INTERFACE_DEFINED__
+#define __IPropertyStoreCapabilities_INTERFACE_DEFINED__
+
+/* interface IPropertyStoreCapabilities */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyStoreCapabilities;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("c8e2d566-186e-4d49-bf41-6909ead56acc")
+    IPropertyStoreCapabilities : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE IsPropertyWritable( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyStoreCapabilitiesVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyStoreCapabilities * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyStoreCapabilities * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyStoreCapabilities * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsPropertyWritable )( 
+            IPropertyStoreCapabilities * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key);
+        
+        END_INTERFACE
+    } IPropertyStoreCapabilitiesVtbl;
+
+    interface IPropertyStoreCapabilities
+    {
+        CONST_VTBL struct IPropertyStoreCapabilitiesVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyStoreCapabilities_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyStoreCapabilities_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyStoreCapabilities_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyStoreCapabilities_IsPropertyWritable(This,key)	\
+    ( (This)->lpVtbl -> IsPropertyWritable(This,key) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyStoreCapabilities_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyStoreCache_INTERFACE_DEFINED__
+#define __IPropertyStoreCache_INTERFACE_DEFINED__
+
+/* interface IPropertyStoreCache */
+/* [unique][object][uuid] */ 
+
+typedef /* [v1_enum] */ 
+enum _PSC_STATE
+    {	PSC_NORMAL	= 0,
+	PSC_NOTINSOURCE	= 1,
+	PSC_DIRTY	= 2,
+	PSC_READONLY	= 3
+    } 	PSC_STATE;
+
+
+EXTERN_C const IID IID_IPropertyStoreCache;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("3017056d-9a91-4e90-937d-746c72abbf4f")
+    IPropertyStoreCache : public IPropertyStore
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetState( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetValueAndState( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
+            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetState( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ PSC_STATE state) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetValueAndState( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
+            /* [in] */ PSC_STATE state) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyStoreCacheVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyStoreCache * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyStoreCache * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPropertyStoreCache * This,
+            /* [out] */ __RPC__out DWORD *cProps);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
+            IPropertyStoreCache * This,
+            /* [in] */ DWORD iProp,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PROPVARIANT *pv);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *Commit )( 
+            IPropertyStoreCache * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetState )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PSC_STATE *pstate);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValueAndState )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
+            /* [out] */ __RPC__out PSC_STATE *pstate);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetState )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ PSC_STATE state);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetValueAndState )( 
+            IPropertyStoreCache * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
+            /* [in] */ PSC_STATE state);
+        
+        END_INTERFACE
+    } IPropertyStoreCacheVtbl;
+
+    interface IPropertyStoreCache
+    {
+        CONST_VTBL struct IPropertyStoreCacheVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyStoreCache_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyStoreCache_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyStoreCache_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyStoreCache_GetCount(This,cProps)	\
+    ( (This)->lpVtbl -> GetCount(This,cProps) ) 
+
+#define IPropertyStoreCache_GetAt(This,iProp,pkey)	\
+    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 
+
+#define IPropertyStoreCache_GetValue(This,key,pv)	\
+    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 
+
+#define IPropertyStoreCache_SetValue(This,key,propvar)	\
+    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 
+
+#define IPropertyStoreCache_Commit(This)	\
+    ( (This)->lpVtbl -> Commit(This) ) 
+
+
+#define IPropertyStoreCache_GetState(This,key,pstate)	\
+    ( (This)->lpVtbl -> GetState(This,key,pstate) ) 
+
+#define IPropertyStoreCache_GetValueAndState(This,key,ppropvar,pstate)	\
+    ( (This)->lpVtbl -> GetValueAndState(This,key,ppropvar,pstate) ) 
+
+#define IPropertyStoreCache_SetState(This,key,state)	\
+    ( (This)->lpVtbl -> SetState(This,key,state) ) 
+
+#define IPropertyStoreCache_SetValueAndState(This,key,ppropvar,state)	\
+    ( (This)->lpVtbl -> SetValueAndState(This,key,ppropvar,state) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyStoreCache_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyEnumType_INTERFACE_DEFINED__
+#define __IPropertyEnumType_INTERFACE_DEFINED__
+
+/* interface IPropertyEnumType */
+/* [unique][object][uuid] */ 
+
+/* [v1_enum] */ 
+enum tagPROPENUMTYPE
+    {	PET_DISCRETEVALUE	= 0,
+	PET_RANGEDVALUE	= 1,
+	PET_DEFAULTVALUE	= 2,
+	PET_ENDRANGE	= 3
+    } ;
+typedef enum tagPROPENUMTYPE PROPENUMTYPE;
+
+
+EXTERN_C const IID IID_IPropertyEnumType;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("11e1fbf9-2d56-4a6b-8db3-7cd193a471f2")
+    IPropertyEnumType : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetEnumType( 
+            /* [out] */ __RPC__out PROPENUMTYPE *penumtype) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetValue( 
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRangeMinValue( 
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRangeSetValue( 
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDisplayText( 
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyEnumTypeVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyEnumType * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyEnumType * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyEnumType * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
+            IPropertyEnumType * This,
+            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
+            IPropertyEnumType * This,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
+            IPropertyEnumType * This,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
+            IPropertyEnumType * This,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
+            IPropertyEnumType * This,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
+        
+        END_INTERFACE
+    } IPropertyEnumTypeVtbl;
+
+    interface IPropertyEnumType
+    {
+        CONST_VTBL struct IPropertyEnumTypeVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyEnumType_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyEnumType_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyEnumType_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyEnumType_GetEnumType(This,penumtype)	\
+    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 
+
+#define IPropertyEnumType_GetValue(This,ppropvar)	\
+    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 
+
+#define IPropertyEnumType_GetRangeMinValue(This,ppropvarMin)	\
+    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 
+
+#define IPropertyEnumType_GetRangeSetValue(This,ppropvarSet)	\
+    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 
+
+#define IPropertyEnumType_GetDisplayText(This,ppszDisplay)	\
+    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyEnumType_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyEnumTypeList_INTERFACE_DEFINED__
+#define __IPropertyEnumTypeList_INTERFACE_DEFINED__
+
+/* interface IPropertyEnumTypeList */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyEnumTypeList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("a99400f4-3d84-4557-94ba-1242fb2cc9a6")
+    IPropertyEnumTypeList : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ __RPC__out UINT *pctypes) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAt( 
+            /* [in] */ UINT itype,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetConditionAt( 
+            /* [in] */ UINT nIndex,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE FindMatchingIndex( 
+            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
+            /* [out] */ __RPC__out UINT *pnIndex) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyEnumTypeListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyEnumTypeList * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyEnumTypeList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyEnumTypeList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPropertyEnumTypeList * This,
+            /* [out] */ __RPC__out UINT *pctypes);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
+            IPropertyEnumTypeList * This,
+            /* [in] */ UINT itype,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetConditionAt )( 
+            IPropertyEnumTypeList * This,
+            /* [in] */ UINT nIndex,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *FindMatchingIndex )( 
+            IPropertyEnumTypeList * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
+            /* [out] */ __RPC__out UINT *pnIndex);
+        
+        END_INTERFACE
+    } IPropertyEnumTypeListVtbl;
+
+    interface IPropertyEnumTypeList
+    {
+        CONST_VTBL struct IPropertyEnumTypeListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyEnumTypeList_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyEnumTypeList_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyEnumTypeList_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyEnumTypeList_GetCount(This,pctypes)	\
+    ( (This)->lpVtbl -> GetCount(This,pctypes) ) 
+
+#define IPropertyEnumTypeList_GetAt(This,itype,riid,ppv)	\
+    ( (This)->lpVtbl -> GetAt(This,itype,riid,ppv) ) 
+
+#define IPropertyEnumTypeList_GetConditionAt(This,nIndex,riid,ppv)	\
+    ( (This)->lpVtbl -> GetConditionAt(This,nIndex,riid,ppv) ) 
+
+#define IPropertyEnumTypeList_FindMatchingIndex(This,propvarCmp,pnIndex)	\
+    ( (This)->lpVtbl -> FindMatchingIndex(This,propvarCmp,pnIndex) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyEnumTypeList_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyDescription_INTERFACE_DEFINED__
+#define __IPropertyDescription_INTERFACE_DEFINED__
+
+/* interface IPropertyDescription */
+/* [unique][object][uuid] */ 
+
+/* [v1_enum] */ 
+enum tagPROPDESC_TYPE_FLAGS
+    {	PDTF_DEFAULT	= 0,
+	PDTF_MULTIPLEVALUES	= 0x1,
+	PDTF_ISINNATE	= 0x2,
+	PDTF_ISGROUP	= 0x4,
+	PDTF_CANGROUPBY	= 0x8,
+	PDTF_CANSTACKBY	= 0x10,
+	PDTF_ISTREEPROPERTY	= 0x20,
+	PDTF_INCLUDEINFULLTEXTQUERY	= 0x40,
+	PDTF_ISVIEWABLE	= 0x80,
+	PDTF_ISQUERYABLE	= 0x100,
+	PDTF_ISSYSTEMPROPERTY	= 0x80000000,
+	PDTF_MASK_ALL	= 0x800001ff
+    } ;
+typedef int PROPDESC_TYPE_FLAGS;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_VIEW_FLAGS
+    {	PDVF_DEFAULT	= 0,
+	PDVF_CENTERALIGN	= 0x1,
+	PDVF_RIGHTALIGN	= 0x2,
+	PDVF_BEGINNEWGROUP	= 0x4,
+	PDVF_FILLAREA	= 0x8,
+	PDVF_SORTDESCENDING	= 0x10,
+	PDVF_SHOWONLYIFPRESENT	= 0x20,
+	PDVF_SHOWBYDEFAULT	= 0x40,
+	PDVF_SHOWINPRIMARYLIST	= 0x80,
+	PDVF_SHOWINSECONDARYLIST	= 0x100,
+	PDVF_HIDELABEL	= 0x200,
+	PDVF_HIDDEN	= 0x800,
+	PDVF_CANWRAP	= 0x1000,
+	PDVF_MASK_ALL	= 0x1bff
+    } ;
+typedef int PROPDESC_VIEW_FLAGS;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_DISPLAYTYPE
+    {	PDDT_STRING	= 0,
+	PDDT_NUMBER	= 1,
+	PDDT_BOOLEAN	= 2,
+	PDDT_DATETIME	= 3,
+	PDDT_ENUMERATED	= 4
+    } ;
+typedef enum tagPROPDESC_DISPLAYTYPE PROPDESC_DISPLAYTYPE;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_GROUPING_RANGE
+    {	PDGR_DISCRETE	= 0,
+	PDGR_ALPHANUMERIC	= 1,
+	PDGR_SIZE	= 2,
+	PDGR_DYNAMIC	= 3,
+	PDGR_DATE	= 4,
+	PDGR_PERCENT	= 5,
+	PDGR_ENUMERATED	= 6
+    } ;
+typedef enum tagPROPDESC_GROUPING_RANGE PROPDESC_GROUPING_RANGE;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_FORMAT_FLAGS
+    {	PDFF_DEFAULT	= 0,
+	PDFF_PREFIXNAME	= 0x1,
+	PDFF_FILENAME	= 0x2,
+	PDFF_ALWAYSKB	= 0x4,
+	PDFF_RESERVED_RIGHTTOLEFT	= 0x8,
+	PDFF_SHORTTIME	= 0x10,
+	PDFF_LONGTIME	= 0x20,
+	PDFF_HIDETIME	= 0x40,
+	PDFF_SHORTDATE	= 0x80,
+	PDFF_LONGDATE	= 0x100,
+	PDFF_HIDEDATE	= 0x200,
+	PDFF_RELATIVEDATE	= 0x400,
+	PDFF_USEEDITINVITATION	= 0x800,
+	PDFF_READONLY	= 0x1000,
+	PDFF_NOAUTOREADINGORDER	= 0x2000
+    } ;
+typedef int PROPDESC_FORMAT_FLAGS;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_SORTDESCRIPTION
+    {	PDSD_GENERAL	= 0,
+	PDSD_A_Z	= 1,
+	PDSD_LOWEST_HIGHEST	= 2,
+	PDSD_SMALLEST_BIGGEST	= 3,
+	PDSD_OLDEST_NEWEST	= 4
+    } ;
+typedef enum tagPROPDESC_SORTDESCRIPTION PROPDESC_SORTDESCRIPTION;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE
+    {	PDRDT_GENERAL	= 0,
+	PDRDT_DATE	= 1,
+	PDRDT_SIZE	= 2,
+	PDRDT_COUNT	= 3,
+	PDRDT_REVISION	= 4,
+	PDRDT_LENGTH	= 5,
+	PDRDT_DURATION	= 6,
+	PDRDT_SPEED	= 7,
+	PDRDT_RATE	= 8,
+	PDRDT_RATING	= 9,
+	PDRDT_PRIORITY	= 10
+    } ;
+typedef enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE PROPDESC_RELATIVEDESCRIPTION_TYPE;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_AGGREGATION_TYPE
+    {	PDAT_DEFAULT	= 0,
+	PDAT_FIRST	= 1,
+	PDAT_SUM	= 2,
+	PDAT_AVERAGE	= 3,
+	PDAT_DATERANGE	= 4,
+	PDAT_UNION	= 5,
+	PDAT_MAX	= 6,
+	PDAT_MIN	= 7
+    } ;
+typedef enum tagPROPDESC_AGGREGATION_TYPE PROPDESC_AGGREGATION_TYPE;
+
+/* [v1_enum] */ 
+enum tagPROPDESC_CONDITION_TYPE
+    {	PDCOT_NONE	= 0,
+	PDCOT_STRING	= 1,
+	PDCOT_SIZE	= 2,
+	PDCOT_DATETIME	= 3,
+	PDCOT_BOOLEAN	= 4,
+	PDCOT_NUMBER	= 5
+    } ;
+typedef enum tagPROPDESC_CONDITION_TYPE PROPDESC_CONDITION_TYPE;
+
+
+EXTERN_C const IID IID_IPropertyDescription;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6f79d558-3e96-4549-a1d1-7d75d2288814")
+    IPropertyDescription : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
+            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
+            /* [out] */ __RPC__out VARTYPE *pvartype) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetEditInvitation( 
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
+            /* [in] */ PROPDESC_TYPE_FLAGS mask,
+            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
+            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnWidth( 
+            /* [out] */ __RPC__out UINT *pcxChars) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetDisplayType( 
+            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetColumnState( 
+            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetGroupingRange( 
+            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescriptionType( 
+            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescription( 
+            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetSortDescription( 
+            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetSortDescriptionLabel( 
+            /* [in] */ BOOL fDescending,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAggregationType( 
+            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
+            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
+            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetEnumTypeList( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CoerceToCanonicalValue( 
+            /* [out][in] */ PROPVARIANT *ppropvar) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE IsValueCanonical( 
+            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyDescriptionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyDescription * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyDescription * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyDescription * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
+            IPropertyDescription * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out VARTYPE *pvartype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
+            IPropertyDescription * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
+            IPropertyDescription * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
+            IPropertyDescription * This,
+            /* [in] */ PROPDESC_TYPE_FLAGS mask,
+            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out UINT *pcxChars);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
+            IPropertyDescription * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
+            IPropertyDescription * This,
+            /* [in] */ BOOL fDescending,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
+            IPropertyDescription * This,
+            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
+            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
+            IPropertyDescription * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
+            IPropertyDescription * This,
+            /* [out][in] */ PROPVARIANT *ppropvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
+            IPropertyDescription * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
+            IPropertyDescription * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        END_INTERFACE
+    } IPropertyDescriptionVtbl;
+
+    interface IPropertyDescription
+    {
+        CONST_VTBL struct IPropertyDescriptionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyDescription_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyDescription_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyDescription_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyDescription_GetPropertyKey(This,pkey)	\
+    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
+
+#define IPropertyDescription_GetCanonicalName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
+
+#define IPropertyDescription_GetPropertyType(This,pvartype)	\
+    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
+
+#define IPropertyDescription_GetDisplayName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
+
+#define IPropertyDescription_GetEditInvitation(This,ppszInvite)	\
+    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
+
+#define IPropertyDescription_GetTypeFlags(This,mask,ppdtFlags)	\
+    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
+
+#define IPropertyDescription_GetViewFlags(This,ppdvFlags)	\
+    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
+
+#define IPropertyDescription_GetDefaultColumnWidth(This,pcxChars)	\
+    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
+
+#define IPropertyDescription_GetDisplayType(This,pdisplaytype)	\
+    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
+
+#define IPropertyDescription_GetColumnState(This,pcsFlags)	\
+    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
+
+#define IPropertyDescription_GetGroupingRange(This,pgr)	\
+    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
+
+#define IPropertyDescription_GetRelativeDescriptionType(This,prdt)	\
+    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
+
+#define IPropertyDescription_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
+    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
+
+#define IPropertyDescription_GetSortDescription(This,psd)	\
+    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
+
+#define IPropertyDescription_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
+    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
+
+#define IPropertyDescription_GetAggregationType(This,paggtype)	\
+    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
+
+#define IPropertyDescription_GetConditionType(This,pcontype,popDefault)	\
+    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
+
+#define IPropertyDescription_GetEnumTypeList(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
+
+#define IPropertyDescription_CoerceToCanonicalValue(This,ppropvar)	\
+    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
+
+#define IPropertyDescription_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
+    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
+
+#define IPropertyDescription_IsValueCanonical(This,propvar)	\
+    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_RemoteCoerceToCanonicalValue_Proxy( 
+    IPropertyDescription * This,
+    /* [in] */ __RPC__in REFPROPVARIANT propvar,
+    /* [out] */ __RPC__out PROPVARIANT *ppropvar);
+
+
+void __RPC_STUB IPropertyDescription_RemoteCoerceToCanonicalValue_Stub(
+    IRpcStubBuffer *This,
+    IRpcChannelBuffer *_pRpcChannelBuffer,
+    PRPC_MESSAGE _pRpcMessage,
+    DWORD *_pdwStubPhase);
+
+
+
+#endif 	/* __IPropertyDescription_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
+#define __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
+
+/* interface IPropertyDescriptionAliasInfo */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyDescriptionAliasInfo;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("f67104fc-2af9-46fd-b32d-243c1404f3d1")
+    IPropertyDescriptionAliasInfo : public IPropertyDescription
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetSortByAlias( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAdditionalSortByAliases( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyDescriptionAliasInfoVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyDescriptionAliasInfo * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyDescriptionAliasInfo * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out VARTYPE *pvartype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ PROPDESC_TYPE_FLAGS mask,
+            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out UINT *pcxChars);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ BOOL fDescending,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
+            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [out][in] */ PROPVARIANT *ppropvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortByAlias )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAdditionalSortByAliases )( 
+            IPropertyDescriptionAliasInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        END_INTERFACE
+    } IPropertyDescriptionAliasInfoVtbl;
+
+    interface IPropertyDescriptionAliasInfo
+    {
+        CONST_VTBL struct IPropertyDescriptionAliasInfoVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyDescriptionAliasInfo_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyDescriptionAliasInfo_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyDescriptionAliasInfo_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyDescriptionAliasInfo_GetPropertyKey(This,pkey)	\
+    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
+
+#define IPropertyDescriptionAliasInfo_GetCanonicalName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
+
+#define IPropertyDescriptionAliasInfo_GetPropertyType(This,pvartype)	\
+    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
+
+#define IPropertyDescriptionAliasInfo_GetDisplayName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
+
+#define IPropertyDescriptionAliasInfo_GetEditInvitation(This,ppszInvite)	\
+    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
+
+#define IPropertyDescriptionAliasInfo_GetTypeFlags(This,mask,ppdtFlags)	\
+    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
+
+#define IPropertyDescriptionAliasInfo_GetViewFlags(This,ppdvFlags)	\
+    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
+
+#define IPropertyDescriptionAliasInfo_GetDefaultColumnWidth(This,pcxChars)	\
+    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
+
+#define IPropertyDescriptionAliasInfo_GetDisplayType(This,pdisplaytype)	\
+    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
+
+#define IPropertyDescriptionAliasInfo_GetColumnState(This,pcsFlags)	\
+    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
+
+#define IPropertyDescriptionAliasInfo_GetGroupingRange(This,pgr)	\
+    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
+
+#define IPropertyDescriptionAliasInfo_GetRelativeDescriptionType(This,prdt)	\
+    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
+
+#define IPropertyDescriptionAliasInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
+    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
+
+#define IPropertyDescriptionAliasInfo_GetSortDescription(This,psd)	\
+    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
+
+#define IPropertyDescriptionAliasInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
+    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
+
+#define IPropertyDescriptionAliasInfo_GetAggregationType(This,paggtype)	\
+    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
+
+#define IPropertyDescriptionAliasInfo_GetConditionType(This,pcontype,popDefault)	\
+    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
+
+#define IPropertyDescriptionAliasInfo_GetEnumTypeList(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
+
+#define IPropertyDescriptionAliasInfo_CoerceToCanonicalValue(This,ppropvar)	\
+    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
+
+#define IPropertyDescriptionAliasInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
+    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
+
+#define IPropertyDescriptionAliasInfo_IsValueCanonical(This,propvar)	\
+    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
+
+
+#define IPropertyDescriptionAliasInfo_GetSortByAlias(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetSortByAlias(This,riid,ppv) ) 
+
+#define IPropertyDescriptionAliasInfo_GetAdditionalSortByAliases(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetAdditionalSortByAliases(This,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
+#define __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
+
+/* interface IPropertyDescriptionSearchInfo */
+/* [unique][object][uuid] */ 
+
+/* [v1_enum] */ 
+enum tagPROPDESC_SEARCHINFO_FLAGS
+    {	PDSIF_DEFAULT	= 0,
+	PDSIF_ININVERTEDINDEX	= 0x1,
+	PDSIF_ISCOLUMN	= 0x2,
+	PDSIF_ISCOLUMNSPARSE	= 0x4
+    } ;
+typedef int PROPDESC_SEARCHINFO_FLAGS;
+
+typedef /* [v1_enum] */ 
+enum tagPROPDESC_COLUMNINDEX_TYPE
+    {	PDCIT_NONE	= 0,
+	PDCIT_ONDISK	= 1,
+	PDCIT_INMEMORY	= 2
+    } 	PROPDESC_COLUMNINDEX_TYPE;
+
+
+EXTERN_C const IID IID_IPropertyDescriptionSearchInfo;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("078f91bd-29a2-440f-924e-46a291524520")
+    IPropertyDescriptionSearchInfo : public IPropertyDescription
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetSearchInfoFlags( 
+            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetColumnIndexType( 
+            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetProjectionString( 
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
+            /* [out] */ __RPC__out UINT *pcbMaxSize) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyDescriptionSearchInfoVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyDescriptionSearchInfo * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyDescriptionSearchInfo * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPERTYKEY *pkey);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out VARTYPE *pvartype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ PROPDESC_TYPE_FLAGS mask,
+            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out UINT *pcxChars);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ BOOL fDescending,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
+            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out][in] */ PROPVARIANT *ppropvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSearchInfoFlags )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetColumnIndexType )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetProjectionString )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
+            IPropertyDescriptionSearchInfo * This,
+            /* [out] */ __RPC__out UINT *pcbMaxSize);
+        
+        END_INTERFACE
+    } IPropertyDescriptionSearchInfoVtbl;
+
+    interface IPropertyDescriptionSearchInfo
+    {
+        CONST_VTBL struct IPropertyDescriptionSearchInfoVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyDescriptionSearchInfo_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyDescriptionSearchInfo_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyDescriptionSearchInfo_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyDescriptionSearchInfo_GetPropertyKey(This,pkey)	\
+    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 
+
+#define IPropertyDescriptionSearchInfo_GetCanonicalName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 
+
+#define IPropertyDescriptionSearchInfo_GetPropertyType(This,pvartype)	\
+    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 
+
+#define IPropertyDescriptionSearchInfo_GetDisplayName(This,ppszName)	\
+    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 
+
+#define IPropertyDescriptionSearchInfo_GetEditInvitation(This,ppszInvite)	\
+    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 
+
+#define IPropertyDescriptionSearchInfo_GetTypeFlags(This,mask,ppdtFlags)	\
+    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 
+
+#define IPropertyDescriptionSearchInfo_GetViewFlags(This,ppdvFlags)	\
+    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 
+
+#define IPropertyDescriptionSearchInfo_GetDefaultColumnWidth(This,pcxChars)	\
+    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 
+
+#define IPropertyDescriptionSearchInfo_GetDisplayType(This,pdisplaytype)	\
+    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 
+
+#define IPropertyDescriptionSearchInfo_GetColumnState(This,pcsFlags)	\
+    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 
+
+#define IPropertyDescriptionSearchInfo_GetGroupingRange(This,pgr)	\
+    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 
+
+#define IPropertyDescriptionSearchInfo_GetRelativeDescriptionType(This,prdt)	\
+    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 
+
+#define IPropertyDescriptionSearchInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
+    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 
+
+#define IPropertyDescriptionSearchInfo_GetSortDescription(This,psd)	\
+    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 
+
+#define IPropertyDescriptionSearchInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
+    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 
+
+#define IPropertyDescriptionSearchInfo_GetAggregationType(This,paggtype)	\
+    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 
+
+#define IPropertyDescriptionSearchInfo_GetConditionType(This,pcontype,popDefault)	\
+    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 
+
+#define IPropertyDescriptionSearchInfo_GetEnumTypeList(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 
+
+#define IPropertyDescriptionSearchInfo_CoerceToCanonicalValue(This,ppropvar)	\
+    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 
+
+#define IPropertyDescriptionSearchInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
+    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 
+
+#define IPropertyDescriptionSearchInfo_IsValueCanonical(This,propvar)	\
+    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 
+
+
+#define IPropertyDescriptionSearchInfo_GetSearchInfoFlags(This,ppdsiFlags)	\
+    ( (This)->lpVtbl -> GetSearchInfoFlags(This,ppdsiFlags) ) 
+
+#define IPropertyDescriptionSearchInfo_GetColumnIndexType(This,ppdciType)	\
+    ( (This)->lpVtbl -> GetColumnIndexType(This,ppdciType) ) 
+
+#define IPropertyDescriptionSearchInfo_GetProjectionString(This,ppszProjection)	\
+    ( (This)->lpVtbl -> GetProjectionString(This,ppszProjection) ) 
+
+#define IPropertyDescriptionSearchInfo_GetMaxSize(This,pcbMaxSize)	\
+    ( (This)->lpVtbl -> GetMaxSize(This,pcbMaxSize) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0014 */
+/* [local] */ 
+
+/* [v1_enum] */ 
+enum tagPROPDESC_ENUMFILTER
+    {	PDEF_ALL	= 0,
+	PDEF_SYSTEM	= 1,
+	PDEF_NONSYSTEM	= 2,
+	PDEF_VIEWABLE	= 3,
+	PDEF_QUERYABLE	= 4,
+	PDEF_INFULLTEXTQUERY	= 5,
+	PDEF_COLUMN	= 6
+    } ;
+typedef enum tagPROPDESC_ENUMFILTER PROPDESC_ENUMFILTER;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_s_ifspec;
+
+#ifndef __IPropertySystem_INTERFACE_DEFINED__
+#define __IPropertySystem_INTERFACE_DEFINED__
+
+/* interface IPropertySystem */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertySystem;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("ca724e8a-c3e6-442b-88a4-6fb0db8035a3")
+    IPropertySystem : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
+            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionByName( 
+            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionListFromString( 
+            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE EnumeratePropertyDescriptions( 
+            /* [in] */ PROPDESC_ENUMFILTER filterOn,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
+            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
+            /* [in] */ DWORD cchText) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE FormatForDisplayAlloc( 
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RegisterPropertySchema( 
+            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE UnregisterPropertySchema( 
+            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RefreshPropertySchema( void) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertySystemVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertySystem * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertySystem * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertySystem * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
+            IPropertySystem * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionByName )( 
+            IPropertySystem * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionListFromString )( 
+            IPropertySystem * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *EnumeratePropertyDescriptions )( 
+            IPropertySystem * This,
+            /* [in] */ PROPDESC_ENUMFILTER filterOn,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
+            IPropertySystem * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
+            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
+            /* [in] */ DWORD cchText);
+        
+        HRESULT ( STDMETHODCALLTYPE *FormatForDisplayAlloc )( 
+            IPropertySystem * This,
+            /* [in] */ __RPC__in REFPROPERTYKEY key,
+            /* [in] */ __RPC__in REFPROPVARIANT propvar,
+            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
+            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
+        
+        HRESULT ( STDMETHODCALLTYPE *RegisterPropertySchema )( 
+            IPropertySystem * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszPath);
+        
+        HRESULT ( STDMETHODCALLTYPE *UnregisterPropertySchema )( 
+            IPropertySystem * This,
+            /* [string][in] */ __RPC__in LPCWSTR pszPath);
+        
+        HRESULT ( STDMETHODCALLTYPE *RefreshPropertySchema )( 
+            IPropertySystem * This);
+        
+        END_INTERFACE
+    } IPropertySystemVtbl;
+
+    interface IPropertySystem
+    {
+        CONST_VTBL struct IPropertySystemVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertySystem_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertySystem_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertySystem_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertySystem_GetPropertyDescription(This,propkey,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyDescription(This,propkey,riid,ppv) ) 
+
+#define IPropertySystem_GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv) ) 
+
+#define IPropertySystem_GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv) ) 
+
+#define IPropertySystem_EnumeratePropertyDescriptions(This,filterOn,riid,ppv)	\
+    ( (This)->lpVtbl -> EnumeratePropertyDescriptions(This,filterOn,riid,ppv) ) 
+
+#define IPropertySystem_FormatForDisplay(This,key,propvar,pdff,pszText,cchText)	\
+    ( (This)->lpVtbl -> FormatForDisplay(This,key,propvar,pdff,pszText,cchText) ) 
+
+#define IPropertySystem_FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay)	\
+    ( (This)->lpVtbl -> FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay) ) 
+
+#define IPropertySystem_RegisterPropertySchema(This,pszPath)	\
+    ( (This)->lpVtbl -> RegisterPropertySchema(This,pszPath) ) 
+
+#define IPropertySystem_UnregisterPropertySchema(This,pszPath)	\
+    ( (This)->lpVtbl -> UnregisterPropertySchema(This,pszPath) ) 
+
+#define IPropertySystem_RefreshPropertySchema(This)	\
+    ( (This)->lpVtbl -> RefreshPropertySchema(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertySystem_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyDescriptionList_INTERFACE_DEFINED__
+#define __IPropertyDescriptionList_INTERFACE_DEFINED__
+
+/* interface IPropertyDescriptionList */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyDescriptionList;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("1f9fc1d0-c39b-4b26-817f-011967d3440e")
+    IPropertyDescriptionList : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetCount( 
+            /* [out] */ __RPC__out UINT *pcElem) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetAt( 
+            /* [in] */ UINT iElem,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyDescriptionListVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyDescriptionList * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyDescriptionList * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyDescriptionList * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
+            IPropertyDescriptionList * This,
+            /* [out] */ __RPC__out UINT *pcElem);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
+            IPropertyDescriptionList * This,
+            /* [in] */ UINT iElem,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        END_INTERFACE
+    } IPropertyDescriptionListVtbl;
+
+    interface IPropertyDescriptionList
+    {
+        CONST_VTBL struct IPropertyDescriptionListVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyDescriptionList_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyDescriptionList_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyDescriptionList_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyDescriptionList_GetCount(This,pcElem)	\
+    ( (This)->lpVtbl -> GetCount(This,pcElem) ) 
+
+#define IPropertyDescriptionList_GetAt(This,iElem,riid,ppv)	\
+    ( (This)->lpVtbl -> GetAt(This,iElem,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyDescriptionList_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertyStoreFactory_INTERFACE_DEFINED__
+#define __IPropertyStoreFactory_INTERFACE_DEFINED__
+
+/* interface IPropertyStoreFactory */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertyStoreFactory;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("bc110b6d-57e8-4148-a9c6-91015ab2f3a5")
+    IPropertyStoreFactory : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
+            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
+            /* [in] */ UINT cKeys,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertyStoreFactoryVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertyStoreFactory * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertyStoreFactory * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertyStoreFactory * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
+            IPropertyStoreFactory * This,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
+            IPropertyStoreFactory * This,
+            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
+            /* [in] */ UINT cKeys,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        END_INTERFACE
+    } IPropertyStoreFactoryVtbl;
+
+    interface IPropertyStoreFactory
+    {
+        CONST_VTBL struct IPropertyStoreFactoryVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertyStoreFactory_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertyStoreFactory_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 
+
+#define IPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertyStoreFactory_INTERFACE_DEFINED__ */
+
+
+#ifndef __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
+#define __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
+
+/* interface IDelayedPropertyStoreFactory */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IDelayedPropertyStoreFactory;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("40d4577f-e237-4bdb-bd69-58f089431b6a")
+    IDelayedPropertyStoreFactory : public IPropertyStoreFactory
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetDelayedPropertyStore( 
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [in] */ DWORD dwStoreId,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IDelayedPropertyStoreFactoryVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IDelayedPropertyStoreFactory * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IDelayedPropertyStoreFactory * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IDelayedPropertyStoreFactory * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
+            IDelayedPropertyStoreFactory * This,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
+            IDelayedPropertyStoreFactory * This,
+            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
+            /* [in] */ UINT cKeys,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetDelayedPropertyStore )( 
+            IDelayedPropertyStoreFactory * This,
+            /* [in] */ GETPROPERTYSTOREFLAGS flags,
+            /* [in] */ DWORD dwStoreId,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        END_INTERFACE
+    } IDelayedPropertyStoreFactoryVtbl;
+
+    interface IDelayedPropertyStoreFactory
+    {
+        CONST_VTBL struct IDelayedPropertyStoreFactoryVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IDelayedPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IDelayedPropertyStoreFactory_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IDelayedPropertyStoreFactory_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IDelayedPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 
+
+#define IDelayedPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
+    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 
+
+
+#define IDelayedPropertyStoreFactory_GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv)	\
+    ( (This)->lpVtbl -> GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0018 */
+/* [local] */ 
+
+/* [v1_enum] */ 
+enum tagPERSIST_SPROPSTORE_FLAGS
+    {	FPSPS_READONLY	= 0x1
+    } ;
+typedef int PERSIST_SPROPSTORE_FLAGS;
+
+typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE;
+
+typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;
+
+typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_s_ifspec;
+
+#ifndef __IPersistSerializedPropStorage_INTERFACE_DEFINED__
+#define __IPersistSerializedPropStorage_INTERFACE_DEFINED__
+
+/* interface IPersistSerializedPropStorage */
+/* [object][local][unique][uuid] */ 
+
+
+EXTERN_C const IID IID_IPersistSerializedPropStorage;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("e318ad57-0aa0-450f-aca5-6fab7103d917")
+    IPersistSerializedPropStorage : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
+            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetPropertyStorage( 
+            /* [in] */ 
+            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
+            /* [in] */ 
+            __in  DWORD cb) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorage( 
+            /* [out] */ 
+            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
+            /* [out] */ 
+            __out  DWORD *pcb) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPersistSerializedPropStorageVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPersistSerializedPropStorage * This,
+            /* [in] */ REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPersistSerializedPropStorage * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPersistSerializedPropStorage * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
+            IPersistSerializedPropStorage * This,
+            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
+            IPersistSerializedPropStorage * This,
+            /* [in] */ 
+            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
+            /* [in] */ 
+            __in  DWORD cb);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
+            IPersistSerializedPropStorage * This,
+            /* [out] */ 
+            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
+            /* [out] */ 
+            __out  DWORD *pcb);
+        
+        END_INTERFACE
+    } IPersistSerializedPropStorageVtbl;
+
+    interface IPersistSerializedPropStorage
+    {
+        CONST_VTBL struct IPersistSerializedPropStorageVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPersistSerializedPropStorage_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPersistSerializedPropStorage_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPersistSerializedPropStorage_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPersistSerializedPropStorage_SetFlags(This,flags)	\
+    ( (This)->lpVtbl -> SetFlags(This,flags) ) 
+
+#define IPersistSerializedPropStorage_SetPropertyStorage(This,psps,cb)	\
+    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 
+
+#define IPersistSerializedPropStorage_GetPropertyStorage(This,ppsps,pcb)	\
+    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPersistSerializedPropStorage_INTERFACE_DEFINED__ */
+
+
+#ifndef __IPropertySystemChangeNotify_INTERFACE_DEFINED__
+#define __IPropertySystemChangeNotify_INTERFACE_DEFINED__
+
+/* interface IPropertySystemChangeNotify */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IPropertySystemChangeNotify;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("fa955fd9-38be-4879-a6ce-824cf52d609f")
+    IPropertySystemChangeNotify : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE SchemaRefreshed( void) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IPropertySystemChangeNotifyVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IPropertySystemChangeNotify * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IPropertySystemChangeNotify * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IPropertySystemChangeNotify * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *SchemaRefreshed )( 
+            IPropertySystemChangeNotify * This);
+        
+        END_INTERFACE
+    } IPropertySystemChangeNotifyVtbl;
+
+    interface IPropertySystemChangeNotify
+    {
+        CONST_VTBL struct IPropertySystemChangeNotifyVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IPropertySystemChangeNotify_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IPropertySystemChangeNotify_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IPropertySystemChangeNotify_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IPropertySystemChangeNotify_SchemaRefreshed(This)	\
+    ( (This)->lpVtbl -> SchemaRefreshed(This) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IPropertySystemChangeNotify_INTERFACE_DEFINED__ */
+
+
+#ifndef __ICreateObject_INTERFACE_DEFINED__
+#define __ICreateObject_INTERFACE_DEFINED__
+
+/* interface ICreateObject */
+/* [object][unique][uuid] */ 
+
+
+EXTERN_C const IID IID_ICreateObject;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("75121952-e0d0-43e5-9380-1d80483acf72")
+    ICreateObject : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
+            /* [in] */ __RPC__in REFCLSID clsid,
+            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ICreateObjectVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ICreateObject * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ICreateObject * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ICreateObject * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
+            ICreateObject * This,
+            /* [in] */ __RPC__in REFCLSID clsid,
+            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
+        
+        END_INTERFACE
+    } ICreateObjectVtbl;
+
+    interface ICreateObject
+    {
+        CONST_VTBL struct ICreateObjectVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ICreateObject_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ICreateObject_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ICreateObject_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ICreateObject_CreateObject(This,clsid,pUnkOuter,riid,ppv)	\
+    ( (This)->lpVtbl -> CreateObject(This,clsid,pUnkOuter,riid,ppv) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ICreateObject_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_propsys_0000_0021 */
+/* [local] */ 
+
+// Format a property value for display purposes
+PSSTDAPI PSFormatForDisplay(
+    __in REFPROPERTYKEY propkey,
+    __in REFPROPVARIANT propvar,
+    __in PROPDESC_FORMAT_FLAGS pdfFlags,
+    __out_ecount(cchText) LPWSTR pwszText,
+    __in DWORD cchText);
+
+PSSTDAPI PSFormatForDisplayAlloc(
+    __in REFPROPERTYKEY key,
+    __in REFPROPVARIANT propvar,
+    __in PROPDESC_FORMAT_FLAGS pdff,
+    __deref_out PWSTR *ppszDisplay);
+
+PSSTDAPI PSFormatPropertyValue(
+    __in IPropertyStore *pps,
+    __in IPropertyDescription *ppd,
+    __in PROPDESC_FORMAT_FLAGS pdff,
+    __deref_out LPWSTR *ppszDisplay);
+
+
+#define PKEY_PIDSTR_MAX     10   // will take care of any long integer value
+#define GUIDSTRING_MAX      (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)  // "{12345678-1234-1234-1234-123456789012}"
+#define PKEYSTR_MAX         (GUIDSTRING_MAX + 1 + PKEY_PIDSTR_MAX)
+
+// Convert a PROPERTYKEY to and from a PWSTR
+PSSTDAPI PSStringFromPropertyKey(
+    __in REFPROPERTYKEY pkey,
+    __out_ecount(cch) LPWSTR psz,
+    __in UINT cch);
+
+PSSTDAPI PSPropertyKeyFromString(
+    __in LPCWSTR pszString,
+    __out PROPERTYKEY *pkey);
+
+
+// Creates an in-memory property store
+// Returns an IPropertyStore, IPersistSerializedPropStorage, and related interfaces interface
+PSSTDAPI PSCreateMemoryPropertyStore(
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Create a read-only, delay-bind multiplexing property store
+// Returns an IPropertyStore interface or related interfaces
+PSSTDAPI PSCreateDelayedMultiplexPropertyStore(
+    __in GETPROPERTYSTOREFLAGS flags,
+    __in IDelayedPropertyStoreFactory *pdpsf,
+    __in_ecount(cStores) const DWORD *rgStoreIds,
+    __in DWORD cStores,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Create a read-only property store from one or more sources (which each must support either IPropertyStore or IPropertySetStorage)
+// Returns an IPropertyStore interface or related interfaces
+PSSTDAPI PSCreateMultiplexPropertyStore(
+    __in_ecount(cStores) IUnknown **prgpunkStores,
+    __in DWORD cStores,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Create a container for IPropertyChanges
+// Returns an IPropertyChangeArray interface
+PSSTDAPI PSCreatePropertyChangeArray(
+    __in_ecount_opt(cChanges) const PROPERTYKEY *rgpropkey,
+    __in_ecount_opt(cChanges) const PKA_FLAGS *rgflags,
+    __in_ecount_opt(cChanges) const PROPVARIANT *rgpropvar,
+    __in UINT cChanges,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Create a simple property change
+// Returns an IPropertyChange interface
+PSSTDAPI PSCreateSimplePropertyChange(
+    __in PKA_FLAGS flags,
+    __in REFPROPERTYKEY key,
+    __in REFPROPVARIANT propvar,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Get a property description
+// Returns an IPropertyDescription interface
+PSSTDAPI PSGetPropertyDescription(
+    __in REFPROPERTYKEY propkey,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+PSSTDAPI PSGetPropertyDescriptionByName(
+    __in LPCWSTR pszCanonicalName,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Lookup a per-machine registered file property handler
+PSSTDAPI PSLookupPropertyHandlerCLSID(
+    __in PCWSTR pszFilePath,
+    __out CLSID *pclsid);
+// Get a property handler, on Vista or downlevel to XP
+// punkItem is a shell item created with an SHCreateItemXXX API
+// Returns an IPropertyStore
+PSSTDAPI PSGetItemPropertyHandler(
+    __in IUnknown *punkItem,
+    __in BOOL fReadWrite,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Get a property handler, on Vista or downlevel to XP
+// punkItem is a shell item created with an SHCreateItemXXX API
+// punkCreateObject supports ICreateObject
+// Returns an IPropertyStore
+PSSTDAPI PSGetItemPropertyHandlerWithCreateObject(
+    __in IUnknown *punkItem,
+    __in BOOL fReadWrite,
+    __in IUnknown *punkCreateObject,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Get or set a property value from a store
+PSSTDAPI PSGetPropertyValue(
+    __in IPropertyStore *pps,
+    __in IPropertyDescription *ppd,
+    __out PROPVARIANT *ppropvar);
+
+PSSTDAPI PSSetPropertyValue(
+    __in IPropertyStore *pps,
+    __in IPropertyDescription *ppd,
+    __in REFPROPVARIANT propvar);
+
+
+// Interact with the set of property descriptions
+PSSTDAPI PSRegisterPropertySchema(
+    __in PCWSTR pszPath);
+
+PSSTDAPI PSUnregisterPropertySchema(
+    __in PCWSTR pszPath);
+
+PSSTDAPI PSRefreshPropertySchema();
+
+// Returns either: IPropertyDescriptionList or IEnumUnknown interfaces
+PSSTDAPI PSEnumeratePropertyDescriptions(
+    __in PROPDESC_ENUMFILTER filterOn,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Convert between a PROPERTYKEY and its canonical name
+PSSTDAPI PSGetPropertyKeyFromName(
+    __in PCWSTR pszName,
+    __out PROPERTYKEY *ppropkey);
+
+PSSTDAPI PSGetNameFromPropertyKey(
+    __in REFPROPERTYKEY propkey,
+    __deref_out PWSTR *ppszCanonicalName);
+
+
+// Coerce and canonicalize a property value
+PSSTDAPI PSCoerceToCanonicalValue(
+    __in REFPROPERTYKEY key,
+    __inout PROPVARIANT *ppropvar);
+
+
+// Convert a 'prop:' string into a list of property descriptions
+// Returns an IPropertyDescriptionList interface
+PSSTDAPI PSGetPropertyDescriptionListFromString(
+    __in LPCWSTR pszPropList,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Wrap an IPropertySetStorage interface in an IPropertyStore interface
+// Returns an IPropertyStore or related interface
+PSSTDAPI PSCreatePropertyStoreFromPropertySetStorage(
+    __in IPropertySetStorage *ppss,
+    DWORD grfMode,
+    REFIID riid,
+    __deref_out void **ppv);
+
+
+// punkSource must support IPropertyStore or IPropertySetStorage
+// On success, the returned ppv is guaranteed to support IPropertyStore.
+// If punkSource already supports IPropertyStore, no wrapper is created.
+PSSTDAPI PSCreatePropertyStoreFromObject(
+    __in IUnknown *punk,
+    __in DWORD grfMode,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// punkSource must support IPropertyStore
+// riid may be IPropertyStore, IPropertySetStorage, IPropertyStoreCapabilities, or IObjectProvider
+PSSTDAPI PSCreateAdapterFromPropertyStore(
+    __in IPropertyStore *pps,
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Talk to the property system using an interface
+// Returns an IPropertySystem interface
+PSSTDAPI PSGetPropertySystem(
+    __in REFIID riid,
+    __deref_out void **ppv);
+
+
+// Obtain a value from serialized property storage
+PSSTDAPI PSGetPropertyFromPropertyStorage(
+    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
+    __in DWORD cb, 
+    __in REFPROPERTYKEY rpkey, 
+    __out PROPVARIANT *ppropvar);
+
+
+// Obtain a named value from serialized property storage
+PSSTDAPI PSGetNamedPropertyFromPropertyStorage(
+    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
+    __in DWORD cb, 
+    __in LPCWSTR pszName, 
+    __out PROPVARIANT *ppropvar);
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_s_ifspec;
+
+
+#ifndef __PropSysObjects_LIBRARY_DEFINED__
+#define __PropSysObjects_LIBRARY_DEFINED__
+
+/* library PropSysObjects */
+/* [version][lcid][uuid] */ 
+
+
+EXTERN_C const IID LIBID_PropSysObjects;
+
+EXTERN_C const CLSID CLSID_InMemoryPropertyStore;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("9a02e012-6303-4e1e-b9a1-630f802592c5")
+InMemoryPropertyStore;
+#endif
+
+EXTERN_C const CLSID CLSID_PropertySystem;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("b8967f85-58ae-4f46-9fb2-5d7904798f4b")
+PropertySystem;
+#endif
+#endif /* __PropSysObjects_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 
+
+unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 
+
+unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 
+
+/* [local] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Proxy( 
+    IInitializeWithStream * This,
+    /* [in] */ IStream *pstream,
+    /* [in] */ DWORD grfMode);
+
+
+/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Stub( 
+    IInitializeWithStream * This,
+    /* [in] */ __RPC__in_opt IStream *pstream,
+    /* [in] */ DWORD grfMode);
+
+/* [local] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Proxy( 
+    IPropertyDescription * This,
+    /* [out][in] */ PROPVARIANT *ppropvar);
+
+
+/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Stub( 
+    IPropertyDescription * This,
+    /* [in] */ __RPC__in REFPROPVARIANT propvar,
+    /* [out] */ __RPC__out PROPVARIANT *ppropvar);
+
+
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/mingw-include/rpcsal.h
+++ b/src/hostapi/wasapi/mingw-include/rpcsal.h
@@ -1,113 +1,113 @@
-#pragma once
-
-#if __GNUC__ >=3
-#pragma GCC system_header
-#endif
-
-#define RPC_range(min,max)
-
-#define __RPC__in           
-#define __RPC__in_string
-#define __RPC__in_opt_string
-#define __RPC__deref_opt_in_opt
-#define __RPC__opt_in_opt_string
-#define __RPC__in_ecount(size) 
-#define __RPC__in_ecount_full(size)
-#define __RPC__in_ecount_full_string(size)
-#define __RPC__in_ecount_part(size, length)
-#define __RPC__in_ecount_full_opt(size)
-#define __RPC__in_ecount_full_opt_string(size)
-#define __RPC__inout_ecount_full_opt_string(size)
-#define __RPC__in_ecount_part_opt(size, length)
-
-#define __RPC__deref_in 
-#define __RPC__deref_in_string
-#define __RPC__deref_opt_in
-#define __RPC__deref_in_opt
-#define __RPC__deref_in_ecount(size) 
-#define __RPC__deref_in_ecount_part(size, length) 
-#define __RPC__deref_in_ecount_full(size) 
-#define __RPC__deref_in_ecount_full_opt(size)
-#define __RPC__deref_in_ecount_full_string(size)
-#define __RPC__deref_in_ecount_full_opt_string(size)
-#define __RPC__deref_in_ecount_opt(size) 
-#define __RPC__deref_in_ecount_opt_string(size)
-#define __RPC__deref_in_ecount_part_opt(size, length) 
-
-// [out]
-#define __RPC__out     
-#define __RPC__out_ecount(size) 
-#define __RPC__out_ecount_part(size, length) 
-#define __RPC__out_ecount_full(size)
-#define __RPC__out_ecount_full_string(size)
-
-// [in,out] 
-#define __RPC__inout                                   
-#define __RPC__inout_string
-#define __RPC__opt_inout
-#define __RPC__inout_ecount(size)                     
-#define __RPC__inout_ecount_part(size, length)    
-#define __RPC__inout_ecount_full(size)          
-#define __RPC__inout_ecount_full_string(size)          
-
-// [in,unique] 
-#define __RPC__in_opt       
-#define __RPC__in_ecount_opt(size)   
-
-
-// [in,out,unique] 
-#define __RPC__inout_opt    
-#define __RPC__inout_ecount_opt(size)  
-#define __RPC__inout_ecount_part_opt(size, length) 
-#define __RPC__inout_ecount_full_opt(size)     
-#define __RPC__inout_ecount_full_string(size)
-
-// [out] **
-#define __RPC__deref_out   
-#define __RPC__deref_out_string
-#define __RPC__deref_out_opt 
-#define __RPC__deref_out_opt_string
-#define __RPC__deref_out_ecount(size) 
-#define __RPC__deref_out_ecount_part(size, length) 
-#define __RPC__deref_out_ecount_full(size)  
-#define __RPC__deref_out_ecount_full_string(size)
-
-
-// [in,out] **, second pointer decoration. 
-#define __RPC__deref_inout    
-#define __RPC__deref_inout_string
-#define __RPC__deref_inout_opt 
-#define __RPC__deref_inout_opt_string
-#define __RPC__deref_inout_ecount_full(size)
-#define __RPC__deref_inout_ecount_full_string(size)
-#define __RPC__deref_inout_ecount_opt(size) 
-#define __RPC__deref_inout_ecount_part_opt(size, length) 
-#define __RPC__deref_inout_ecount_full_opt(size) 
-#define __RPC__deref_inout_ecount_full_opt_string(size) 
-
-// #define __RPC_out_opt    out_opt is not allowed in rpc
-
-// [in,out,unique] 
-#define __RPC__deref_opt_inout  
-#define __RPC__deref_opt_inout_string
-#define __RPC__deref_opt_inout_ecount(size)     
-#define __RPC__deref_opt_inout_ecount_part(size, length) 
-#define __RPC__deref_opt_inout_ecount_full(size) 
-#define __RPC__deref_opt_inout_ecount_full_string(size)
-
-#define __RPC__deref_out_ecount_opt(size) 
-#define __RPC__deref_out_ecount_part_opt(size, length) 
-#define __RPC__deref_out_ecount_full_opt(size) 
-#define __RPC__deref_out_ecount_full_opt_string(size)
-
-#define __RPC__deref_opt_inout_opt      
-#define __RPC__deref_opt_inout_opt_string
-#define __RPC__deref_opt_inout_ecount_opt(size)   
-#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
-#define __RPC__deref_opt_inout_ecount_full_opt(size) 
-#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 
-
-#define __RPC_full_pointer  
-#define __RPC_unique_pointer
-#define __RPC_ref_pointer
-#define __RPC_string                               
+#pragma once
+
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+#define RPC_range(min,max)
+
+#define __RPC__in           
+#define __RPC__in_string
+#define __RPC__in_opt_string
+#define __RPC__deref_opt_in_opt
+#define __RPC__opt_in_opt_string
+#define __RPC__in_ecount(size) 
+#define __RPC__in_ecount_full(size)
+#define __RPC__in_ecount_full_string(size)
+#define __RPC__in_ecount_part(size, length)
+#define __RPC__in_ecount_full_opt(size)
+#define __RPC__in_ecount_full_opt_string(size)
+#define __RPC__inout_ecount_full_opt_string(size)
+#define __RPC__in_ecount_part_opt(size, length)
+
+#define __RPC__deref_in 
+#define __RPC__deref_in_string
+#define __RPC__deref_opt_in
+#define __RPC__deref_in_opt
+#define __RPC__deref_in_ecount(size) 
+#define __RPC__deref_in_ecount_part(size, length) 
+#define __RPC__deref_in_ecount_full(size) 
+#define __RPC__deref_in_ecount_full_opt(size)
+#define __RPC__deref_in_ecount_full_string(size)
+#define __RPC__deref_in_ecount_full_opt_string(size)
+#define __RPC__deref_in_ecount_opt(size) 
+#define __RPC__deref_in_ecount_opt_string(size)
+#define __RPC__deref_in_ecount_part_opt(size, length) 
+
+// [out]
+#define __RPC__out     
+#define __RPC__out_ecount(size) 
+#define __RPC__out_ecount_part(size, length) 
+#define __RPC__out_ecount_full(size)
+#define __RPC__out_ecount_full_string(size)
+
+// [in,out] 
+#define __RPC__inout                                   
+#define __RPC__inout_string
+#define __RPC__opt_inout
+#define __RPC__inout_ecount(size)                     
+#define __RPC__inout_ecount_part(size, length)    
+#define __RPC__inout_ecount_full(size)          
+#define __RPC__inout_ecount_full_string(size)          
+
+// [in,unique] 
+#define __RPC__in_opt       
+#define __RPC__in_ecount_opt(size)   
+
+
+// [in,out,unique] 
+#define __RPC__inout_opt    
+#define __RPC__inout_ecount_opt(size)  
+#define __RPC__inout_ecount_part_opt(size, length) 
+#define __RPC__inout_ecount_full_opt(size)     
+#define __RPC__inout_ecount_full_string(size)
+
+// [out] **
+#define __RPC__deref_out   
+#define __RPC__deref_out_string
+#define __RPC__deref_out_opt 
+#define __RPC__deref_out_opt_string
+#define __RPC__deref_out_ecount(size) 
+#define __RPC__deref_out_ecount_part(size, length) 
+#define __RPC__deref_out_ecount_full(size)  
+#define __RPC__deref_out_ecount_full_string(size)
+
+
+// [in,out] **, second pointer decoration. 
+#define __RPC__deref_inout    
+#define __RPC__deref_inout_string
+#define __RPC__deref_inout_opt 
+#define __RPC__deref_inout_opt_string
+#define __RPC__deref_inout_ecount_full(size)
+#define __RPC__deref_inout_ecount_full_string(size)
+#define __RPC__deref_inout_ecount_opt(size) 
+#define __RPC__deref_inout_ecount_part_opt(size, length) 
+#define __RPC__deref_inout_ecount_full_opt(size) 
+#define __RPC__deref_inout_ecount_full_opt_string(size) 
+
+// #define __RPC_out_opt    out_opt is not allowed in rpc
+
+// [in,out,unique] 
+#define __RPC__deref_opt_inout  
+#define __RPC__deref_opt_inout_string
+#define __RPC__deref_opt_inout_ecount(size)     
+#define __RPC__deref_opt_inout_ecount_part(size, length) 
+#define __RPC__deref_opt_inout_ecount_full(size) 
+#define __RPC__deref_opt_inout_ecount_full_string(size)
+
+#define __RPC__deref_out_ecount_opt(size) 
+#define __RPC__deref_out_ecount_part_opt(size, length) 
+#define __RPC__deref_out_ecount_full_opt(size) 
+#define __RPC__deref_out_ecount_full_opt_string(size)
+
+#define __RPC__deref_opt_inout_opt      
+#define __RPC__deref_opt_inout_opt_string
+#define __RPC__deref_opt_inout_ecount_opt(size)   
+#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
+#define __RPC__deref_opt_inout_ecount_full_opt(size) 
+#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 
+
+#define __RPC_full_pointer  
+#define __RPC_unique_pointer
+#define __RPC_ref_pointer
+#define __RPC_string                               
--- a/src/hostapi/wasapi/mingw-include/sal.h
+++ b/src/hostapi/wasapi/mingw-include/sal.h
@@ -1,252 +1,252 @@
-#pragma once
-
-#if __GNUC__ >=3
-#pragma GCC system_header
-#endif
-
-/*#define __null*/ // << Conflicts with GCC internal type __null
-#define __notnull
-#define __maybenull
-#define __readonly
-#define __notreadonly
-#define __maybereadonly
-#define __valid
-#define __notvalid
-#define __maybevalid
-#define __readableTo(extent)
-#define __elem_readableTo(size)
-#define __byte_readableTo(size)
-#define __writableTo(size)
-#define __elem_writableTo(size)
-#define __byte_writableTo(size)
-#define __deref
-#define __pre
-#define __post
-#define __precond(expr)
-#define __postcond(expr)
-#define __exceptthat
-#define __execeptthat
-#define __inner_success(expr)
-#define __inner_checkReturn
-#define __inner_typefix(ctype)
-#define __inner_override
-#define __inner_callback
-#define __inner_blocksOn(resource)
-#define __inner_fallthrough_dec
-#define __inner_fallthrough
-#define __refparam
-#define __inner_control_entrypoint(category)
-#define __inner_data_entrypoint(category)
-
-#define __ecount(size)
-#define __bcount(size)
-#define __in
-#define __in_ecount(size)
-#define __in_bcount(size)
-#define __in_z
-#define __in_ecount_z(size)
-#define __in_bcount_z(size)
-#define __in_nz
-#define __in_ecount_nz(size)
-#define __in_bcount_nz(size)
-#define __out
-#define __out_ecount(size)
-#define __out_bcount(size)
-#define __out_ecount_part(size,length)
-#define __out_bcount_part(size,length)
-#define __out_ecount_full(size)
-#define __out_bcount_full(size)
-#define __out_z
-#define __out_z_opt
-#define __out_ecount_z(size)
-#define __out_bcount_z(size)
-#define __out_ecount_part_z(size,length)
-#define __out_bcount_part_z(size,length)
-#define __out_ecount_full_z(size)
-#define __out_bcount_full_z(size)
-#define __out_nz
-#define __out_nz_opt
-#define __out_ecount_nz(size)
-#define __out_bcount_nz(size)
-#define __inout
-#define __inout_ecount(size)
-#define __inout_bcount(size)
-#define __inout_ecount_part(size,length)
-#define __inout_bcount_part(size,length)
-#define __inout_ecount_full(size)
-#define __inout_bcount_full(size)
-#define __inout_z
-#define __inout_ecount_z(size)
-#define __inout_bcount_z(size)
-#define __inout_nz
-#define __inout_ecount_nz(size)
-#define __inout_bcount_nz(size)
-#define __ecount_opt(size)
-#define __bcount_opt(size)
-#define __in_opt
-#define __in_ecount_opt(size)
-#define __in_bcount_opt(size)
-#define __in_z_opt
-#define __in_ecount_z_opt(size)
-#define __in_bcount_z_opt(size)
-#define __in_nz_opt
-#define __in_ecount_nz_opt(size)
-#define __in_bcount_nz_opt(size)
-#define __out_opt
-#define __out_ecount_opt(size)
-#define __out_bcount_opt(size)
-#define __out_ecount_part_opt(size,length)
-#define __out_bcount_part_opt(size,length)
-#define __out_ecount_full_opt(size)
-#define __out_bcount_full_opt(size)
-#define __out_ecount_z_opt(size)
-#define __out_bcount_z_opt(size)
-#define __out_ecount_part_z_opt(size,length)
-#define __out_bcount_part_z_opt(size,length)
-#define __out_ecount_full_z_opt(size)
-#define __out_bcount_full_z_opt(size)
-#define __out_ecount_nz_opt(size)
-#define __out_bcount_nz_opt(size)
-#define __inout_opt
-#define __inout_ecount_opt(size)
-#define __inout_bcount_opt(size)
-#define __inout_ecount_part_opt(size,length)
-#define __inout_bcount_part_opt(size,length)
-#define __inout_ecount_full_opt(size)
-#define __inout_bcount_full_opt(size)
-#define __inout_z_opt
-#define __inout_ecount_z_opt(size)
-#define __inout_ecount_z_opt(size)
-#define __inout_bcount_z_opt(size)
-#define __inout_nz_opt
-#define __inout_ecount_nz_opt(size)
-#define __inout_bcount_nz_opt(size)
-#define __deref_ecount(size)
-#define __deref_bcount(size)
-#define __deref_out
-#define __deref_out_ecount(size)
-#define __deref_out_bcount(size)
-#define __deref_out_ecount_part(size,length)
-#define __deref_out_bcount_part(size,length)
-#define __deref_out_ecount_full(size)
-#define __deref_out_bcount_full(size)
-#define __deref_out_z
-#define __deref_out_ecount_z(size)
-#define __deref_out_bcount_z(size)
-#define __deref_out_nz
-#define __deref_out_ecount_nz(size)
-#define __deref_out_bcount_nz(size)
-#define __deref_inout
-#define __deref_inout_z
-#define __deref_inout_ecount(size)
-#define __deref_inout_bcount(size)
-#define __deref_inout_ecount_part(size,length)
-#define __deref_inout_bcount_part(size,length)
-#define __deref_inout_ecount_full(size)
-#define __deref_inout_bcount_full(size)
-#define __deref_inout_z
-#define __deref_inout_ecount_z(size)
-#define __deref_inout_bcount_z(size)
-#define __deref_inout_nz
-#define __deref_inout_ecount_nz(size)
-#define __deref_inout_bcount_nz(size)
-#define __deref_ecount_opt(size)
-#define __deref_bcount_opt(size)
-#define __deref_out_opt
-#define __deref_out_ecount_opt(size)
-#define __deref_out_bcount_opt(size)
-#define __deref_out_ecount_part_opt(size,length)
-#define __deref_out_bcount_part_opt(size,length)
-#define __deref_out_ecount_full_opt(size)
-#define __deref_out_bcount_full_opt(size)
-#define __deref_out_z_opt
-#define __deref_out_ecount_z_opt(size)
-#define __deref_out_bcount_z_opt(size)
-#define __deref_out_nz_opt
-#define __deref_out_ecount_nz_opt(size)
-#define __deref_out_bcount_nz_opt(size)
-#define __deref_inout_opt
-#define __deref_inout_ecount_opt(size)
-#define __deref_inout_bcount_opt(size)
-#define __deref_inout_ecount_part_opt(size,length)
-#define __deref_inout_bcount_part_opt(size,length)
-#define __deref_inout_ecount_full_opt(size)
-#define __deref_inout_bcount_full_opt(size)
-#define __deref_inout_z_opt
-#define __deref_inout_ecount_z_opt(size)
-#define __deref_inout_bcount_z_opt(size)
-#define __deref_inout_nz_opt
-#define __deref_inout_ecount_nz_opt(size)
-#define __deref_inout_bcount_nz_opt(size)
-#define __deref_opt_ecount(size)
-#define __deref_opt_bcount(size)
-#define __deref_opt_out
-#define __deref_opt_out_z
-#define __deref_opt_out_ecount(size)
-#define __deref_opt_out_bcount(size)
-#define __deref_opt_out_ecount_part(size,length)
-#define __deref_opt_out_bcount_part(size,length)
-#define __deref_opt_out_ecount_full(size)
-#define __deref_opt_out_bcount_full(size)
-#define __deref_opt_inout
-#define __deref_opt_inout_ecount(size)
-#define __deref_opt_inout_bcount(size)
-#define __deref_opt_inout_ecount_part(size,length)
-#define __deref_opt_inout_bcount_part(size,length)
-#define __deref_opt_inout_ecount_full(size)
-#define __deref_opt_inout_bcount_full(size)
-#define __deref_opt_inout_z
-#define __deref_opt_inout_ecount_z(size)
-#define __deref_opt_inout_bcount_z(size)
-#define __deref_opt_inout_nz
-#define __deref_opt_inout_ecount_nz(size)
-#define __deref_opt_inout_bcount_nz(size)
-#define __deref_opt_ecount_opt(size)
-#define __deref_opt_bcount_opt(size)
-#define __deref_opt_out_opt
-#define __deref_opt_out_ecount_opt(size)
-#define __deref_opt_out_bcount_opt(size)
-#define __deref_opt_out_ecount_part_opt(size,length)
-#define __deref_opt_out_bcount_part_opt(size,length)
-#define __deref_opt_out_ecount_full_opt(size)
-#define __deref_opt_out_bcount_full_opt(size)
-#define __deref_opt_out_z_opt
-#define __deref_opt_out_ecount_z_opt(size)
-#define __deref_opt_out_bcount_z_opt(size)
-#define __deref_opt_out_nz_opt
-#define __deref_opt_out_ecount_nz_opt(size)
-#define __deref_opt_out_bcount_nz_opt(size)
-#define __deref_opt_inout_opt
-#define __deref_opt_inout_ecount_opt(size)
-#define __deref_opt_inout_bcount_opt(size)
-#define __deref_opt_inout_ecount_part_opt(size,length)
-#define __deref_opt_inout_bcount_part_opt(size,length)
-#define __deref_opt_inout_ecount_full_opt(size)
-#define __deref_opt_inout_bcount_full_opt(size)
-#define __deref_opt_inout_z_opt
-#define __deref_opt_inout_ecount_z_opt(size)
-#define __deref_opt_inout_bcount_z_opt(size)
-#define __deref_opt_inout_nz_opt
-#define __deref_opt_inout_ecount_nz_opt(size)
-#define __deref_opt_inout_bcount_nz_opt(size)
-
-#define __success(expr)
-#define __nullterminated
-#define __nullnullterminated
-#define __reserved
-#define __checkReturn
-#define __typefix(ctype)
-#define __override
-#define __callback
-#define __format_string
-#define __blocksOn(resource)
-#define __control_entrypoint(category)
-#define __data_entrypoint(category)
-
-#ifndef __fallthrough
-    #define __fallthrough __inner_fallthrough
-#endif
-
-#ifndef __analysis_assume
-    #define __analysis_assume(expr)
-#endif
+#pragma once
+
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+/*#define __null*/ // << Conflicts with GCC internal type __null
+#define __notnull
+#define __maybenull
+#define __readonly
+#define __notreadonly
+#define __maybereadonly
+#define __valid
+#define __notvalid
+#define __maybevalid
+#define __readableTo(extent)
+#define __elem_readableTo(size)
+#define __byte_readableTo(size)
+#define __writableTo(size)
+#define __elem_writableTo(size)
+#define __byte_writableTo(size)
+#define __deref
+#define __pre
+#define __post
+#define __precond(expr)
+#define __postcond(expr)
+#define __exceptthat
+#define __execeptthat
+#define __inner_success(expr)
+#define __inner_checkReturn
+#define __inner_typefix(ctype)
+#define __inner_override
+#define __inner_callback
+#define __inner_blocksOn(resource)
+#define __inner_fallthrough_dec
+#define __inner_fallthrough
+#define __refparam
+#define __inner_control_entrypoint(category)
+#define __inner_data_entrypoint(category)
+
+#define __ecount(size)
+#define __bcount(size)
+#define __in
+#define __in_ecount(size)
+#define __in_bcount(size)
+#define __in_z
+#define __in_ecount_z(size)
+#define __in_bcount_z(size)
+#define __in_nz
+#define __in_ecount_nz(size)
+#define __in_bcount_nz(size)
+#define __out
+#define __out_ecount(size)
+#define __out_bcount(size)
+#define __out_ecount_part(size,length)
+#define __out_bcount_part(size,length)
+#define __out_ecount_full(size)
+#define __out_bcount_full(size)
+#define __out_z
+#define __out_z_opt
+#define __out_ecount_z(size)
+#define __out_bcount_z(size)
+#define __out_ecount_part_z(size,length)
+#define __out_bcount_part_z(size,length)
+#define __out_ecount_full_z(size)
+#define __out_bcount_full_z(size)
+#define __out_nz
+#define __out_nz_opt
+#define __out_ecount_nz(size)
+#define __out_bcount_nz(size)
+#define __inout
+#define __inout_ecount(size)
+#define __inout_bcount(size)
+#define __inout_ecount_part(size,length)
+#define __inout_bcount_part(size,length)
+#define __inout_ecount_full(size)
+#define __inout_bcount_full(size)
+#define __inout_z
+#define __inout_ecount_z(size)
+#define __inout_bcount_z(size)
+#define __inout_nz
+#define __inout_ecount_nz(size)
+#define __inout_bcount_nz(size)
+#define __ecount_opt(size)
+#define __bcount_opt(size)
+#define __in_opt
+#define __in_ecount_opt(size)
+#define __in_bcount_opt(size)
+#define __in_z_opt
+#define __in_ecount_z_opt(size)
+#define __in_bcount_z_opt(size)
+#define __in_nz_opt
+#define __in_ecount_nz_opt(size)
+#define __in_bcount_nz_opt(size)
+#define __out_opt
+#define __out_ecount_opt(size)
+#define __out_bcount_opt(size)
+#define __out_ecount_part_opt(size,length)
+#define __out_bcount_part_opt(size,length)
+#define __out_ecount_full_opt(size)
+#define __out_bcount_full_opt(size)
+#define __out_ecount_z_opt(size)
+#define __out_bcount_z_opt(size)
+#define __out_ecount_part_z_opt(size,length)
+#define __out_bcount_part_z_opt(size,length)
+#define __out_ecount_full_z_opt(size)
+#define __out_bcount_full_z_opt(size)
+#define __out_ecount_nz_opt(size)
+#define __out_bcount_nz_opt(size)
+#define __inout_opt
+#define __inout_ecount_opt(size)
+#define __inout_bcount_opt(size)
+#define __inout_ecount_part_opt(size,length)
+#define __inout_bcount_part_opt(size,length)
+#define __inout_ecount_full_opt(size)
+#define __inout_bcount_full_opt(size)
+#define __inout_z_opt
+#define __inout_ecount_z_opt(size)
+#define __inout_ecount_z_opt(size)
+#define __inout_bcount_z_opt(size)
+#define __inout_nz_opt
+#define __inout_ecount_nz_opt(size)
+#define __inout_bcount_nz_opt(size)
+#define __deref_ecount(size)
+#define __deref_bcount(size)
+#define __deref_out
+#define __deref_out_ecount(size)
+#define __deref_out_bcount(size)
+#define __deref_out_ecount_part(size,length)
+#define __deref_out_bcount_part(size,length)
+#define __deref_out_ecount_full(size)
+#define __deref_out_bcount_full(size)
+#define __deref_out_z
+#define __deref_out_ecount_z(size)
+#define __deref_out_bcount_z(size)
+#define __deref_out_nz
+#define __deref_out_ecount_nz(size)
+#define __deref_out_bcount_nz(size)
+#define __deref_inout
+#define __deref_inout_z
+#define __deref_inout_ecount(size)
+#define __deref_inout_bcount(size)
+#define __deref_inout_ecount_part(size,length)
+#define __deref_inout_bcount_part(size,length)
+#define __deref_inout_ecount_full(size)
+#define __deref_inout_bcount_full(size)
+#define __deref_inout_z
+#define __deref_inout_ecount_z(size)
+#define __deref_inout_bcount_z(size)
+#define __deref_inout_nz
+#define __deref_inout_ecount_nz(size)
+#define __deref_inout_bcount_nz(size)
+#define __deref_ecount_opt(size)
+#define __deref_bcount_opt(size)
+#define __deref_out_opt
+#define __deref_out_ecount_opt(size)
+#define __deref_out_bcount_opt(size)
+#define __deref_out_ecount_part_opt(size,length)
+#define __deref_out_bcount_part_opt(size,length)
+#define __deref_out_ecount_full_opt(size)
+#define __deref_out_bcount_full_opt(size)
+#define __deref_out_z_opt
+#define __deref_out_ecount_z_opt(size)
+#define __deref_out_bcount_z_opt(size)
+#define __deref_out_nz_opt
+#define __deref_out_ecount_nz_opt(size)
+#define __deref_out_bcount_nz_opt(size)
+#define __deref_inout_opt
+#define __deref_inout_ecount_opt(size)
+#define __deref_inout_bcount_opt(size)
+#define __deref_inout_ecount_part_opt(size,length)
+#define __deref_inout_bcount_part_opt(size,length)
+#define __deref_inout_ecount_full_opt(size)
+#define __deref_inout_bcount_full_opt(size)
+#define __deref_inout_z_opt
+#define __deref_inout_ecount_z_opt(size)
+#define __deref_inout_bcount_z_opt(size)
+#define __deref_inout_nz_opt
+#define __deref_inout_ecount_nz_opt(size)
+#define __deref_inout_bcount_nz_opt(size)
+#define __deref_opt_ecount(size)
+#define __deref_opt_bcount(size)
+#define __deref_opt_out
+#define __deref_opt_out_z
+#define __deref_opt_out_ecount(size)
+#define __deref_opt_out_bcount(size)
+#define __deref_opt_out_ecount_part(size,length)
+#define __deref_opt_out_bcount_part(size,length)
+#define __deref_opt_out_ecount_full(size)
+#define __deref_opt_out_bcount_full(size)
+#define __deref_opt_inout
+#define __deref_opt_inout_ecount(size)
+#define __deref_opt_inout_bcount(size)
+#define __deref_opt_inout_ecount_part(size,length)
+#define __deref_opt_inout_bcount_part(size,length)
+#define __deref_opt_inout_ecount_full(size)
+#define __deref_opt_inout_bcount_full(size)
+#define __deref_opt_inout_z
+#define __deref_opt_inout_ecount_z(size)
+#define __deref_opt_inout_bcount_z(size)
+#define __deref_opt_inout_nz
+#define __deref_opt_inout_ecount_nz(size)
+#define __deref_opt_inout_bcount_nz(size)
+#define __deref_opt_ecount_opt(size)
+#define __deref_opt_bcount_opt(size)
+#define __deref_opt_out_opt
+#define __deref_opt_out_ecount_opt(size)
+#define __deref_opt_out_bcount_opt(size)
+#define __deref_opt_out_ecount_part_opt(size,length)
+#define __deref_opt_out_bcount_part_opt(size,length)
+#define __deref_opt_out_ecount_full_opt(size)
+#define __deref_opt_out_bcount_full_opt(size)
+#define __deref_opt_out_z_opt
+#define __deref_opt_out_ecount_z_opt(size)
+#define __deref_opt_out_bcount_z_opt(size)
+#define __deref_opt_out_nz_opt
+#define __deref_opt_out_ecount_nz_opt(size)
+#define __deref_opt_out_bcount_nz_opt(size)
+#define __deref_opt_inout_opt
+#define __deref_opt_inout_ecount_opt(size)
+#define __deref_opt_inout_bcount_opt(size)
+#define __deref_opt_inout_ecount_part_opt(size,length)
+#define __deref_opt_inout_bcount_part_opt(size,length)
+#define __deref_opt_inout_ecount_full_opt(size)
+#define __deref_opt_inout_bcount_full_opt(size)
+#define __deref_opt_inout_z_opt
+#define __deref_opt_inout_ecount_z_opt(size)
+#define __deref_opt_inout_bcount_z_opt(size)
+#define __deref_opt_inout_nz_opt
+#define __deref_opt_inout_ecount_nz_opt(size)
+#define __deref_opt_inout_bcount_nz_opt(size)
+
+#define __success(expr)
+#define __nullterminated
+#define __nullnullterminated
+#define __reserved
+#define __checkReturn
+#define __typefix(ctype)
+#define __override
+#define __callback
+#define __format_string
+#define __blocksOn(resource)
+#define __control_entrypoint(category)
+#define __data_entrypoint(category)
+
+#ifndef __fallthrough
+    #define __fallthrough __inner_fallthrough
+#endif
+
+#ifndef __analysis_assume
+    #define __analysis_assume(expr)
+#endif
--- a/src/hostapi/wasapi/mingw-include/structuredquery.h
+++ b/src/hostapi/wasapi/mingw-include/structuredquery.h
@@ -1,2478 +1,2478 @@
-
-
-/* this ALWAYS GENERATED file contains the definitions for the interfaces */
-
-
- /* File created by MIDL compiler version 7.00.0499 */
-/* Compiler settings for structuredquery.idl:
-    Oicf, W1, Zp8, env=Win32 (32b run)
-    protocol : dce , ms_ext, c_ext, robust
-    error checks: allocation ref bounds_check enum stub_data 
-    VC __declspec() decoration level: 
-         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
-         DECLSPEC_UUID(), MIDL_INTERFACE()
-*/
-//@@MIDL_FILE_HEADING(  )
-
-#pragma warning( disable: 4049 )  /* more than 64k source lines */
-
-
-/* verify that the <rpcndr.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCNDR_H_VERSION__
-#define __REQUIRED_RPCNDR_H_VERSION__ 475
-#endif
-
-/* verify that the <rpcsal.h> version is high enough to compile this file*/
-#ifndef __REQUIRED_RPCSAL_H_VERSION__
-#define __REQUIRED_RPCSAL_H_VERSION__ 100
-#endif
-
-#include "rpc.h"
-#include "rpcndr.h"
-
-#ifndef __RPCNDR_H_VERSION__
-#error this stub requires an updated version of <rpcndr.h>
-#endif // __RPCNDR_H_VERSION__
-
-#ifndef COM_NO_WINDOWS_H
-#include "windows.h"
-#include "ole2.h"
-#endif /*COM_NO_WINDOWS_H*/
-
-#ifndef __structuredquery_h__
-#define __structuredquery_h__
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-#pragma once
-#endif
-
-/* Forward Declarations */ 
-
-#ifndef __IQueryParser_FWD_DEFINED__
-#define __IQueryParser_FWD_DEFINED__
-typedef interface IQueryParser IQueryParser;
-#endif 	/* __IQueryParser_FWD_DEFINED__ */
-
-
-#ifndef __IConditionFactory_FWD_DEFINED__
-#define __IConditionFactory_FWD_DEFINED__
-typedef interface IConditionFactory IConditionFactory;
-#endif 	/* __IConditionFactory_FWD_DEFINED__ */
-
-
-#ifndef __IQuerySolution_FWD_DEFINED__
-#define __IQuerySolution_FWD_DEFINED__
-typedef interface IQuerySolution IQuerySolution;
-#endif 	/* __IQuerySolution_FWD_DEFINED__ */
-
-
-#ifndef __ICondition_FWD_DEFINED__
-#define __ICondition_FWD_DEFINED__
-typedef interface ICondition ICondition;
-#endif 	/* __ICondition_FWD_DEFINED__ */
-
-
-#ifndef __IConditionGenerator_FWD_DEFINED__
-#define __IConditionGenerator_FWD_DEFINED__
-typedef interface IConditionGenerator IConditionGenerator;
-#endif 	/* __IConditionGenerator_FWD_DEFINED__ */
-
-
-#ifndef __IRichChunk_FWD_DEFINED__
-#define __IRichChunk_FWD_DEFINED__
-typedef interface IRichChunk IRichChunk;
-#endif 	/* __IRichChunk_FWD_DEFINED__ */
-
-
-#ifndef __IInterval_FWD_DEFINED__
-#define __IInterval_FWD_DEFINED__
-typedef interface IInterval IInterval;
-#endif 	/* __IInterval_FWD_DEFINED__ */
-
-
-#ifndef __IMetaData_FWD_DEFINED__
-#define __IMetaData_FWD_DEFINED__
-typedef interface IMetaData IMetaData;
-#endif 	/* __IMetaData_FWD_DEFINED__ */
-
-
-#ifndef __IEntity_FWD_DEFINED__
-#define __IEntity_FWD_DEFINED__
-typedef interface IEntity IEntity;
-#endif 	/* __IEntity_FWD_DEFINED__ */
-
-
-#ifndef __IRelationship_FWD_DEFINED__
-#define __IRelationship_FWD_DEFINED__
-typedef interface IRelationship IRelationship;
-#endif 	/* __IRelationship_FWD_DEFINED__ */
-
-
-#ifndef __INamedEntity_FWD_DEFINED__
-#define __INamedEntity_FWD_DEFINED__
-typedef interface INamedEntity INamedEntity;
-#endif 	/* __INamedEntity_FWD_DEFINED__ */
-
-
-#ifndef __ISchemaProvider_FWD_DEFINED__
-#define __ISchemaProvider_FWD_DEFINED__
-typedef interface ISchemaProvider ISchemaProvider;
-#endif 	/* __ISchemaProvider_FWD_DEFINED__ */
-
-
-#ifndef __ITokenCollection_FWD_DEFINED__
-#define __ITokenCollection_FWD_DEFINED__
-typedef interface ITokenCollection ITokenCollection;
-#endif 	/* __ITokenCollection_FWD_DEFINED__ */
-
-
-#ifndef __INamedEntityCollector_FWD_DEFINED__
-#define __INamedEntityCollector_FWD_DEFINED__
-typedef interface INamedEntityCollector INamedEntityCollector;
-#endif 	/* __INamedEntityCollector_FWD_DEFINED__ */
-
-
-#ifndef __ISchemaLocalizerSupport_FWD_DEFINED__
-#define __ISchemaLocalizerSupport_FWD_DEFINED__
-typedef interface ISchemaLocalizerSupport ISchemaLocalizerSupport;
-#endif 	/* __ISchemaLocalizerSupport_FWD_DEFINED__ */
-
-
-#ifndef __IQueryParserManager_FWD_DEFINED__
-#define __IQueryParserManager_FWD_DEFINED__
-typedef interface IQueryParserManager IQueryParserManager;
-#endif 	/* __IQueryParserManager_FWD_DEFINED__ */
-
-
-#ifndef __QueryParser_FWD_DEFINED__
-#define __QueryParser_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class QueryParser QueryParser;
-#else
-typedef struct QueryParser QueryParser;
-#endif /* __cplusplus */
-
-#endif 	/* __QueryParser_FWD_DEFINED__ */
-
-
-#ifndef __NegationCondition_FWD_DEFINED__
-#define __NegationCondition_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class NegationCondition NegationCondition;
-#else
-typedef struct NegationCondition NegationCondition;
-#endif /* __cplusplus */
-
-#endif 	/* __NegationCondition_FWD_DEFINED__ */
-
-
-#ifndef __CompoundCondition_FWD_DEFINED__
-#define __CompoundCondition_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class CompoundCondition CompoundCondition;
-#else
-typedef struct CompoundCondition CompoundCondition;
-#endif /* __cplusplus */
-
-#endif 	/* __CompoundCondition_FWD_DEFINED__ */
-
-
-#ifndef __LeafCondition_FWD_DEFINED__
-#define __LeafCondition_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class LeafCondition LeafCondition;
-#else
-typedef struct LeafCondition LeafCondition;
-#endif /* __cplusplus */
-
-#endif 	/* __LeafCondition_FWD_DEFINED__ */
-
-
-#ifndef __ConditionFactory_FWD_DEFINED__
-#define __ConditionFactory_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class ConditionFactory ConditionFactory;
-#else
-typedef struct ConditionFactory ConditionFactory;
-#endif /* __cplusplus */
-
-#endif 	/* __ConditionFactory_FWD_DEFINED__ */
-
-
-#ifndef __Interval_FWD_DEFINED__
-#define __Interval_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class Interval Interval;
-#else
-typedef struct Interval Interval;
-#endif /* __cplusplus */
-
-#endif 	/* __Interval_FWD_DEFINED__ */
-
-
-#ifndef __QueryParserManager_FWD_DEFINED__
-#define __QueryParserManager_FWD_DEFINED__
-
-#ifdef __cplusplus
-typedef class QueryParserManager QueryParserManager;
-#else
-typedef struct QueryParserManager QueryParserManager;
-#endif /* __cplusplus */
-
-#endif 	/* __QueryParserManager_FWD_DEFINED__ */
-
-
-/* header files for imported files */
-#include "oaidl.h"
-#include "ocidl.h"
-#include "propidl.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif 
-
-
-/* interface __MIDL_itf_structuredquery_0000_0000 */
-/* [local] */ 
-
-
-
-
-
-
-
-
-
-
-
-typedef /* [v1_enum] */ 
-enum tagCONDITION_TYPE
-    {	CT_AND_CONDITION	= 0,
-	CT_OR_CONDITION	= ( CT_AND_CONDITION + 1 ) ,
-	CT_NOT_CONDITION	= ( CT_OR_CONDITION + 1 ) ,
-	CT_LEAF_CONDITION	= ( CT_NOT_CONDITION + 1 ) 
-    } 	CONDITION_TYPE;
-
-typedef /* [v1_enum] */ 
-enum tagCONDITION_OPERATION
-    {	COP_IMPLICIT	= 0,
-	COP_EQUAL	= ( COP_IMPLICIT + 1 ) ,
-	COP_NOTEQUAL	= ( COP_EQUAL + 1 ) ,
-	COP_LESSTHAN	= ( COP_NOTEQUAL + 1 ) ,
-	COP_GREATERTHAN	= ( COP_LESSTHAN + 1 ) ,
-	COP_LESSTHANOREQUAL	= ( COP_GREATERTHAN + 1 ) ,
-	COP_GREATERTHANOREQUAL	= ( COP_LESSTHANOREQUAL + 1 ) ,
-	COP_VALUE_STARTSWITH	= ( COP_GREATERTHANOREQUAL + 1 ) ,
-	COP_VALUE_ENDSWITH	= ( COP_VALUE_STARTSWITH + 1 ) ,
-	COP_VALUE_CONTAINS	= ( COP_VALUE_ENDSWITH + 1 ) ,
-	COP_VALUE_NOTCONTAINS	= ( COP_VALUE_CONTAINS + 1 ) ,
-	COP_DOSWILDCARDS	= ( COP_VALUE_NOTCONTAINS + 1 ) ,
-	COP_WORD_EQUAL	= ( COP_DOSWILDCARDS + 1 ) ,
-	COP_WORD_STARTSWITH	= ( COP_WORD_EQUAL + 1 ) ,
-	COP_APPLICATION_SPECIFIC	= ( COP_WORD_STARTSWITH + 1 ) 
-    } 	CONDITION_OPERATION;
-
-typedef /* [v1_enum] */ 
-enum tagSTRUCTURED_QUERY_SINGLE_OPTION
-    {	SQSO_SCHEMA	= 0,
-	SQSO_LOCALE_WORD_BREAKING	= ( SQSO_SCHEMA + 1 ) ,
-	SQSO_WORD_BREAKER	= ( SQSO_LOCALE_WORD_BREAKING + 1 ) ,
-	SQSO_NATURAL_SYNTAX	= ( SQSO_WORD_BREAKER + 1 ) ,
-	SQSO_AUTOMATIC_WILDCARD	= ( SQSO_NATURAL_SYNTAX + 1 ) ,
-	SQSO_TRACE_LEVEL	= ( SQSO_AUTOMATIC_WILDCARD + 1 ) ,
-	SQSO_LANGUAGE_KEYWORDS	= ( SQSO_TRACE_LEVEL + 1 ) 
-    } 	STRUCTURED_QUERY_SINGLE_OPTION;
-
-typedef /* [v1_enum] */ 
-enum tagSTRUCTURED_QUERY_MULTIOPTION
-    {	SQMO_VIRTUAL_PROPERTY	= 0,
-	SQMO_DEFAULT_PROPERTY	= ( SQMO_VIRTUAL_PROPERTY + 1 ) ,
-	SQMO_GENERATOR_FOR_TYPE	= ( SQMO_DEFAULT_PROPERTY + 1 ) 
-    } 	STRUCTURED_QUERY_MULTIOPTION;
-
-typedef /* [v1_enum] */ 
-enum tagSTRUCTURED_QUERY_PARSE_ERROR
-    {	SQPE_NONE	= 0,
-	SQPE_EXTRA_OPENING_PARENTHESIS	= ( SQPE_NONE + 1 ) ,
-	SQPE_EXTRA_CLOSING_PARENTHESIS	= ( SQPE_EXTRA_OPENING_PARENTHESIS + 1 ) ,
-	SQPE_IGNORED_MODIFIER	= ( SQPE_EXTRA_CLOSING_PARENTHESIS + 1 ) ,
-	SQPE_IGNORED_CONNECTOR	= ( SQPE_IGNORED_MODIFIER + 1 ) ,
-	SQPE_IGNORED_KEYWORD	= ( SQPE_IGNORED_CONNECTOR + 1 ) ,
-	SQPE_UNHANDLED	= ( SQPE_IGNORED_KEYWORD + 1 ) 
-    } 	STRUCTURED_QUERY_PARSE_ERROR;
-
-/* [v1_enum] */ 
-enum tagSTRUCTURED_QUERY_RESOLVE_OPTION
-    {	SQRO_DONT_RESOLVE_DATETIME	= 0x1,
-	SQRO_ALWAYS_ONE_INTERVAL	= 0x2,
-	SQRO_DONT_SIMPLIFY_CONDITION_TREES	= 0x4,
-	SQRO_DONT_MAP_RELATIONS	= 0x8,
-	SQRO_DONT_RESOLVE_RANGES	= 0x10,
-	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS	= 0x20,
-	SQRO_DONT_SPLIT_WORDS	= 0x40,
-	SQRO_IGNORE_PHRASE_ORDER	= 0x80
-    } ;
-typedef int STRUCTURED_QUERY_RESOLVE_OPTION;
-
-typedef /* [v1_enum] */ 
-enum tagINTERVAL_LIMIT_KIND
-    {	ILK_EXPLICIT_INCLUDED	= 0,
-	ILK_EXPLICIT_EXCLUDED	= ( ILK_EXPLICIT_INCLUDED + 1 ) ,
-	ILK_NEGATIVE_INFINITY	= ( ILK_EXPLICIT_EXCLUDED + 1 ) ,
-	ILK_POSITIVE_INFINITY	= ( ILK_NEGATIVE_INFINITY + 1 ) 
-    } 	INTERVAL_LIMIT_KIND;
-
-typedef /* [v1_enum] */ 
-enum tagQUERY_PARSER_MANAGER_OPTION
-    {	QPMO_SCHEMA_BINARY_NAME	= 0,
-	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_SCHEMA_BINARY_NAME + 1 ) ,
-	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
-	QPMO_LOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
-	QPMO_APPEND_LCID_TO_LOCALIZED_PATH	= ( QPMO_LOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
-	QPMO_LOCALIZER_SUPPORT	= ( QPMO_APPEND_LCID_TO_LOCALIZED_PATH + 1 ) 
-    } 	QUERY_PARSER_MANAGER_OPTION;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_s_ifspec;
-
-#ifndef __IQueryParser_INTERFACE_DEFINED__
-#define __IQueryParser_INTERFACE_DEFINED__
-
-/* interface IQueryParser */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IQueryParser;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")
-    IQueryParser : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Parse( 
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
-            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetOption( 
-            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetOption( 
-            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
-            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetMultiOption( 
-            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
-            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetSchemaProvider( 
-            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RestateToString( 
-            /* [in] */ __RPC__in_opt ICondition *pCondition,
-            /* [in] */ BOOL fUseEnglish,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE ParsePropertyValue( 
-            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RestatePropertyValueToString( 
-            /* [in] */ __RPC__in_opt ICondition *pCondition,
-            /* [in] */ BOOL fUseEnglish,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IQueryParserVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IQueryParser * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IQueryParser * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IQueryParser * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Parse )( 
-            IQueryParser * This,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
-            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
-            IQueryParser * This,
-            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
-            IQueryParser * This,
-            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
-            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetMultiOption )( 
-            IQueryParser * This,
-            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
-            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSchemaProvider )( 
-            IQueryParser * This,
-            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider);
-        
-        HRESULT ( STDMETHODCALLTYPE *RestateToString )( 
-            IQueryParser * This,
-            /* [in] */ __RPC__in_opt ICondition *pCondition,
-            /* [in] */ BOOL fUseEnglish,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
-        
-        HRESULT ( STDMETHODCALLTYPE *ParsePropertyValue )( 
-            IQueryParser * This,
-            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
-        
-        HRESULT ( STDMETHODCALLTYPE *RestatePropertyValueToString )( 
-            IQueryParser * This,
-            /* [in] */ __RPC__in_opt ICondition *pCondition,
-            /* [in] */ BOOL fUseEnglish,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
-        
-        END_INTERFACE
-    } IQueryParserVtbl;
-
-    interface IQueryParser
-    {
-        CONST_VTBL struct IQueryParserVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IQueryParser_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IQueryParser_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IQueryParser_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IQueryParser_Parse(This,pszInputString,pCustomProperties,ppSolution)	\
-    ( (This)->lpVtbl -> Parse(This,pszInputString,pCustomProperties,ppSolution) ) 
-
-#define IQueryParser_SetOption(This,option,pOptionValue)	\
-    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 
-
-#define IQueryParser_GetOption(This,option,pOptionValue)	\
-    ( (This)->lpVtbl -> GetOption(This,option,pOptionValue) ) 
-
-#define IQueryParser_SetMultiOption(This,option,pszOptionKey,pOptionValue)	\
-    ( (This)->lpVtbl -> SetMultiOption(This,option,pszOptionKey,pOptionValue) ) 
-
-#define IQueryParser_GetSchemaProvider(This,ppSchemaProvider)	\
-    ( (This)->lpVtbl -> GetSchemaProvider(This,ppSchemaProvider) ) 
-
-#define IQueryParser_RestateToString(This,pCondition,fUseEnglish,ppszQueryString)	\
-    ( (This)->lpVtbl -> RestateToString(This,pCondition,fUseEnglish,ppszQueryString) ) 
-
-#define IQueryParser_ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)	\
-    ( (This)->lpVtbl -> ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution) ) 
-
-#define IQueryParser_RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)	\
-    ( (This)->lpVtbl -> RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IQueryParser_INTERFACE_DEFINED__ */
-
-
-#ifndef __IConditionFactory_INTERFACE_DEFINED__
-#define __IConditionFactory_INTERFACE_DEFINED__
-
-/* interface IConditionFactory */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IConditionFactory;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")
-    IConditionFactory : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE MakeNot( 
-            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE MakeAndOr( 
-            /* [in] */ CONDITION_TYPE nodeType,
-            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE MakeLeaf( 
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
-            /* [in] */ CONDITION_OPERATION op,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
-            /* [in] */ __RPC__in const PROPVARIANT *pValue,
-            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
-            /* [in] */ BOOL expand,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Resolve( 
-            /* [in] */ 
-            __in  ICondition *pConditionTree,
-            /* [in] */ 
-            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
-            /* [ref][in] */ 
-            __in_opt  const SYSTEMTIME *pstReferenceTime,
-            /* [retval][out] */ 
-            __out  ICondition **ppResolvedConditionTree) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IConditionFactoryVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IConditionFactory * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IConditionFactory * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IConditionFactory * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
-            IConditionFactory * This,
-            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
-            IConditionFactory * This,
-            /* [in] */ CONDITION_TYPE nodeType,
-            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
-            IConditionFactory * This,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
-            /* [in] */ CONDITION_OPERATION op,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
-            /* [in] */ __RPC__in const PROPVARIANT *pValue,
-            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
-            /* [in] */ BOOL expand,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
-            IConditionFactory * This,
-            /* [in] */ 
-            __in  ICondition *pConditionTree,
-            /* [in] */ 
-            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
-            /* [ref][in] */ 
-            __in_opt  const SYSTEMTIME *pstReferenceTime,
-            /* [retval][out] */ 
-            __out  ICondition **ppResolvedConditionTree);
-        
-        END_INTERFACE
-    } IConditionFactoryVtbl;
-
-    interface IConditionFactory
-    {
-        CONST_VTBL struct IConditionFactoryVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IConditionFactory_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IConditionFactory_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IConditionFactory_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IConditionFactory_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 
-
-#define IConditionFactory_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 
-
-#define IConditionFactory_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 
-
-#define IConditionFactory_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
-    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IConditionFactory_INTERFACE_DEFINED__ */
-
-
-#ifndef __IQuerySolution_INTERFACE_DEFINED__
-#define __IQuerySolution_INTERFACE_DEFINED__
-
-/* interface IQuerySolution */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IQuerySolution;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")
-    IQuerySolution : public IConditionFactory
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetQuery( 
-            /* [out] */ 
-            __out_opt  ICondition **ppQueryNode,
-            /* [out] */ 
-            __out_opt  IEntity **ppMainType) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetErrors( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLexicalData( 
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszInputString,
-            /* [out] */ 
-            __out_opt  ITokenCollection **ppTokens,
-            /* [out] */ 
-            __out_opt  LCID *pLocale,
-            /* [out] */ 
-            __out_opt  IUnknown **ppWordBreaker) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IQuerySolutionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IQuerySolution * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IQuerySolution * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IQuerySolution * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
-            IQuerySolution * This,
-            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
-            IQuerySolution * This,
-            /* [in] */ CONDITION_TYPE nodeType,
-            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
-            /* [in] */ BOOL simplify,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
-            IQuerySolution * This,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
-            /* [in] */ CONDITION_OPERATION op,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
-            /* [in] */ __RPC__in const PROPVARIANT *pValue,
-            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
-            /* [in] */ BOOL expand,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
-            IQuerySolution * This,
-            /* [in] */ 
-            __in  ICondition *pConditionTree,
-            /* [in] */ 
-            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
-            /* [ref][in] */ 
-            __in_opt  const SYSTEMTIME *pstReferenceTime,
-            /* [retval][out] */ 
-            __out  ICondition **ppResolvedConditionTree);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
-            IQuerySolution * This,
-            /* [out] */ 
-            __out_opt  ICondition **ppQueryNode,
-            /* [out] */ 
-            __out_opt  IEntity **ppMainType);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetErrors )( 
-            IQuerySolution * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetLexicalData )( 
-            IQuerySolution * This,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszInputString,
-            /* [out] */ 
-            __out_opt  ITokenCollection **ppTokens,
-            /* [out] */ 
-            __out_opt  LCID *pLocale,
-            /* [out] */ 
-            __out_opt  IUnknown **ppWordBreaker);
-        
-        END_INTERFACE
-    } IQuerySolutionVtbl;
-
-    interface IQuerySolution
-    {
-        CONST_VTBL struct IQuerySolutionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IQuerySolution_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IQuerySolution_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IQuerySolution_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IQuerySolution_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 
-
-#define IQuerySolution_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 
-
-#define IQuerySolution_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
-    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 
-
-#define IQuerySolution_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
-    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 
-
-
-#define IQuerySolution_GetQuery(This,ppQueryNode,ppMainType)	\
-    ( (This)->lpVtbl -> GetQuery(This,ppQueryNode,ppMainType) ) 
-
-#define IQuerySolution_GetErrors(This,riid,ppParseErrors)	\
-    ( (This)->lpVtbl -> GetErrors(This,riid,ppParseErrors) ) 
-
-#define IQuerySolution_GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)	\
-    ( (This)->lpVtbl -> GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IQuerySolution_INTERFACE_DEFINED__ */
-
-
-#ifndef __ICondition_INTERFACE_DEFINED__
-#define __ICondition_INTERFACE_DEFINED__
-
-/* interface ICondition */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_ICondition;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("0FC988D4-C935-4b97-A973-46282EA175C8")
-    ICondition : public IPersistStream
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
-            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetSubConditions( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetComparisonInfo( 
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszPropertyName,
-            /* [out] */ 
-            __out_opt  CONDITION_OPERATION *pOperation,
-            /* [out] */ 
-            __out_opt  PROPVARIANT *pValue) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetValueType( 
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetValueNormalization( 
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputTerms( 
-            /* [out] */ 
-            __out_opt  IRichChunk **ppPropertyTerm,
-            /* [out] */ 
-            __out_opt  IRichChunk **ppOperationTerm,
-            /* [out] */ 
-            __out_opt  IRichChunk **ppValueTerm) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Clone( 
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IConditionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ICondition * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ICondition * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ICondition * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
-            ICondition * This,
-            /* [out] */ __RPC__out CLSID *pClassID);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
-            ICondition * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Load )( 
-            ICondition * This,
-            /* [unique][in] */ __RPC__in_opt IStream *pStm);
-        
-        HRESULT ( STDMETHODCALLTYPE *Save )( 
-            ICondition * This,
-            /* [unique][in] */ __RPC__in_opt IStream *pStm,
-            /* [in] */ BOOL fClearDirty);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
-            ICondition * This,
-            /* [out] */ __RPC__out ULARGE_INTEGER *pcbSize);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
-            ICondition * This,
-            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetSubConditions )( 
-            ICondition * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetComparisonInfo )( 
-            ICondition * This,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszPropertyName,
-            /* [out] */ 
-            __out_opt  CONDITION_OPERATION *pOperation,
-            /* [out] */ 
-            __out_opt  PROPVARIANT *pValue);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValueType )( 
-            ICondition * This,
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValueNormalization )( 
-            ICondition * This,
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetInputTerms )( 
-            ICondition * This,
-            /* [out] */ 
-            __out_opt  IRichChunk **ppPropertyTerm,
-            /* [out] */ 
-            __out_opt  IRichChunk **ppOperationTerm,
-            /* [out] */ 
-            __out_opt  IRichChunk **ppValueTerm);
-        
-        HRESULT ( STDMETHODCALLTYPE *Clone )( 
-            ICondition * This,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc);
-        
-        END_INTERFACE
-    } IConditionVtbl;
-
-    interface ICondition
-    {
-        CONST_VTBL struct IConditionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ICondition_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ICondition_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ICondition_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ICondition_GetClassID(This,pClassID)	\
-    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 
-
-
-#define ICondition_IsDirty(This)	\
-    ( (This)->lpVtbl -> IsDirty(This) ) 
-
-#define ICondition_Load(This,pStm)	\
-    ( (This)->lpVtbl -> Load(This,pStm) ) 
-
-#define ICondition_Save(This,pStm,fClearDirty)	\
-    ( (This)->lpVtbl -> Save(This,pStm,fClearDirty) ) 
-
-#define ICondition_GetSizeMax(This,pcbSize)	\
-    ( (This)->lpVtbl -> GetSizeMax(This,pcbSize) ) 
-
-
-#define ICondition_GetConditionType(This,pNodeType)	\
-    ( (This)->lpVtbl -> GetConditionType(This,pNodeType) ) 
-
-#define ICondition_GetSubConditions(This,riid,ppv)	\
-    ( (This)->lpVtbl -> GetSubConditions(This,riid,ppv) ) 
-
-#define ICondition_GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)	\
-    ( (This)->lpVtbl -> GetComparisonInfo(This,ppszPropertyName,pOperation,pValue) ) 
-
-#define ICondition_GetValueType(This,ppszValueTypeName)	\
-    ( (This)->lpVtbl -> GetValueType(This,ppszValueTypeName) ) 
-
-#define ICondition_GetValueNormalization(This,ppszNormalization)	\
-    ( (This)->lpVtbl -> GetValueNormalization(This,ppszNormalization) ) 
-
-#define ICondition_GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)	\
-    ( (This)->lpVtbl -> GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm) ) 
-
-#define ICondition_Clone(This,ppc)	\
-    ( (This)->lpVtbl -> Clone(This,ppc) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ICondition_INTERFACE_DEFINED__ */
-
-
-#ifndef __IConditionGenerator_INTERFACE_DEFINED__
-#define __IConditionGenerator_INTERFACE_DEFINED__
-
-/* interface IConditionGenerator */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IConditionGenerator;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("92D2CC58-4386-45a3-B98C-7E0CE64A4117")
-    IConditionGenerator : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Initialize( 
-            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RecognizeNamedEntities( 
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ LCID lcid,
-            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
-            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GenerateForLeaf( 
-            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
-            /* [in] */ CONDITION_OPERATION op,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
-            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
-            /* [in] */ BOOL automaticWildcard,
-            /* [out] */ __RPC__out BOOL *pNoStringQuery,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
-            /* [unique][in] */ LPCWSTR pszValueType,
-            /* [in] */ const PROPVARIANT *ppropvar,
-            /* [in] */ BOOL fUseEnglish,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IConditionGeneratorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IConditionGenerator * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IConditionGenerator * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IConditionGenerator * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
-            IConditionGenerator * This,
-            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider);
-        
-        HRESULT ( STDMETHODCALLTYPE *RecognizeNamedEntities )( 
-            IConditionGenerator * This,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ LCID lcid,
-            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
-            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities);
-        
-        HRESULT ( STDMETHODCALLTYPE *GenerateForLeaf )( 
-            IConditionGenerator * This,
-            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
-            /* [in] */ CONDITION_OPERATION op,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
-            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
-            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
-            /* [in] */ BOOL automaticWildcard,
-            /* [out] */ __RPC__out BOOL *pNoStringQuery,
-            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
-            IConditionGenerator * This,
-            /* [unique][in] */ LPCWSTR pszValueType,
-            /* [in] */ const PROPVARIANT *ppropvar,
-            /* [in] */ BOOL fUseEnglish,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase);
-        
-        END_INTERFACE
-    } IConditionGeneratorVtbl;
-
-    interface IConditionGenerator
-    {
-        CONST_VTBL struct IConditionGeneratorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IConditionGenerator_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IConditionGenerator_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IConditionGenerator_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IConditionGenerator_Initialize(This,pSchemaProvider)	\
-    ( (This)->lpVtbl -> Initialize(This,pSchemaProvider) ) 
-
-#define IConditionGenerator_RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)	\
-    ( (This)->lpVtbl -> RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities) ) 
-
-#define IConditionGenerator_GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)	\
-    ( (This)->lpVtbl -> GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression) ) 
-
-#define IConditionGenerator_DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)	\
-    ( (This)->lpVtbl -> DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IConditionGenerator_INTERFACE_DEFINED__ */
-
-
-#ifndef __IRichChunk_INTERFACE_DEFINED__
-#define __IRichChunk_INTERFACE_DEFINED__
-
-/* interface IRichChunk */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IRichChunk;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("4FDEF69C-DBC9-454e-9910-B34F3C64B510")
-    IRichChunk : public IUnknown
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
-            /* [out] */ 
-            __out_opt  ULONG *pFirstPos,
-            /* [out] */ 
-            __out_opt  ULONG *pLength,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppsz,
-            /* [out] */ 
-            __out_opt  PROPVARIANT *pValue) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IRichChunkVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IRichChunk * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IRichChunk * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IRichChunk * This);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
-            IRichChunk * This,
-            /* [out] */ 
-            __out_opt  ULONG *pFirstPos,
-            /* [out] */ 
-            __out_opt  ULONG *pLength,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppsz,
-            /* [out] */ 
-            __out_opt  PROPVARIANT *pValue);
-        
-        END_INTERFACE
-    } IRichChunkVtbl;
-
-    interface IRichChunk
-    {
-        CONST_VTBL struct IRichChunkVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IRichChunk_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IRichChunk_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IRichChunk_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IRichChunk_GetData(This,pFirstPos,pLength,ppsz,pValue)	\
-    ( (This)->lpVtbl -> GetData(This,pFirstPos,pLength,ppsz,pValue) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IRichChunk_INTERFACE_DEFINED__ */
-
-
-#ifndef __IInterval_INTERFACE_DEFINED__
-#define __IInterval_INTERFACE_DEFINED__
-
-/* interface IInterval */
-/* [unique][uuid][object] */ 
-
-
-EXTERN_C const IID IID_IInterval;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")
-    IInterval : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetLimits( 
-            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
-            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IIntervalVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IInterval * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IInterval * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IInterval * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetLimits )( 
-            IInterval * This,
-            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
-            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
-            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper);
-        
-        END_INTERFACE
-    } IIntervalVtbl;
-
-    interface IInterval
-    {
-        CONST_VTBL struct IIntervalVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IInterval_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IInterval_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IInterval_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IInterval_GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)	\
-    ( (This)->lpVtbl -> GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IInterval_INTERFACE_DEFINED__ */
-
-
-#ifndef __IMetaData_INTERFACE_DEFINED__
-#define __IMetaData_INTERFACE_DEFINED__
-
-/* interface IMetaData */
-/* [unique][uuid][object][helpstring] */ 
-
-
-EXTERN_C const IID IID_IMetaData;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("780102B0-C43B-4876-BC7B-5E9BA5C88794")
-    IMetaData : public IUnknown
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszKey,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszValue) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IMetaDataVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IMetaData * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IMetaData * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IMetaData * This);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
-            IMetaData * This,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszKey,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppszValue);
-        
-        END_INTERFACE
-    } IMetaDataVtbl;
-
-    interface IMetaData
-    {
-        CONST_VTBL struct IMetaDataVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IMetaData_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IMetaData_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IMetaData_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IMetaData_GetData(This,ppszKey,ppszValue)	\
-    ( (This)->lpVtbl -> GetData(This,ppszKey,ppszValue) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IMetaData_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_structuredquery_0000_0008 */
-/* [local] */ 
-
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_s_ifspec;
-
-#ifndef __IEntity_INTERFACE_DEFINED__
-#define __IEntity_INTERFACE_DEFINED__
-
-/* interface IEntity */
-/* [unique][object][uuid][helpstring] */ 
-
-
-EXTERN_C const IID IID_IEntity;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")
-    IEntity : public IUnknown
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszName) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Base( 
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Relationships( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetRelationship( 
-            /* [in] */ __RPC__in LPCWSTR pszRelationName,
-            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE MetaData( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE NamedEntities( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetNamedEntity( 
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IEntityVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IEntity * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IEntity * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IEntity * This);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
-            IEntity * This,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *Base )( 
-            IEntity * This,
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity);
-        
-        HRESULT ( STDMETHODCALLTYPE *Relationships )( 
-            IEntity * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetRelationship )( 
-            IEntity * This,
-            /* [in] */ __RPC__in LPCWSTR pszRelationName,
-            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship);
-        
-        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
-            IEntity * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
-        
-        HRESULT ( STDMETHODCALLTYPE *NamedEntities )( 
-            IEntity * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetNamedEntity )( 
-            IEntity * This,
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
-            IEntity * This,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase);
-        
-        END_INTERFACE
-    } IEntityVtbl;
-
-    interface IEntity
-    {
-        CONST_VTBL struct IEntityVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IEntity_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IEntity_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IEntity_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IEntity_Name(This,ppszName)	\
-    ( (This)->lpVtbl -> Name(This,ppszName) ) 
-
-#define IEntity_Base(This,pBaseEntity)	\
-    ( (This)->lpVtbl -> Base(This,pBaseEntity) ) 
-
-#define IEntity_Relationships(This,riid,pRelationships)	\
-    ( (This)->lpVtbl -> Relationships(This,riid,pRelationships) ) 
-
-#define IEntity_GetRelationship(This,pszRelationName,pRelationship)	\
-    ( (This)->lpVtbl -> GetRelationship(This,pszRelationName,pRelationship) ) 
-
-#define IEntity_MetaData(This,riid,pMetaData)	\
-    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
-
-#define IEntity_NamedEntities(This,riid,pNamedEntities)	\
-    ( (This)->lpVtbl -> NamedEntities(This,riid,pNamedEntities) ) 
-
-#define IEntity_GetNamedEntity(This,pszValue,ppNamedEntity)	\
-    ( (This)->lpVtbl -> GetNamedEntity(This,pszValue,ppNamedEntity) ) 
-
-#define IEntity_DefaultPhrase(This,ppszPhrase)	\
-    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IEntity_INTERFACE_DEFINED__ */
-
-
-#ifndef __IRelationship_INTERFACE_DEFINED__
-#define __IRelationship_INTERFACE_DEFINED__
-
-/* interface IRelationship */
-/* [unique][object][uuid][helpstring] */ 
-
-
-EXTERN_C const IID IID_IRelationship;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("2769280B-5108-498c-9C7F-A51239B63147")
-    IRelationship : public IUnknown
-    {
-    public:
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszName) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE IsReal( 
-            /* [retval][out] */ __RPC__out BOOL *pIsReal) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Destination( 
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE MetaData( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IRelationshipVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IRelationship * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IRelationship * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IRelationship * This);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
-            IRelationship * This,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszName);
-        
-        HRESULT ( STDMETHODCALLTYPE *IsReal )( 
-            IRelationship * This,
-            /* [retval][out] */ __RPC__out BOOL *pIsReal);
-        
-        HRESULT ( STDMETHODCALLTYPE *Destination )( 
-            IRelationship * This,
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity);
-        
-        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
-            IRelationship * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
-            IRelationship * This,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase);
-        
-        END_INTERFACE
-    } IRelationshipVtbl;
-
-    interface IRelationship
-    {
-        CONST_VTBL struct IRelationshipVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IRelationship_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IRelationship_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IRelationship_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IRelationship_Name(This,ppszName)	\
-    ( (This)->lpVtbl -> Name(This,ppszName) ) 
-
-#define IRelationship_IsReal(This,pIsReal)	\
-    ( (This)->lpVtbl -> IsReal(This,pIsReal) ) 
-
-#define IRelationship_Destination(This,pDestinationEntity)	\
-    ( (This)->lpVtbl -> Destination(This,pDestinationEntity) ) 
-
-#define IRelationship_MetaData(This,riid,pMetaData)	\
-    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
-
-#define IRelationship_DefaultPhrase(This,ppszPhrase)	\
-    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IRelationship_INTERFACE_DEFINED__ */
-
-
-#ifndef __INamedEntity_INTERFACE_DEFINED__
-#define __INamedEntity_INTERFACE_DEFINED__
-
-/* interface INamedEntity */
-/* [unique][uuid][object][helpstring] */ 
-
-
-EXTERN_C const IID IID_INamedEntity;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")
-    INamedEntity : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE GetValue( 
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct INamedEntityVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            INamedEntity * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            INamedEntity * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            INamedEntity * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
-            INamedEntity * This,
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
-            INamedEntity * This,
-            /* [retval][out] */ 
-            __deref_opt_out  LPWSTR *ppszPhrase);
-        
-        END_INTERFACE
-    } INamedEntityVtbl;
-
-    interface INamedEntity
-    {
-        CONST_VTBL struct INamedEntityVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define INamedEntity_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define INamedEntity_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define INamedEntity_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define INamedEntity_GetValue(This,ppszValue)	\
-    ( (This)->lpVtbl -> GetValue(This,ppszValue) ) 
-
-#define INamedEntity_DefaultPhrase(This,ppszPhrase)	\
-    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __INamedEntity_INTERFACE_DEFINED__ */
-
-
-#ifndef __ISchemaProvider_INTERFACE_DEFINED__
-#define __ISchemaProvider_INTERFACE_DEFINED__
-
-/* interface ISchemaProvider */
-/* [unique][object][uuid][helpstring] */ 
-
-
-EXTERN_C const IID IID_ISchemaProvider;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")
-    ISchemaProvider : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Entities( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE RootEntity( 
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE GetEntity( 
-            /* [in] */ __RPC__in LPCWSTR pszEntityName,
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE MetaData( 
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE Localize( 
-            /* [in] */ LCID lcid,
-            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SaveBinary( 
-            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE LookupAuthoredNamedEntity( 
-            /* [in] */ __RPC__in_opt IEntity *pEntity,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
-            /* [in] */ ULONG cTokensBegin,
-            /* [out] */ __RPC__out ULONG *pcTokensLength,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ISchemaProviderVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ISchemaProvider * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ISchemaProvider * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Entities )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities);
-        
-        HRESULT ( STDMETHODCALLTYPE *RootEntity )( 
-            ISchemaProvider * This,
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity);
-        
-        HRESULT ( STDMETHODCALLTYPE *GetEntity )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in LPCWSTR pszEntityName,
-            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity);
-        
-        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
-        
-        HRESULT ( STDMETHODCALLTYPE *Localize )( 
-            ISchemaProvider * This,
-            /* [in] */ LCID lcid,
-            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport);
-        
-        HRESULT ( STDMETHODCALLTYPE *SaveBinary )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath);
-        
-        HRESULT ( STDMETHODCALLTYPE *LookupAuthoredNamedEntity )( 
-            ISchemaProvider * This,
-            /* [in] */ __RPC__in_opt IEntity *pEntity,
-            /* [in] */ __RPC__in LPCWSTR pszInputString,
-            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
-            /* [in] */ ULONG cTokensBegin,
-            /* [out] */ __RPC__out ULONG *pcTokensLength,
-            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
-        
-        END_INTERFACE
-    } ISchemaProviderVtbl;
-
-    interface ISchemaProvider
-    {
-        CONST_VTBL struct ISchemaProviderVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ISchemaProvider_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ISchemaProvider_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ISchemaProvider_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ISchemaProvider_Entities(This,riid,pEntities)	\
-    ( (This)->lpVtbl -> Entities(This,riid,pEntities) ) 
-
-#define ISchemaProvider_RootEntity(This,pRootEntity)	\
-    ( (This)->lpVtbl -> RootEntity(This,pRootEntity) ) 
-
-#define ISchemaProvider_GetEntity(This,pszEntityName,pEntity)	\
-    ( (This)->lpVtbl -> GetEntity(This,pszEntityName,pEntity) ) 
-
-#define ISchemaProvider_MetaData(This,riid,pMetaData)	\
-    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
-
-#define ISchemaProvider_Localize(This,lcid,pSchemaLocalizerSupport)	\
-    ( (This)->lpVtbl -> Localize(This,lcid,pSchemaLocalizerSupport) ) 
-
-#define ISchemaProvider_SaveBinary(This,pszSchemaBinaryPath)	\
-    ( (This)->lpVtbl -> SaveBinary(This,pszSchemaBinaryPath) ) 
-
-#define ISchemaProvider_LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)	\
-    ( (This)->lpVtbl -> LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ISchemaProvider_INTERFACE_DEFINED__ */
-
-
-#ifndef __ITokenCollection_INTERFACE_DEFINED__
-#define __ITokenCollection_INTERFACE_DEFINED__
-
-/* interface ITokenCollection */
-/* [unique][object][uuid][helpstring] */ 
-
-
-EXTERN_C const IID IID_ITokenCollection;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("22D8B4F2-F577-4adb-A335-C2AE88416FAB")
-    ITokenCollection : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE NumberOfTokens( 
-            __RPC__in ULONG *pCount) = 0;
-        
-        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToken( 
-            /* [in] */ ULONG i,
-            /* [out] */ 
-            __out_opt  ULONG *pBegin,
-            /* [out] */ 
-            __out_opt  ULONG *pLength,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppsz) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ITokenCollectionVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ITokenCollection * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ITokenCollection * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ITokenCollection * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *NumberOfTokens )( 
-            ITokenCollection * This,
-            __RPC__in ULONG *pCount);
-        
-        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetToken )( 
-            ITokenCollection * This,
-            /* [in] */ ULONG i,
-            /* [out] */ 
-            __out_opt  ULONG *pBegin,
-            /* [out] */ 
-            __out_opt  ULONG *pLength,
-            /* [out] */ 
-            __deref_opt_out  LPWSTR *ppsz);
-        
-        END_INTERFACE
-    } ITokenCollectionVtbl;
-
-    interface ITokenCollection
-    {
-        CONST_VTBL struct ITokenCollectionVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ITokenCollection_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ITokenCollection_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ITokenCollection_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ITokenCollection_NumberOfTokens(This,pCount)	\
-    ( (This)->lpVtbl -> NumberOfTokens(This,pCount) ) 
-
-#define ITokenCollection_GetToken(This,i,pBegin,pLength,ppsz)	\
-    ( (This)->lpVtbl -> GetToken(This,i,pBegin,pLength,ppsz) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ITokenCollection_INTERFACE_DEFINED__ */
-
-
-/* interface __MIDL_itf_structuredquery_0000_0013 */
-/* [local] */ 
-
-typedef /* [public][public][v1_enum] */ 
-enum __MIDL___MIDL_itf_structuredquery_0000_0013_0001
-    {	NEC_LOW	= 0,
-	NEC_MEDIUM	= ( NEC_LOW + 1 ) ,
-	NEC_HIGH	= ( NEC_MEDIUM + 1 ) 
-    } 	NAMED_ENTITY_CERTAINTY;
-
-
-
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_c_ifspec;
-extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_s_ifspec;
-
-#ifndef __INamedEntityCollector_INTERFACE_DEFINED__
-#define __INamedEntityCollector_INTERFACE_DEFINED__
-
-/* interface INamedEntityCollector */
-/* [unique][object][uuid][helpstring] */ 
-
-
-EXTERN_C const IID IID_INamedEntityCollector;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")
-    INamedEntityCollector : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Add( 
-            /* [in] */ ULONG beginSpan,
-            /* [in] */ ULONG endSpan,
-            /* [in] */ ULONG beginActual,
-            /* [in] */ ULONG endActual,
-            /* [in] */ __RPC__in_opt IEntity *pType,
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [in] */ NAMED_ENTITY_CERTAINTY certainty) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct INamedEntityCollectorVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            INamedEntityCollector * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            INamedEntityCollector * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            INamedEntityCollector * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Add )( 
-            INamedEntityCollector * This,
-            /* [in] */ ULONG beginSpan,
-            /* [in] */ ULONG endSpan,
-            /* [in] */ ULONG beginActual,
-            /* [in] */ ULONG endActual,
-            /* [in] */ __RPC__in_opt IEntity *pType,
-            /* [in] */ __RPC__in LPCWSTR pszValue,
-            /* [in] */ NAMED_ENTITY_CERTAINTY certainty);
-        
-        END_INTERFACE
-    } INamedEntityCollectorVtbl;
-
-    interface INamedEntityCollector
-    {
-        CONST_VTBL struct INamedEntityCollectorVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define INamedEntityCollector_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define INamedEntityCollector_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define INamedEntityCollector_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define INamedEntityCollector_Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)	\
-    ( (This)->lpVtbl -> Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __INamedEntityCollector_INTERFACE_DEFINED__ */
-
-
-#ifndef __ISchemaLocalizerSupport_INTERFACE_DEFINED__
-#define __ISchemaLocalizerSupport_INTERFACE_DEFINED__
-
-/* interface ISchemaLocalizerSupport */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_ISchemaLocalizerSupport;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")
-    ISchemaLocalizerSupport : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE Localize( 
-            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct ISchemaLocalizerSupportVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            ISchemaLocalizerSupport * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            ISchemaLocalizerSupport * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            ISchemaLocalizerSupport * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *Localize )( 
-            ISchemaLocalizerSupport * This,
-            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
-            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString);
-        
-        END_INTERFACE
-    } ISchemaLocalizerSupportVtbl;
-
-    interface ISchemaLocalizerSupport
-    {
-        CONST_VTBL struct ISchemaLocalizerSupportVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define ISchemaLocalizerSupport_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define ISchemaLocalizerSupport_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define ISchemaLocalizerSupport_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define ISchemaLocalizerSupport_Localize(This,pszGlobalString,ppszLocalString)	\
-    ( (This)->lpVtbl -> Localize(This,pszGlobalString,ppszLocalString) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __ISchemaLocalizerSupport_INTERFACE_DEFINED__ */
-
-
-#ifndef __IQueryParserManager_INTERFACE_DEFINED__
-#define __IQueryParserManager_INTERFACE_DEFINED__
-
-/* interface IQueryParserManager */
-/* [unique][object][uuid] */ 
-
-
-EXTERN_C const IID IID_IQueryParserManager;
-
-#if defined(__cplusplus) && !defined(CINTERFACE)
-    
-    MIDL_INTERFACE("A879E3C4-AF77-44fb-8F37-EBD1487CF920")
-    IQueryParserManager : public IUnknown
-    {
-    public:
-        virtual HRESULT STDMETHODCALLTYPE CreateLoadedParser( 
-            /* [in] */ __RPC__in LPCWSTR pszCatalog,
-            /* [in] */ LANGID langidForKeywords,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE InitializeOptions( 
-            /* [in] */ BOOL fUnderstandNQS,
-            /* [in] */ BOOL fAutoWildCard,
-            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser) = 0;
-        
-        virtual HRESULT STDMETHODCALLTYPE SetOption( 
-            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
-        
-    };
-    
-#else 	/* C style interface */
-
-    typedef struct IQueryParserManagerVtbl
-    {
-        BEGIN_INTERFACE
-        
-        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
-            IQueryParserManager * This,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][out] */ 
-            __RPC__deref_out  void **ppvObject);
-        
-        ULONG ( STDMETHODCALLTYPE *AddRef )( 
-            IQueryParserManager * This);
-        
-        ULONG ( STDMETHODCALLTYPE *Release )( 
-            IQueryParserManager * This);
-        
-        HRESULT ( STDMETHODCALLTYPE *CreateLoadedParser )( 
-            IQueryParserManager * This,
-            /* [in] */ __RPC__in LPCWSTR pszCatalog,
-            /* [in] */ LANGID langidForKeywords,
-            /* [in] */ __RPC__in REFIID riid,
-            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser);
-        
-        HRESULT ( STDMETHODCALLTYPE *InitializeOptions )( 
-            IQueryParserManager * This,
-            /* [in] */ BOOL fUnderstandNQS,
-            /* [in] */ BOOL fAutoWildCard,
-            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser);
-        
-        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
-            IQueryParserManager * This,
-            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
-            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
-        
-        END_INTERFACE
-    } IQueryParserManagerVtbl;
-
-    interface IQueryParserManager
-    {
-        CONST_VTBL struct IQueryParserManagerVtbl *lpVtbl;
-    };
-
-    
-
-#ifdef COBJMACROS
-
-
-#define IQueryParserManager_QueryInterface(This,riid,ppvObject)	\
-    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
-
-#define IQueryParserManager_AddRef(This)	\
-    ( (This)->lpVtbl -> AddRef(This) ) 
-
-#define IQueryParserManager_Release(This)	\
-    ( (This)->lpVtbl -> Release(This) ) 
-
-
-#define IQueryParserManager_CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)	\
-    ( (This)->lpVtbl -> CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser) ) 
-
-#define IQueryParserManager_InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)	\
-    ( (This)->lpVtbl -> InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser) ) 
-
-#define IQueryParserManager_SetOption(This,option,pOptionValue)	\
-    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 
-
-#endif /* COBJMACROS */
-
-
-#endif 	/* C style interface */
-
-
-
-
-#endif 	/* __IQueryParserManager_INTERFACE_DEFINED__ */
-
-
-
-#ifndef __StructuredQuery1_LIBRARY_DEFINED__
-#define __StructuredQuery1_LIBRARY_DEFINED__
-
-/* library StructuredQuery1 */
-/* [version][uuid] */ 
-
-
-EXTERN_C const IID LIBID_StructuredQuery1;
-
-EXTERN_C const CLSID CLSID_QueryParser;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")
-QueryParser;
-#endif
-
-EXTERN_C const CLSID CLSID_NegationCondition;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")
-NegationCondition;
-#endif
-
-EXTERN_C const CLSID CLSID_CompoundCondition;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("116F8D13-101E-4fa5-84D4-FF8279381935")
-CompoundCondition;
-#endif
-
-EXTERN_C const CLSID CLSID_LeafCondition;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")
-LeafCondition;
-#endif
-
-EXTERN_C const CLSID CLSID_ConditionFactory;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")
-ConditionFactory;
-#endif
-
-EXTERN_C const CLSID CLSID_Interval;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("D957171F-4BF9-4de2-BCD5-C70A7CA55836")
-Interval;
-#endif
-
-EXTERN_C const CLSID CLSID_QueryParserManager;
-
-#ifdef __cplusplus
-
-class DECLSPEC_UUID("5088B39A-29B4-4d9d-8245-4EE289222F66")
-QueryParserManager;
-#endif
-#endif /* __StructuredQuery1_LIBRARY_DEFINED__ */
-
-/* Additional Prototypes for ALL interfaces */
-
-unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
-unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
-void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
-
-unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
-void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 
-
-/* end of Additional Prototypes */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-
-
+
+
+/* this ALWAYS GENERATED file contains the definitions for the interfaces */
+
+
+ /* File created by MIDL compiler version 7.00.0499 */
+/* Compiler settings for structuredquery.idl:
+    Oicf, W1, Zp8, env=Win32 (32b run)
+    protocol : dce , ms_ext, c_ext, robust
+    error checks: allocation ref bounds_check enum stub_data 
+    VC __declspec() decoration level: 
+         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
+         DECLSPEC_UUID(), MIDL_INTERFACE()
+*/
+//@@MIDL_FILE_HEADING(  )
+
+#pragma warning( disable: 4049 )  /* more than 64k source lines */
+
+
+/* verify that the <rpcndr.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+/* verify that the <rpcsal.h> version is high enough to compile this file*/
+#ifndef __REQUIRED_RPCSAL_H_VERSION__
+#define __REQUIRED_RPCSAL_H_VERSION__ 100
+#endif
+
+#include "rpc.h"
+#include "rpcndr.h"
+
+#ifndef __RPCNDR_H_VERSION__
+#error this stub requires an updated version of <rpcndr.h>
+#endif // __RPCNDR_H_VERSION__
+
+#ifndef COM_NO_WINDOWS_H
+#include "windows.h"
+#include "ole2.h"
+#endif /*COM_NO_WINDOWS_H*/
+
+#ifndef __structuredquery_h__
+#define __structuredquery_h__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+#pragma once
+#endif
+
+/* Forward Declarations */ 
+
+#ifndef __IQueryParser_FWD_DEFINED__
+#define __IQueryParser_FWD_DEFINED__
+typedef interface IQueryParser IQueryParser;
+#endif 	/* __IQueryParser_FWD_DEFINED__ */
+
+
+#ifndef __IConditionFactory_FWD_DEFINED__
+#define __IConditionFactory_FWD_DEFINED__
+typedef interface IConditionFactory IConditionFactory;
+#endif 	/* __IConditionFactory_FWD_DEFINED__ */
+
+
+#ifndef __IQuerySolution_FWD_DEFINED__
+#define __IQuerySolution_FWD_DEFINED__
+typedef interface IQuerySolution IQuerySolution;
+#endif 	/* __IQuerySolution_FWD_DEFINED__ */
+
+
+#ifndef __ICondition_FWD_DEFINED__
+#define __ICondition_FWD_DEFINED__
+typedef interface ICondition ICondition;
+#endif 	/* __ICondition_FWD_DEFINED__ */
+
+
+#ifndef __IConditionGenerator_FWD_DEFINED__
+#define __IConditionGenerator_FWD_DEFINED__
+typedef interface IConditionGenerator IConditionGenerator;
+#endif 	/* __IConditionGenerator_FWD_DEFINED__ */
+
+
+#ifndef __IRichChunk_FWD_DEFINED__
+#define __IRichChunk_FWD_DEFINED__
+typedef interface IRichChunk IRichChunk;
+#endif 	/* __IRichChunk_FWD_DEFINED__ */
+
+
+#ifndef __IInterval_FWD_DEFINED__
+#define __IInterval_FWD_DEFINED__
+typedef interface IInterval IInterval;
+#endif 	/* __IInterval_FWD_DEFINED__ */
+
+
+#ifndef __IMetaData_FWD_DEFINED__
+#define __IMetaData_FWD_DEFINED__
+typedef interface IMetaData IMetaData;
+#endif 	/* __IMetaData_FWD_DEFINED__ */
+
+
+#ifndef __IEntity_FWD_DEFINED__
+#define __IEntity_FWD_DEFINED__
+typedef interface IEntity IEntity;
+#endif 	/* __IEntity_FWD_DEFINED__ */
+
+
+#ifndef __IRelationship_FWD_DEFINED__
+#define __IRelationship_FWD_DEFINED__
+typedef interface IRelationship IRelationship;
+#endif 	/* __IRelationship_FWD_DEFINED__ */
+
+
+#ifndef __INamedEntity_FWD_DEFINED__
+#define __INamedEntity_FWD_DEFINED__
+typedef interface INamedEntity INamedEntity;
+#endif 	/* __INamedEntity_FWD_DEFINED__ */
+
+
+#ifndef __ISchemaProvider_FWD_DEFINED__
+#define __ISchemaProvider_FWD_DEFINED__
+typedef interface ISchemaProvider ISchemaProvider;
+#endif 	/* __ISchemaProvider_FWD_DEFINED__ */
+
+
+#ifndef __ITokenCollection_FWD_DEFINED__
+#define __ITokenCollection_FWD_DEFINED__
+typedef interface ITokenCollection ITokenCollection;
+#endif 	/* __ITokenCollection_FWD_DEFINED__ */
+
+
+#ifndef __INamedEntityCollector_FWD_DEFINED__
+#define __INamedEntityCollector_FWD_DEFINED__
+typedef interface INamedEntityCollector INamedEntityCollector;
+#endif 	/* __INamedEntityCollector_FWD_DEFINED__ */
+
+
+#ifndef __ISchemaLocalizerSupport_FWD_DEFINED__
+#define __ISchemaLocalizerSupport_FWD_DEFINED__
+typedef interface ISchemaLocalizerSupport ISchemaLocalizerSupport;
+#endif 	/* __ISchemaLocalizerSupport_FWD_DEFINED__ */
+
+
+#ifndef __IQueryParserManager_FWD_DEFINED__
+#define __IQueryParserManager_FWD_DEFINED__
+typedef interface IQueryParserManager IQueryParserManager;
+#endif 	/* __IQueryParserManager_FWD_DEFINED__ */
+
+
+#ifndef __QueryParser_FWD_DEFINED__
+#define __QueryParser_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class QueryParser QueryParser;
+#else
+typedef struct QueryParser QueryParser;
+#endif /* __cplusplus */
+
+#endif 	/* __QueryParser_FWD_DEFINED__ */
+
+
+#ifndef __NegationCondition_FWD_DEFINED__
+#define __NegationCondition_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class NegationCondition NegationCondition;
+#else
+typedef struct NegationCondition NegationCondition;
+#endif /* __cplusplus */
+
+#endif 	/* __NegationCondition_FWD_DEFINED__ */
+
+
+#ifndef __CompoundCondition_FWD_DEFINED__
+#define __CompoundCondition_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class CompoundCondition CompoundCondition;
+#else
+typedef struct CompoundCondition CompoundCondition;
+#endif /* __cplusplus */
+
+#endif 	/* __CompoundCondition_FWD_DEFINED__ */
+
+
+#ifndef __LeafCondition_FWD_DEFINED__
+#define __LeafCondition_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class LeafCondition LeafCondition;
+#else
+typedef struct LeafCondition LeafCondition;
+#endif /* __cplusplus */
+
+#endif 	/* __LeafCondition_FWD_DEFINED__ */
+
+
+#ifndef __ConditionFactory_FWD_DEFINED__
+#define __ConditionFactory_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class ConditionFactory ConditionFactory;
+#else
+typedef struct ConditionFactory ConditionFactory;
+#endif /* __cplusplus */
+
+#endif 	/* __ConditionFactory_FWD_DEFINED__ */
+
+
+#ifndef __Interval_FWD_DEFINED__
+#define __Interval_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class Interval Interval;
+#else
+typedef struct Interval Interval;
+#endif /* __cplusplus */
+
+#endif 	/* __Interval_FWD_DEFINED__ */
+
+
+#ifndef __QueryParserManager_FWD_DEFINED__
+#define __QueryParserManager_FWD_DEFINED__
+
+#ifdef __cplusplus
+typedef class QueryParserManager QueryParserManager;
+#else
+typedef struct QueryParserManager QueryParserManager;
+#endif /* __cplusplus */
+
+#endif 	/* __QueryParserManager_FWD_DEFINED__ */
+
+
+/* header files for imported files */
+#include "oaidl.h"
+#include "ocidl.h"
+#include "propidl.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif 
+
+
+/* interface __MIDL_itf_structuredquery_0000_0000 */
+/* [local] */ 
+
+
+
+
+
+
+
+
+
+
+
+typedef /* [v1_enum] */ 
+enum tagCONDITION_TYPE
+    {	CT_AND_CONDITION	= 0,
+	CT_OR_CONDITION	= ( CT_AND_CONDITION + 1 ) ,
+	CT_NOT_CONDITION	= ( CT_OR_CONDITION + 1 ) ,
+	CT_LEAF_CONDITION	= ( CT_NOT_CONDITION + 1 ) 
+    } 	CONDITION_TYPE;
+
+typedef /* [v1_enum] */ 
+enum tagCONDITION_OPERATION
+    {	COP_IMPLICIT	= 0,
+	COP_EQUAL	= ( COP_IMPLICIT + 1 ) ,
+	COP_NOTEQUAL	= ( COP_EQUAL + 1 ) ,
+	COP_LESSTHAN	= ( COP_NOTEQUAL + 1 ) ,
+	COP_GREATERTHAN	= ( COP_LESSTHAN + 1 ) ,
+	COP_LESSTHANOREQUAL	= ( COP_GREATERTHAN + 1 ) ,
+	COP_GREATERTHANOREQUAL	= ( COP_LESSTHANOREQUAL + 1 ) ,
+	COP_VALUE_STARTSWITH	= ( COP_GREATERTHANOREQUAL + 1 ) ,
+	COP_VALUE_ENDSWITH	= ( COP_VALUE_STARTSWITH + 1 ) ,
+	COP_VALUE_CONTAINS	= ( COP_VALUE_ENDSWITH + 1 ) ,
+	COP_VALUE_NOTCONTAINS	= ( COP_VALUE_CONTAINS + 1 ) ,
+	COP_DOSWILDCARDS	= ( COP_VALUE_NOTCONTAINS + 1 ) ,
+	COP_WORD_EQUAL	= ( COP_DOSWILDCARDS + 1 ) ,
+	COP_WORD_STARTSWITH	= ( COP_WORD_EQUAL + 1 ) ,
+	COP_APPLICATION_SPECIFIC	= ( COP_WORD_STARTSWITH + 1 ) 
+    } 	CONDITION_OPERATION;
+
+typedef /* [v1_enum] */ 
+enum tagSTRUCTURED_QUERY_SINGLE_OPTION
+    {	SQSO_SCHEMA	= 0,
+	SQSO_LOCALE_WORD_BREAKING	= ( SQSO_SCHEMA + 1 ) ,
+	SQSO_WORD_BREAKER	= ( SQSO_LOCALE_WORD_BREAKING + 1 ) ,
+	SQSO_NATURAL_SYNTAX	= ( SQSO_WORD_BREAKER + 1 ) ,
+	SQSO_AUTOMATIC_WILDCARD	= ( SQSO_NATURAL_SYNTAX + 1 ) ,
+	SQSO_TRACE_LEVEL	= ( SQSO_AUTOMATIC_WILDCARD + 1 ) ,
+	SQSO_LANGUAGE_KEYWORDS	= ( SQSO_TRACE_LEVEL + 1 ) 
+    } 	STRUCTURED_QUERY_SINGLE_OPTION;
+
+typedef /* [v1_enum] */ 
+enum tagSTRUCTURED_QUERY_MULTIOPTION
+    {	SQMO_VIRTUAL_PROPERTY	= 0,
+	SQMO_DEFAULT_PROPERTY	= ( SQMO_VIRTUAL_PROPERTY + 1 ) ,
+	SQMO_GENERATOR_FOR_TYPE	= ( SQMO_DEFAULT_PROPERTY + 1 ) 
+    } 	STRUCTURED_QUERY_MULTIOPTION;
+
+typedef /* [v1_enum] */ 
+enum tagSTRUCTURED_QUERY_PARSE_ERROR
+    {	SQPE_NONE	= 0,
+	SQPE_EXTRA_OPENING_PARENTHESIS	= ( SQPE_NONE + 1 ) ,
+	SQPE_EXTRA_CLOSING_PARENTHESIS	= ( SQPE_EXTRA_OPENING_PARENTHESIS + 1 ) ,
+	SQPE_IGNORED_MODIFIER	= ( SQPE_EXTRA_CLOSING_PARENTHESIS + 1 ) ,
+	SQPE_IGNORED_CONNECTOR	= ( SQPE_IGNORED_MODIFIER + 1 ) ,
+	SQPE_IGNORED_KEYWORD	= ( SQPE_IGNORED_CONNECTOR + 1 ) ,
+	SQPE_UNHANDLED	= ( SQPE_IGNORED_KEYWORD + 1 ) 
+    } 	STRUCTURED_QUERY_PARSE_ERROR;
+
+/* [v1_enum] */ 
+enum tagSTRUCTURED_QUERY_RESOLVE_OPTION
+    {	SQRO_DONT_RESOLVE_DATETIME	= 0x1,
+	SQRO_ALWAYS_ONE_INTERVAL	= 0x2,
+	SQRO_DONT_SIMPLIFY_CONDITION_TREES	= 0x4,
+	SQRO_DONT_MAP_RELATIONS	= 0x8,
+	SQRO_DONT_RESOLVE_RANGES	= 0x10,
+	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS	= 0x20,
+	SQRO_DONT_SPLIT_WORDS	= 0x40,
+	SQRO_IGNORE_PHRASE_ORDER	= 0x80
+    } ;
+typedef int STRUCTURED_QUERY_RESOLVE_OPTION;
+
+typedef /* [v1_enum] */ 
+enum tagINTERVAL_LIMIT_KIND
+    {	ILK_EXPLICIT_INCLUDED	= 0,
+	ILK_EXPLICIT_EXCLUDED	= ( ILK_EXPLICIT_INCLUDED + 1 ) ,
+	ILK_NEGATIVE_INFINITY	= ( ILK_EXPLICIT_EXCLUDED + 1 ) ,
+	ILK_POSITIVE_INFINITY	= ( ILK_NEGATIVE_INFINITY + 1 ) 
+    } 	INTERVAL_LIMIT_KIND;
+
+typedef /* [v1_enum] */ 
+enum tagQUERY_PARSER_MANAGER_OPTION
+    {	QPMO_SCHEMA_BINARY_NAME	= 0,
+	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_SCHEMA_BINARY_NAME + 1 ) ,
+	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
+	QPMO_LOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
+	QPMO_APPEND_LCID_TO_LOCALIZED_PATH	= ( QPMO_LOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
+	QPMO_LOCALIZER_SUPPORT	= ( QPMO_APPEND_LCID_TO_LOCALIZED_PATH + 1 ) 
+    } 	QUERY_PARSER_MANAGER_OPTION;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_s_ifspec;
+
+#ifndef __IQueryParser_INTERFACE_DEFINED__
+#define __IQueryParser_INTERFACE_DEFINED__
+
+/* interface IQueryParser */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IQueryParser;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")
+    IQueryParser : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Parse( 
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
+            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetOption( 
+            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetOption( 
+            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
+            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetMultiOption( 
+            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
+            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetSchemaProvider( 
+            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RestateToString( 
+            /* [in] */ __RPC__in_opt ICondition *pCondition,
+            /* [in] */ BOOL fUseEnglish,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE ParsePropertyValue( 
+            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RestatePropertyValueToString( 
+            /* [in] */ __RPC__in_opt ICondition *pCondition,
+            /* [in] */ BOOL fUseEnglish,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IQueryParserVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IQueryParser * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IQueryParser * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IQueryParser * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Parse )( 
+            IQueryParser * This,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
+            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
+            IQueryParser * This,
+            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
+            IQueryParser * This,
+            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
+            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetMultiOption )( 
+            IQueryParser * This,
+            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
+            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSchemaProvider )( 
+            IQueryParser * This,
+            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider);
+        
+        HRESULT ( STDMETHODCALLTYPE *RestateToString )( 
+            IQueryParser * This,
+            /* [in] */ __RPC__in_opt ICondition *pCondition,
+            /* [in] */ BOOL fUseEnglish,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
+        
+        HRESULT ( STDMETHODCALLTYPE *ParsePropertyValue )( 
+            IQueryParser * This,
+            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
+        
+        HRESULT ( STDMETHODCALLTYPE *RestatePropertyValueToString )( 
+            IQueryParser * This,
+            /* [in] */ __RPC__in_opt ICondition *pCondition,
+            /* [in] */ BOOL fUseEnglish,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
+        
+        END_INTERFACE
+    } IQueryParserVtbl;
+
+    interface IQueryParser
+    {
+        CONST_VTBL struct IQueryParserVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IQueryParser_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IQueryParser_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IQueryParser_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IQueryParser_Parse(This,pszInputString,pCustomProperties,ppSolution)	\
+    ( (This)->lpVtbl -> Parse(This,pszInputString,pCustomProperties,ppSolution) ) 
+
+#define IQueryParser_SetOption(This,option,pOptionValue)	\
+    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 
+
+#define IQueryParser_GetOption(This,option,pOptionValue)	\
+    ( (This)->lpVtbl -> GetOption(This,option,pOptionValue) ) 
+
+#define IQueryParser_SetMultiOption(This,option,pszOptionKey,pOptionValue)	\
+    ( (This)->lpVtbl -> SetMultiOption(This,option,pszOptionKey,pOptionValue) ) 
+
+#define IQueryParser_GetSchemaProvider(This,ppSchemaProvider)	\
+    ( (This)->lpVtbl -> GetSchemaProvider(This,ppSchemaProvider) ) 
+
+#define IQueryParser_RestateToString(This,pCondition,fUseEnglish,ppszQueryString)	\
+    ( (This)->lpVtbl -> RestateToString(This,pCondition,fUseEnglish,ppszQueryString) ) 
+
+#define IQueryParser_ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)	\
+    ( (This)->lpVtbl -> ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution) ) 
+
+#define IQueryParser_RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)	\
+    ( (This)->lpVtbl -> RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IQueryParser_INTERFACE_DEFINED__ */
+
+
+#ifndef __IConditionFactory_INTERFACE_DEFINED__
+#define __IConditionFactory_INTERFACE_DEFINED__
+
+/* interface IConditionFactory */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IConditionFactory;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")
+    IConditionFactory : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE MakeNot( 
+            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MakeAndOr( 
+            /* [in] */ CONDITION_TYPE nodeType,
+            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MakeLeaf( 
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
+            /* [in] */ CONDITION_OPERATION op,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
+            /* [in] */ __RPC__in const PROPVARIANT *pValue,
+            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
+            /* [in] */ BOOL expand,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Resolve( 
+            /* [in] */ 
+            __in  ICondition *pConditionTree,
+            /* [in] */ 
+            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
+            /* [ref][in] */ 
+            __in_opt  const SYSTEMTIME *pstReferenceTime,
+            /* [retval][out] */ 
+            __out  ICondition **ppResolvedConditionTree) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IConditionFactoryVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IConditionFactory * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IConditionFactory * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IConditionFactory * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
+            IConditionFactory * This,
+            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
+            IConditionFactory * This,
+            /* [in] */ CONDITION_TYPE nodeType,
+            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
+            IConditionFactory * This,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
+            /* [in] */ CONDITION_OPERATION op,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
+            /* [in] */ __RPC__in const PROPVARIANT *pValue,
+            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
+            /* [in] */ BOOL expand,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
+            IConditionFactory * This,
+            /* [in] */ 
+            __in  ICondition *pConditionTree,
+            /* [in] */ 
+            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
+            /* [ref][in] */ 
+            __in_opt  const SYSTEMTIME *pstReferenceTime,
+            /* [retval][out] */ 
+            __out  ICondition **ppResolvedConditionTree);
+        
+        END_INTERFACE
+    } IConditionFactoryVtbl;
+
+    interface IConditionFactory
+    {
+        CONST_VTBL struct IConditionFactoryVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IConditionFactory_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IConditionFactory_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IConditionFactory_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IConditionFactory_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 
+
+#define IConditionFactory_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 
+
+#define IConditionFactory_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 
+
+#define IConditionFactory_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
+    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IConditionFactory_INTERFACE_DEFINED__ */
+
+
+#ifndef __IQuerySolution_INTERFACE_DEFINED__
+#define __IQuerySolution_INTERFACE_DEFINED__
+
+/* interface IQuerySolution */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IQuerySolution;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")
+    IQuerySolution : public IConditionFactory
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetQuery( 
+            /* [out] */ 
+            __out_opt  ICondition **ppQueryNode,
+            /* [out] */ 
+            __out_opt  IEntity **ppMainType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetErrors( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLexicalData( 
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszInputString,
+            /* [out] */ 
+            __out_opt  ITokenCollection **ppTokens,
+            /* [out] */ 
+            __out_opt  LCID *pLocale,
+            /* [out] */ 
+            __out_opt  IUnknown **ppWordBreaker) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IQuerySolutionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IQuerySolution * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IQuerySolution * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IQuerySolution * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
+            IQuerySolution * This,
+            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
+            IQuerySolution * This,
+            /* [in] */ CONDITION_TYPE nodeType,
+            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
+            /* [in] */ BOOL simplify,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
+            IQuerySolution * This,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
+            /* [in] */ CONDITION_OPERATION op,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
+            /* [in] */ __RPC__in const PROPVARIANT *pValue,
+            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
+            /* [in] */ BOOL expand,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
+            IQuerySolution * This,
+            /* [in] */ 
+            __in  ICondition *pConditionTree,
+            /* [in] */ 
+            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
+            /* [ref][in] */ 
+            __in_opt  const SYSTEMTIME *pstReferenceTime,
+            /* [retval][out] */ 
+            __out  ICondition **ppResolvedConditionTree);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
+            IQuerySolution * This,
+            /* [out] */ 
+            __out_opt  ICondition **ppQueryNode,
+            /* [out] */ 
+            __out_opt  IEntity **ppMainType);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetErrors )( 
+            IQuerySolution * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetLexicalData )( 
+            IQuerySolution * This,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszInputString,
+            /* [out] */ 
+            __out_opt  ITokenCollection **ppTokens,
+            /* [out] */ 
+            __out_opt  LCID *pLocale,
+            /* [out] */ 
+            __out_opt  IUnknown **ppWordBreaker);
+        
+        END_INTERFACE
+    } IQuerySolutionVtbl;
+
+    interface IQuerySolution
+    {
+        CONST_VTBL struct IQuerySolutionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IQuerySolution_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IQuerySolution_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IQuerySolution_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IQuerySolution_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 
+
+#define IQuerySolution_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 
+
+#define IQuerySolution_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
+    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 
+
+#define IQuerySolution_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
+    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 
+
+
+#define IQuerySolution_GetQuery(This,ppQueryNode,ppMainType)	\
+    ( (This)->lpVtbl -> GetQuery(This,ppQueryNode,ppMainType) ) 
+
+#define IQuerySolution_GetErrors(This,riid,ppParseErrors)	\
+    ( (This)->lpVtbl -> GetErrors(This,riid,ppParseErrors) ) 
+
+#define IQuerySolution_GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)	\
+    ( (This)->lpVtbl -> GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IQuerySolution_INTERFACE_DEFINED__ */
+
+
+#ifndef __ICondition_INTERFACE_DEFINED__
+#define __ICondition_INTERFACE_DEFINED__
+
+/* interface ICondition */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_ICondition;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("0FC988D4-C935-4b97-A973-46282EA175C8")
+    ICondition : public IPersistStream
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
+            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetSubConditions( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetComparisonInfo( 
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszPropertyName,
+            /* [out] */ 
+            __out_opt  CONDITION_OPERATION *pOperation,
+            /* [out] */ 
+            __out_opt  PROPVARIANT *pValue) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetValueType( 
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetValueNormalization( 
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputTerms( 
+            /* [out] */ 
+            __out_opt  IRichChunk **ppPropertyTerm,
+            /* [out] */ 
+            __out_opt  IRichChunk **ppOperationTerm,
+            /* [out] */ 
+            __out_opt  IRichChunk **ppValueTerm) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Clone( 
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IConditionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ICondition * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ICondition * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ICondition * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
+            ICondition * This,
+            /* [out] */ __RPC__out CLSID *pClassID);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
+            ICondition * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Load )( 
+            ICondition * This,
+            /* [unique][in] */ __RPC__in_opt IStream *pStm);
+        
+        HRESULT ( STDMETHODCALLTYPE *Save )( 
+            ICondition * This,
+            /* [unique][in] */ __RPC__in_opt IStream *pStm,
+            /* [in] */ BOOL fClearDirty);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
+            ICondition * This,
+            /* [out] */ __RPC__out ULARGE_INTEGER *pcbSize);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
+            ICondition * This,
+            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetSubConditions )( 
+            ICondition * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetComparisonInfo )( 
+            ICondition * This,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszPropertyName,
+            /* [out] */ 
+            __out_opt  CONDITION_OPERATION *pOperation,
+            /* [out] */ 
+            __out_opt  PROPVARIANT *pValue);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValueType )( 
+            ICondition * This,
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValueNormalization )( 
+            ICondition * This,
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetInputTerms )( 
+            ICondition * This,
+            /* [out] */ 
+            __out_opt  IRichChunk **ppPropertyTerm,
+            /* [out] */ 
+            __out_opt  IRichChunk **ppOperationTerm,
+            /* [out] */ 
+            __out_opt  IRichChunk **ppValueTerm);
+        
+        HRESULT ( STDMETHODCALLTYPE *Clone )( 
+            ICondition * This,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc);
+        
+        END_INTERFACE
+    } IConditionVtbl;
+
+    interface ICondition
+    {
+        CONST_VTBL struct IConditionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ICondition_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ICondition_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ICondition_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ICondition_GetClassID(This,pClassID)	\
+    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 
+
+
+#define ICondition_IsDirty(This)	\
+    ( (This)->lpVtbl -> IsDirty(This) ) 
+
+#define ICondition_Load(This,pStm)	\
+    ( (This)->lpVtbl -> Load(This,pStm) ) 
+
+#define ICondition_Save(This,pStm,fClearDirty)	\
+    ( (This)->lpVtbl -> Save(This,pStm,fClearDirty) ) 
+
+#define ICondition_GetSizeMax(This,pcbSize)	\
+    ( (This)->lpVtbl -> GetSizeMax(This,pcbSize) ) 
+
+
+#define ICondition_GetConditionType(This,pNodeType)	\
+    ( (This)->lpVtbl -> GetConditionType(This,pNodeType) ) 
+
+#define ICondition_GetSubConditions(This,riid,ppv)	\
+    ( (This)->lpVtbl -> GetSubConditions(This,riid,ppv) ) 
+
+#define ICondition_GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)	\
+    ( (This)->lpVtbl -> GetComparisonInfo(This,ppszPropertyName,pOperation,pValue) ) 
+
+#define ICondition_GetValueType(This,ppszValueTypeName)	\
+    ( (This)->lpVtbl -> GetValueType(This,ppszValueTypeName) ) 
+
+#define ICondition_GetValueNormalization(This,ppszNormalization)	\
+    ( (This)->lpVtbl -> GetValueNormalization(This,ppszNormalization) ) 
+
+#define ICondition_GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)	\
+    ( (This)->lpVtbl -> GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm) ) 
+
+#define ICondition_Clone(This,ppc)	\
+    ( (This)->lpVtbl -> Clone(This,ppc) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ICondition_INTERFACE_DEFINED__ */
+
+
+#ifndef __IConditionGenerator_INTERFACE_DEFINED__
+#define __IConditionGenerator_INTERFACE_DEFINED__
+
+/* interface IConditionGenerator */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IConditionGenerator;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("92D2CC58-4386-45a3-B98C-7E0CE64A4117")
+    IConditionGenerator : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Initialize( 
+            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RecognizeNamedEntities( 
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ LCID lcid,
+            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
+            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GenerateForLeaf( 
+            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
+            /* [in] */ CONDITION_OPERATION op,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
+            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
+            /* [in] */ BOOL automaticWildcard,
+            /* [out] */ __RPC__out BOOL *pNoStringQuery,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
+            /* [unique][in] */ LPCWSTR pszValueType,
+            /* [in] */ const PROPVARIANT *ppropvar,
+            /* [in] */ BOOL fUseEnglish,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IConditionGeneratorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IConditionGenerator * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IConditionGenerator * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IConditionGenerator * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
+            IConditionGenerator * This,
+            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider);
+        
+        HRESULT ( STDMETHODCALLTYPE *RecognizeNamedEntities )( 
+            IConditionGenerator * This,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ LCID lcid,
+            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
+            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities);
+        
+        HRESULT ( STDMETHODCALLTYPE *GenerateForLeaf )( 
+            IConditionGenerator * This,
+            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
+            /* [in] */ CONDITION_OPERATION op,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
+            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
+            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
+            /* [in] */ BOOL automaticWildcard,
+            /* [out] */ __RPC__out BOOL *pNoStringQuery,
+            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
+            IConditionGenerator * This,
+            /* [unique][in] */ LPCWSTR pszValueType,
+            /* [in] */ const PROPVARIANT *ppropvar,
+            /* [in] */ BOOL fUseEnglish,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase);
+        
+        END_INTERFACE
+    } IConditionGeneratorVtbl;
+
+    interface IConditionGenerator
+    {
+        CONST_VTBL struct IConditionGeneratorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IConditionGenerator_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IConditionGenerator_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IConditionGenerator_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IConditionGenerator_Initialize(This,pSchemaProvider)	\
+    ( (This)->lpVtbl -> Initialize(This,pSchemaProvider) ) 
+
+#define IConditionGenerator_RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)	\
+    ( (This)->lpVtbl -> RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities) ) 
+
+#define IConditionGenerator_GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)	\
+    ( (This)->lpVtbl -> GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression) ) 
+
+#define IConditionGenerator_DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)	\
+    ( (This)->lpVtbl -> DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IConditionGenerator_INTERFACE_DEFINED__ */
+
+
+#ifndef __IRichChunk_INTERFACE_DEFINED__
+#define __IRichChunk_INTERFACE_DEFINED__
+
+/* interface IRichChunk */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IRichChunk;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("4FDEF69C-DBC9-454e-9910-B34F3C64B510")
+    IRichChunk : public IUnknown
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
+            /* [out] */ 
+            __out_opt  ULONG *pFirstPos,
+            /* [out] */ 
+            __out_opt  ULONG *pLength,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppsz,
+            /* [out] */ 
+            __out_opt  PROPVARIANT *pValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IRichChunkVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IRichChunk * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IRichChunk * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IRichChunk * This);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
+            IRichChunk * This,
+            /* [out] */ 
+            __out_opt  ULONG *pFirstPos,
+            /* [out] */ 
+            __out_opt  ULONG *pLength,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppsz,
+            /* [out] */ 
+            __out_opt  PROPVARIANT *pValue);
+        
+        END_INTERFACE
+    } IRichChunkVtbl;
+
+    interface IRichChunk
+    {
+        CONST_VTBL struct IRichChunkVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IRichChunk_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IRichChunk_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IRichChunk_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IRichChunk_GetData(This,pFirstPos,pLength,ppsz,pValue)	\
+    ( (This)->lpVtbl -> GetData(This,pFirstPos,pLength,ppsz,pValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IRichChunk_INTERFACE_DEFINED__ */
+
+
+#ifndef __IInterval_INTERFACE_DEFINED__
+#define __IInterval_INTERFACE_DEFINED__
+
+/* interface IInterval */
+/* [unique][uuid][object] */ 
+
+
+EXTERN_C const IID IID_IInterval;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")
+    IInterval : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetLimits( 
+            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
+            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IIntervalVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IInterval * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IInterval * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IInterval * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetLimits )( 
+            IInterval * This,
+            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
+            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
+            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper);
+        
+        END_INTERFACE
+    } IIntervalVtbl;
+
+    interface IInterval
+    {
+        CONST_VTBL struct IIntervalVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IInterval_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IInterval_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IInterval_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IInterval_GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)	\
+    ( (This)->lpVtbl -> GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IInterval_INTERFACE_DEFINED__ */
+
+
+#ifndef __IMetaData_INTERFACE_DEFINED__
+#define __IMetaData_INTERFACE_DEFINED__
+
+/* interface IMetaData */
+/* [unique][uuid][object][helpstring] */ 
+
+
+EXTERN_C const IID IID_IMetaData;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("780102B0-C43B-4876-BC7B-5E9BA5C88794")
+    IMetaData : public IUnknown
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszKey,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IMetaDataVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IMetaData * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IMetaData * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IMetaData * This);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
+            IMetaData * This,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszKey,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppszValue);
+        
+        END_INTERFACE
+    } IMetaDataVtbl;
+
+    interface IMetaData
+    {
+        CONST_VTBL struct IMetaDataVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IMetaData_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IMetaData_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IMetaData_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IMetaData_GetData(This,ppszKey,ppszValue)	\
+    ( (This)->lpVtbl -> GetData(This,ppszKey,ppszValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IMetaData_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_structuredquery_0000_0008 */
+/* [local] */ 
+
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_s_ifspec;
+
+#ifndef __IEntity_INTERFACE_DEFINED__
+#define __IEntity_INTERFACE_DEFINED__
+
+/* interface IEntity */
+/* [unique][object][uuid][helpstring] */ 
+
+
+EXTERN_C const IID IID_IEntity;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")
+    IEntity : public IUnknown
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszName) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Base( 
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Relationships( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetRelationship( 
+            /* [in] */ __RPC__in LPCWSTR pszRelationName,
+            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MetaData( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE NamedEntities( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetNamedEntity( 
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IEntityVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IEntity * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IEntity * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IEntity * This);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
+            IEntity * This,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *Base )( 
+            IEntity * This,
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity);
+        
+        HRESULT ( STDMETHODCALLTYPE *Relationships )( 
+            IEntity * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetRelationship )( 
+            IEntity * This,
+            /* [in] */ __RPC__in LPCWSTR pszRelationName,
+            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship);
+        
+        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
+            IEntity * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
+        
+        HRESULT ( STDMETHODCALLTYPE *NamedEntities )( 
+            IEntity * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetNamedEntity )( 
+            IEntity * This,
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
+            IEntity * This,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase);
+        
+        END_INTERFACE
+    } IEntityVtbl;
+
+    interface IEntity
+    {
+        CONST_VTBL struct IEntityVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IEntity_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IEntity_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IEntity_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IEntity_Name(This,ppszName)	\
+    ( (This)->lpVtbl -> Name(This,ppszName) ) 
+
+#define IEntity_Base(This,pBaseEntity)	\
+    ( (This)->lpVtbl -> Base(This,pBaseEntity) ) 
+
+#define IEntity_Relationships(This,riid,pRelationships)	\
+    ( (This)->lpVtbl -> Relationships(This,riid,pRelationships) ) 
+
+#define IEntity_GetRelationship(This,pszRelationName,pRelationship)	\
+    ( (This)->lpVtbl -> GetRelationship(This,pszRelationName,pRelationship) ) 
+
+#define IEntity_MetaData(This,riid,pMetaData)	\
+    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
+
+#define IEntity_NamedEntities(This,riid,pNamedEntities)	\
+    ( (This)->lpVtbl -> NamedEntities(This,riid,pNamedEntities) ) 
+
+#define IEntity_GetNamedEntity(This,pszValue,ppNamedEntity)	\
+    ( (This)->lpVtbl -> GetNamedEntity(This,pszValue,ppNamedEntity) ) 
+
+#define IEntity_DefaultPhrase(This,ppszPhrase)	\
+    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IEntity_INTERFACE_DEFINED__ */
+
+
+#ifndef __IRelationship_INTERFACE_DEFINED__
+#define __IRelationship_INTERFACE_DEFINED__
+
+/* interface IRelationship */
+/* [unique][object][uuid][helpstring] */ 
+
+
+EXTERN_C const IID IID_IRelationship;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("2769280B-5108-498c-9C7F-A51239B63147")
+    IRelationship : public IUnknown
+    {
+    public:
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszName) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE IsReal( 
+            /* [retval][out] */ __RPC__out BOOL *pIsReal) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Destination( 
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MetaData( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IRelationshipVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IRelationship * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IRelationship * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IRelationship * This);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
+            IRelationship * This,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszName);
+        
+        HRESULT ( STDMETHODCALLTYPE *IsReal )( 
+            IRelationship * This,
+            /* [retval][out] */ __RPC__out BOOL *pIsReal);
+        
+        HRESULT ( STDMETHODCALLTYPE *Destination )( 
+            IRelationship * This,
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity);
+        
+        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
+            IRelationship * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
+            IRelationship * This,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase);
+        
+        END_INTERFACE
+    } IRelationshipVtbl;
+
+    interface IRelationship
+    {
+        CONST_VTBL struct IRelationshipVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IRelationship_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IRelationship_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IRelationship_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IRelationship_Name(This,ppszName)	\
+    ( (This)->lpVtbl -> Name(This,ppszName) ) 
+
+#define IRelationship_IsReal(This,pIsReal)	\
+    ( (This)->lpVtbl -> IsReal(This,pIsReal) ) 
+
+#define IRelationship_Destination(This,pDestinationEntity)	\
+    ( (This)->lpVtbl -> Destination(This,pDestinationEntity) ) 
+
+#define IRelationship_MetaData(This,riid,pMetaData)	\
+    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
+
+#define IRelationship_DefaultPhrase(This,ppszPhrase)	\
+    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IRelationship_INTERFACE_DEFINED__ */
+
+
+#ifndef __INamedEntity_INTERFACE_DEFINED__
+#define __INamedEntity_INTERFACE_DEFINED__
+
+/* interface INamedEntity */
+/* [unique][uuid][object][helpstring] */ 
+
+
+EXTERN_C const IID IID_INamedEntity;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")
+    INamedEntity : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE GetValue( 
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct INamedEntityVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            INamedEntity * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            INamedEntity * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            INamedEntity * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
+            INamedEntity * This,
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
+            INamedEntity * This,
+            /* [retval][out] */ 
+            __deref_opt_out  LPWSTR *ppszPhrase);
+        
+        END_INTERFACE
+    } INamedEntityVtbl;
+
+    interface INamedEntity
+    {
+        CONST_VTBL struct INamedEntityVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define INamedEntity_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define INamedEntity_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define INamedEntity_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define INamedEntity_GetValue(This,ppszValue)	\
+    ( (This)->lpVtbl -> GetValue(This,ppszValue) ) 
+
+#define INamedEntity_DefaultPhrase(This,ppszPhrase)	\
+    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __INamedEntity_INTERFACE_DEFINED__ */
+
+
+#ifndef __ISchemaProvider_INTERFACE_DEFINED__
+#define __ISchemaProvider_INTERFACE_DEFINED__
+
+/* interface ISchemaProvider */
+/* [unique][object][uuid][helpstring] */ 
+
+
+EXTERN_C const IID IID_ISchemaProvider;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")
+    ISchemaProvider : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Entities( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE RootEntity( 
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE GetEntity( 
+            /* [in] */ __RPC__in LPCWSTR pszEntityName,
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE MetaData( 
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE Localize( 
+            /* [in] */ LCID lcid,
+            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SaveBinary( 
+            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE LookupAuthoredNamedEntity( 
+            /* [in] */ __RPC__in_opt IEntity *pEntity,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
+            /* [in] */ ULONG cTokensBegin,
+            /* [out] */ __RPC__out ULONG *pcTokensLength,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ISchemaProviderVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ISchemaProvider * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ISchemaProvider * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Entities )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities);
+        
+        HRESULT ( STDMETHODCALLTYPE *RootEntity )( 
+            ISchemaProvider * This,
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity);
+        
+        HRESULT ( STDMETHODCALLTYPE *GetEntity )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in LPCWSTR pszEntityName,
+            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity);
+        
+        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
+        
+        HRESULT ( STDMETHODCALLTYPE *Localize )( 
+            ISchemaProvider * This,
+            /* [in] */ LCID lcid,
+            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport);
+        
+        HRESULT ( STDMETHODCALLTYPE *SaveBinary )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath);
+        
+        HRESULT ( STDMETHODCALLTYPE *LookupAuthoredNamedEntity )( 
+            ISchemaProvider * This,
+            /* [in] */ __RPC__in_opt IEntity *pEntity,
+            /* [in] */ __RPC__in LPCWSTR pszInputString,
+            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
+            /* [in] */ ULONG cTokensBegin,
+            /* [out] */ __RPC__out ULONG *pcTokensLength,
+            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
+        
+        END_INTERFACE
+    } ISchemaProviderVtbl;
+
+    interface ISchemaProvider
+    {
+        CONST_VTBL struct ISchemaProviderVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ISchemaProvider_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ISchemaProvider_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ISchemaProvider_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ISchemaProvider_Entities(This,riid,pEntities)	\
+    ( (This)->lpVtbl -> Entities(This,riid,pEntities) ) 
+
+#define ISchemaProvider_RootEntity(This,pRootEntity)	\
+    ( (This)->lpVtbl -> RootEntity(This,pRootEntity) ) 
+
+#define ISchemaProvider_GetEntity(This,pszEntityName,pEntity)	\
+    ( (This)->lpVtbl -> GetEntity(This,pszEntityName,pEntity) ) 
+
+#define ISchemaProvider_MetaData(This,riid,pMetaData)	\
+    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 
+
+#define ISchemaProvider_Localize(This,lcid,pSchemaLocalizerSupport)	\
+    ( (This)->lpVtbl -> Localize(This,lcid,pSchemaLocalizerSupport) ) 
+
+#define ISchemaProvider_SaveBinary(This,pszSchemaBinaryPath)	\
+    ( (This)->lpVtbl -> SaveBinary(This,pszSchemaBinaryPath) ) 
+
+#define ISchemaProvider_LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)	\
+    ( (This)->lpVtbl -> LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ISchemaProvider_INTERFACE_DEFINED__ */
+
+
+#ifndef __ITokenCollection_INTERFACE_DEFINED__
+#define __ITokenCollection_INTERFACE_DEFINED__
+
+/* interface ITokenCollection */
+/* [unique][object][uuid][helpstring] */ 
+
+
+EXTERN_C const IID IID_ITokenCollection;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("22D8B4F2-F577-4adb-A335-C2AE88416FAB")
+    ITokenCollection : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE NumberOfTokens( 
+            __RPC__in ULONG *pCount) = 0;
+        
+        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToken( 
+            /* [in] */ ULONG i,
+            /* [out] */ 
+            __out_opt  ULONG *pBegin,
+            /* [out] */ 
+            __out_opt  ULONG *pLength,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppsz) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ITokenCollectionVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ITokenCollection * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ITokenCollection * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ITokenCollection * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *NumberOfTokens )( 
+            ITokenCollection * This,
+            __RPC__in ULONG *pCount);
+        
+        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetToken )( 
+            ITokenCollection * This,
+            /* [in] */ ULONG i,
+            /* [out] */ 
+            __out_opt  ULONG *pBegin,
+            /* [out] */ 
+            __out_opt  ULONG *pLength,
+            /* [out] */ 
+            __deref_opt_out  LPWSTR *ppsz);
+        
+        END_INTERFACE
+    } ITokenCollectionVtbl;
+
+    interface ITokenCollection
+    {
+        CONST_VTBL struct ITokenCollectionVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ITokenCollection_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ITokenCollection_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ITokenCollection_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ITokenCollection_NumberOfTokens(This,pCount)	\
+    ( (This)->lpVtbl -> NumberOfTokens(This,pCount) ) 
+
+#define ITokenCollection_GetToken(This,i,pBegin,pLength,ppsz)	\
+    ( (This)->lpVtbl -> GetToken(This,i,pBegin,pLength,ppsz) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ITokenCollection_INTERFACE_DEFINED__ */
+
+
+/* interface __MIDL_itf_structuredquery_0000_0013 */
+/* [local] */ 
+
+typedef /* [public][public][v1_enum] */ 
+enum __MIDL___MIDL_itf_structuredquery_0000_0013_0001
+    {	NEC_LOW	= 0,
+	NEC_MEDIUM	= ( NEC_LOW + 1 ) ,
+	NEC_HIGH	= ( NEC_MEDIUM + 1 ) 
+    } 	NAMED_ENTITY_CERTAINTY;
+
+
+
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_c_ifspec;
+extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_s_ifspec;
+
+#ifndef __INamedEntityCollector_INTERFACE_DEFINED__
+#define __INamedEntityCollector_INTERFACE_DEFINED__
+
+/* interface INamedEntityCollector */
+/* [unique][object][uuid][helpstring] */ 
+
+
+EXTERN_C const IID IID_INamedEntityCollector;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")
+    INamedEntityCollector : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Add( 
+            /* [in] */ ULONG beginSpan,
+            /* [in] */ ULONG endSpan,
+            /* [in] */ ULONG beginActual,
+            /* [in] */ ULONG endActual,
+            /* [in] */ __RPC__in_opt IEntity *pType,
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [in] */ NAMED_ENTITY_CERTAINTY certainty) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct INamedEntityCollectorVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            INamedEntityCollector * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            INamedEntityCollector * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            INamedEntityCollector * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Add )( 
+            INamedEntityCollector * This,
+            /* [in] */ ULONG beginSpan,
+            /* [in] */ ULONG endSpan,
+            /* [in] */ ULONG beginActual,
+            /* [in] */ ULONG endActual,
+            /* [in] */ __RPC__in_opt IEntity *pType,
+            /* [in] */ __RPC__in LPCWSTR pszValue,
+            /* [in] */ NAMED_ENTITY_CERTAINTY certainty);
+        
+        END_INTERFACE
+    } INamedEntityCollectorVtbl;
+
+    interface INamedEntityCollector
+    {
+        CONST_VTBL struct INamedEntityCollectorVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define INamedEntityCollector_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define INamedEntityCollector_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define INamedEntityCollector_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define INamedEntityCollector_Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)	\
+    ( (This)->lpVtbl -> Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __INamedEntityCollector_INTERFACE_DEFINED__ */
+
+
+#ifndef __ISchemaLocalizerSupport_INTERFACE_DEFINED__
+#define __ISchemaLocalizerSupport_INTERFACE_DEFINED__
+
+/* interface ISchemaLocalizerSupport */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_ISchemaLocalizerSupport;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")
+    ISchemaLocalizerSupport : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE Localize( 
+            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct ISchemaLocalizerSupportVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            ISchemaLocalizerSupport * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            ISchemaLocalizerSupport * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            ISchemaLocalizerSupport * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *Localize )( 
+            ISchemaLocalizerSupport * This,
+            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
+            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString);
+        
+        END_INTERFACE
+    } ISchemaLocalizerSupportVtbl;
+
+    interface ISchemaLocalizerSupport
+    {
+        CONST_VTBL struct ISchemaLocalizerSupportVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define ISchemaLocalizerSupport_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define ISchemaLocalizerSupport_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define ISchemaLocalizerSupport_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define ISchemaLocalizerSupport_Localize(This,pszGlobalString,ppszLocalString)	\
+    ( (This)->lpVtbl -> Localize(This,pszGlobalString,ppszLocalString) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __ISchemaLocalizerSupport_INTERFACE_DEFINED__ */
+
+
+#ifndef __IQueryParserManager_INTERFACE_DEFINED__
+#define __IQueryParserManager_INTERFACE_DEFINED__
+
+/* interface IQueryParserManager */
+/* [unique][object][uuid] */ 
+
+
+EXTERN_C const IID IID_IQueryParserManager;
+
+#if defined(__cplusplus) && !defined(CINTERFACE)
+    
+    MIDL_INTERFACE("A879E3C4-AF77-44fb-8F37-EBD1487CF920")
+    IQueryParserManager : public IUnknown
+    {
+    public:
+        virtual HRESULT STDMETHODCALLTYPE CreateLoadedParser( 
+            /* [in] */ __RPC__in LPCWSTR pszCatalog,
+            /* [in] */ LANGID langidForKeywords,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE InitializeOptions( 
+            /* [in] */ BOOL fUnderstandNQS,
+            /* [in] */ BOOL fAutoWildCard,
+            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser) = 0;
+        
+        virtual HRESULT STDMETHODCALLTYPE SetOption( 
+            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
+        
+    };
+    
+#else 	/* C style interface */
+
+    typedef struct IQueryParserManagerVtbl
+    {
+        BEGIN_INTERFACE
+        
+        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
+            IQueryParserManager * This,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][out] */ 
+            __RPC__deref_out  void **ppvObject);
+        
+        ULONG ( STDMETHODCALLTYPE *AddRef )( 
+            IQueryParserManager * This);
+        
+        ULONG ( STDMETHODCALLTYPE *Release )( 
+            IQueryParserManager * This);
+        
+        HRESULT ( STDMETHODCALLTYPE *CreateLoadedParser )( 
+            IQueryParserManager * This,
+            /* [in] */ __RPC__in LPCWSTR pszCatalog,
+            /* [in] */ LANGID langidForKeywords,
+            /* [in] */ __RPC__in REFIID riid,
+            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser);
+        
+        HRESULT ( STDMETHODCALLTYPE *InitializeOptions )( 
+            IQueryParserManager * This,
+            /* [in] */ BOOL fUnderstandNQS,
+            /* [in] */ BOOL fAutoWildCard,
+            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser);
+        
+        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
+            IQueryParserManager * This,
+            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
+            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
+        
+        END_INTERFACE
+    } IQueryParserManagerVtbl;
+
+    interface IQueryParserManager
+    {
+        CONST_VTBL struct IQueryParserManagerVtbl *lpVtbl;
+    };
+
+    
+
+#ifdef COBJMACROS
+
+
+#define IQueryParserManager_QueryInterface(This,riid,ppvObject)	\
+    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
+
+#define IQueryParserManager_AddRef(This)	\
+    ( (This)->lpVtbl -> AddRef(This) ) 
+
+#define IQueryParserManager_Release(This)	\
+    ( (This)->lpVtbl -> Release(This) ) 
+
+
+#define IQueryParserManager_CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)	\
+    ( (This)->lpVtbl -> CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser) ) 
+
+#define IQueryParserManager_InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)	\
+    ( (This)->lpVtbl -> InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser) ) 
+
+#define IQueryParserManager_SetOption(This,option,pOptionValue)	\
+    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 
+
+#endif /* COBJMACROS */
+
+
+#endif 	/* C style interface */
+
+
+
+
+#endif 	/* __IQueryParserManager_INTERFACE_DEFINED__ */
+
+
+
+#ifndef __StructuredQuery1_LIBRARY_DEFINED__
+#define __StructuredQuery1_LIBRARY_DEFINED__
+
+/* library StructuredQuery1 */
+/* [version][uuid] */ 
+
+
+EXTERN_C const IID LIBID_StructuredQuery1;
+
+EXTERN_C const CLSID CLSID_QueryParser;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")
+QueryParser;
+#endif
+
+EXTERN_C const CLSID CLSID_NegationCondition;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")
+NegationCondition;
+#endif
+
+EXTERN_C const CLSID CLSID_CompoundCondition;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("116F8D13-101E-4fa5-84D4-FF8279381935")
+CompoundCondition;
+#endif
+
+EXTERN_C const CLSID CLSID_LeafCondition;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")
+LeafCondition;
+#endif
+
+EXTERN_C const CLSID CLSID_ConditionFactory;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")
+ConditionFactory;
+#endif
+
+EXTERN_C const CLSID CLSID_Interval;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("D957171F-4BF9-4de2-BCD5-C70A7CA55836")
+Interval;
+#endif
+
+EXTERN_C const CLSID CLSID_QueryParserManager;
+
+#ifdef __cplusplus
+
+class DECLSPEC_UUID("5088B39A-29B4-4d9d-8245-4EE289222F66")
+QueryParserManager;
+#endif
+#endif /* __StructuredQuery1_LIBRARY_DEFINED__ */
+
+/* Additional Prototypes for ALL interfaces */
+
+unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
+unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
+void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 
+
+unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
+void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 
+
+/* end of Additional Prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
--- a/src/hostapi/wasapi/pa_win_wasapi.c
+++ b/src/hostapi/wasapi/pa_win_wasapi.c
@@ -1,5181 +1,5742 @@
-/*
- * Portable Audio I/O Library WASAPI implementation
- * Copyright (c) 2006-2010 David Viens, Dmitry Kostjuchenko
- *
- * Based on the Open Source API proposed by Ross Bencina
- * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however,
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also
- * requested that these non-binding requests be included along with the
- * license above.
- */
-
-/** @file
- @ingroup hostapi_src
- @brief WASAPI implementation of support for a host API.
- @note pa_wasapi currently requires minimum VC 2005, and the latest Vista SDK
-*/
-
-#define WIN32_LEAN_AND_MEAN // exclude rare headers
-#include <windows.h>
-#include <stdio.h>
-#include <process.h>
-#include <assert.h>
-#include <mmsystem.h>
-#include <mmreg.h>  // must be before other Wasapi headers
-#if defined(_MSC_VER) && (_MSC_VER >= 1400)
-	#include <Avrt.h>
-	#define COBJMACROS
-	#include <Audioclient.h>
-	#include <endpointvolume.h>
-	#define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
-	#include <mmdeviceapi.h>
-	#include <functiondiscoverykeys.h>
-    #include <devicetopology.h>	// Used to get IKsJackDescription interface
-	#undef INITGUID
-#endif
-#ifndef __MWERKS__
-#include <malloc.h>
-#include <memory.h>
-#endif /* __MWERKS__ */
-
-#include "pa_util.h"
-#include "pa_allocation.h"
-#include "pa_hostapi.h"
-#include "pa_stream.h"
-#include "pa_cpuload.h"
-#include "pa_process.h"
-#include "pa_win_wasapi.h"
-#include "pa_debugprint.h"
-#include "pa_ringbuffer.h"
-
-#include "pa_win_coinitialize.h"
-
-#ifndef NTDDI_VERSION
- 
-    #undef WINVER
-    #undef _WIN32_WINNT
-    #define WINVER       0x0600 // VISTA
-	#define _WIN32_WINNT WINVER
-
-	#ifndef _AVRT_ //<< fix MinGW dummy compile by defining missing type: AVRT_PRIORITY
-        typedef enum _AVRT_PRIORITY
-        {
-            AVRT_PRIORITY_LOW = -1,
-            AVRT_PRIORITY_NORMAL,
-            AVRT_PRIORITY_HIGH,
-            AVRT_PRIORITY_CRITICAL
-        } AVRT_PRIORITY, *PAVRT_PRIORITY;
-	#endif
-
-	#include <basetyps.h> // << for IID/CLSID
-    #include <rpcsal.h>
-    #include <sal.h>
-
-	#ifndef __LPCGUID_DEFINED__
-		#define __LPCGUID_DEFINED__
-		typedef const GUID *LPCGUID;
-	#endif
-
-    #ifndef PROPERTYKEY_DEFINED
-        #define PROPERTYKEY_DEFINED
-        typedef struct _tagpropertykey
-        {
-            GUID fmtid;
-            DWORD pid;
-        } 	PROPERTYKEY;
-    #endif
-
-    #ifdef __midl_proxy
-        #define __MIDL_CONST
-    #else
-        #define __MIDL_CONST const
-    #endif
-
-    #ifdef WIN64
-        #include <wtypes.h>
-        typedef LONG NTSTATUS;
-        #define FASTCALL
-        #include <oleidl.h>
-        #include <objidl.h>
-     #else
-        typedef struct _BYTE_BLOB
-        {
-            unsigned long clSize;
-            unsigned char abData[ 1 ];
-        } 	BYTE_BLOB;
-        typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *UP_BYTE_BLOB;
-        typedef LONGLONG REFERENCE_TIME;
-        #define NONAMELESSUNION
-    #endif
-    
-    #ifndef WAVE_FORMAT_IEEE_FLOAT
-        #define WAVE_FORMAT_IEEE_FLOAT 0x0003 // 32-bit floating-point
-    #endif    
-    
-    #ifndef __MINGW_EXTENSION
-        #if defined(__GNUC__) || defined(__GNUG__)
-            #define __MINGW_EXTENSION __extension__
-        #else
-            #define __MINGW_EXTENSION
-        #endif
-    #endif 
-
-    #include <sdkddkver.h>
-    #include <propkeydef.h>
-    #define COBJMACROS
-    #define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
-    #include <audioclient.h>
-    #include <mmdeviceapi.h>
-    #include <endpointvolume.h>
-    #include <functiondiscoverykeys.h>
-	#include <devicetopology.h>	// Used to get IKsJackDescription interface
-    #undef INITGUID
-
-#endif // NTDDI_VERSION
-
-#ifndef GUID_SECT
-    #define GUID_SECT
-#endif
-
-#define __DEFINE_GUID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const GUID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
-#define __DEFINE_IID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const IID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
-#define __DEFINE_CLSID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const CLSID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
-#define PA_DEFINE_CLSID(className, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
-    __DEFINE_CLSID(pa_CLSID_##className, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)
-#define PA_DEFINE_IID(interfaceName, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
-    __DEFINE_IID(pa_IID_##interfaceName, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)
-
-// "1CB9AD4C-DBFA-4c32-B178-C2F568A703B2"
-PA_DEFINE_IID(IAudioClient,         1cb9ad4c, dbfa, 4c32, b1, 78, c2, f5, 68, a7, 03, b2);
-// "1BE09788-6894-4089-8586-9A2A6C265AC5"
-PA_DEFINE_IID(IMMEndpoint,          1be09788, 6894, 4089, 85, 86, 9a, 2a, 6c, 26, 5a, c5);
-// "A95664D2-9614-4F35-A746-DE8DB63617E6"
-PA_DEFINE_IID(IMMDeviceEnumerator,  a95664d2, 9614, 4f35, a7, 46, de, 8d, b6, 36, 17, e6);
-// "BCDE0395-E52F-467C-8E3D-C4579291692E"
-PA_DEFINE_CLSID(IMMDeviceEnumerator,bcde0395, e52f, 467c, 8e, 3d, c4, 57, 92, 91, 69, 2e);
-// "F294ACFC-3146-4483-A7BF-ADDCA7C260E2"
-PA_DEFINE_IID(IAudioRenderClient,   f294acfc, 3146, 4483, a7, bf, ad, dc, a7, c2, 60, e2);
-// "C8ADBD64-E71E-48a0-A4DE-185C395CD317"
-PA_DEFINE_IID(IAudioCaptureClient,  c8adbd64, e71e, 48a0, a4, de, 18, 5c, 39, 5c, d3, 17);
-// *2A07407E-6497-4A18-9787-32F79BD0D98F*  Or this??
-PA_DEFINE_IID(IDeviceTopology,      2A07407E, 6497, 4A18, 97, 87, 32, f7, 9b, d0, d9, 8f);
-// *AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9*
-PA_DEFINE_IID(IPart,                AE2DE0E4, 5BCA, 4F2D, aa, 46, 5d, 13, f8, fd, b3, a9);
-// *4509F757-2D46-4637-8E62-CE7DB944F57B*
-PA_DEFINE_IID(IKsJackDescription,   4509F757, 2D46, 4637, 8e, 62, ce, 7d, b9, 44, f5, 7b);
-// Media formats:
-__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_PCM,        0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
-__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_ADPCM,      0x00000002, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
-__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, 0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
-
-/* use CreateThread for CYGWIN/Windows Mobile, _beginthreadex for all others */
-#if !defined(__CYGWIN__) && !defined(_WIN32_WCE)
-	#define CREATE_THREAD(PROC) (HANDLE)_beginthreadex( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
-	#define PA_THREAD_FUNC static unsigned WINAPI
-	#define PA_THREAD_ID unsigned
-#else
-	#define CREATE_THREAD(PROC) CreateThread( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
-	#define PA_THREAD_FUNC static DWORD WINAPI
-	#define PA_THREAD_ID DWORD
-#endif
-
-// Thread function forward decl.
-PA_THREAD_FUNC ProcThreadEvent(void *param);
-PA_THREAD_FUNC ProcThreadPoll(void *param);
-
-// Availabe from Windows 7
-#ifndef AUDCLNT_E_BUFFER_ERROR
-	#define AUDCLNT_E_BUFFER_ERROR AUDCLNT_ERR(0x018)
-#endif
-#ifndef AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
-	#define AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED AUDCLNT_ERR(0x019)
-#endif
-#ifndef AUDCLNT_E_INVALID_DEVICE_PERIOD
-	#define AUDCLNT_E_INVALID_DEVICE_PERIOD AUDCLNT_ERR(0x020)
-#endif
-
-#define MAX_STR_LEN 512
-
-enum { S_INPUT = 0, S_OUTPUT = 1, S_COUNT = 2, S_FULLDUPLEX = 0 };
-
-// Number of packets which compose single contignous buffer. With trial and error it was calculated
-// that WASAPI Input sub-system uses 6 packets per whole buffer. Please provide more information
-// or corrections if available.
-enum { WASAPI_PACKETS_PER_INPUT_BUFFER = 6 };
-
-#define STATIC_ARRAY_SIZE(array) (sizeof(array)/sizeof(array[0]))
-
-#define PRINT(x) PA_DEBUG(x);
-
-#define PA_SKELETON_SET_LAST_HOST_ERROR( errorCode, errorText ) \
-    PaUtil_SetLastHostErrorInfo( paWASAPI, errorCode, errorText )
-
-#define PA_WASAPI__IS_FULLDUPLEX(STREAM) ((STREAM)->in.clientProc && (STREAM)->out.clientProc)
-
-#ifndef IF_FAILED_JUMP
-#define IF_FAILED_JUMP(hr, label) if(FAILED(hr)) goto label;
-#endif
-
-#ifndef IF_FAILED_INTERNAL_ERROR_JUMP
-#define IF_FAILED_INTERNAL_ERROR_JUMP(hr, error, label) if(FAILED(hr)) { error = paInternalError; goto label; }
-#endif
-
-#define SAFE_CLOSE(h) if ((h) != NULL) { CloseHandle((h)); (h) = NULL; }
-#define SAFE_RELEASE(punk) if ((punk) != NULL) { (punk)->lpVtbl->Release((punk)); (punk) = NULL; }
-
-// Mixer function
-typedef void (*MixMonoToStereoF) (void *__to, void *__from, UINT32 count);
-
-// AVRT is the new "multimedia schedulling stuff"
-typedef BOOL   (WINAPI *FAvRtCreateThreadOrderingGroup)  (PHANDLE,PLARGE_INTEGER,GUID*,PLARGE_INTEGER);
-typedef BOOL   (WINAPI *FAvRtDeleteThreadOrderingGroup)  (HANDLE);
-typedef BOOL   (WINAPI *FAvRtWaitOnThreadOrderingGroup)  (HANDLE);
-typedef HANDLE (WINAPI *FAvSetMmThreadCharacteristics)   (LPCSTR,LPDWORD);
-typedef BOOL   (WINAPI *FAvRevertMmThreadCharacteristics)(HANDLE);
-typedef BOOL   (WINAPI *FAvSetMmThreadPriority)          (HANDLE,AVRT_PRIORITY);
-
-static HMODULE hDInputDLL = 0;
-FAvRtCreateThreadOrderingGroup   pAvRtCreateThreadOrderingGroup = NULL;
-FAvRtDeleteThreadOrderingGroup   pAvRtDeleteThreadOrderingGroup = NULL;
-FAvRtWaitOnThreadOrderingGroup   pAvRtWaitOnThreadOrderingGroup = NULL;
-FAvSetMmThreadCharacteristics    pAvSetMmThreadCharacteristics = NULL;
-FAvRevertMmThreadCharacteristics pAvRevertMmThreadCharacteristics = NULL;
-FAvSetMmThreadPriority           pAvSetMmThreadPriority = NULL;
-
-#define _GetProc(fun, type, name)  {                                                        \
-                                        fun = (type) GetProcAddress(hDInputDLL,name);       \
-                                        if (fun == NULL) {                                  \
-                                            PRINT(("GetProcAddr failed for %s" ,name));     \
-                                            return FALSE;                                   \
-                                        }                                                   \
-                                    }                                                       \
-
-// ------------------------------------------------------------------------------------------
-/* prototypes for functions declared in this file */
-#ifdef __cplusplus
-extern "C"
-{
-#endif /* __cplusplus */
-PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-// dummy entry point for other compilers and sdks
-// currently built using RC1 SDK (5600)
-//#if _MSC_VER < 1400
-//PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
-//{
-    //return paNoError;
-//}
-//#else
-
-// ------------------------------------------------------------------------------------------
-static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
-static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
-                                  const PaStreamParameters *inputParameters,
-                                  const PaStreamParameters *outputParameters,
-                                  double sampleRate );
-static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
-                           PaStream** s,
-                           const PaStreamParameters *inputParameters,
-                           const PaStreamParameters *outputParameters,
-                           double sampleRate,
-                           unsigned long framesPerBuffer,
-                           PaStreamFlags streamFlags,
-                           PaStreamCallback *streamCallback,
-                           void *userData );
-static PaError CloseStream( PaStream* stream );
-static PaError StartStream( PaStream *stream );
-static PaError StopStream( PaStream *stream );
-static PaError AbortStream( PaStream *stream );
-static PaError IsStreamStopped( PaStream *s );
-static PaError IsStreamActive( PaStream *stream );
-static PaTime GetStreamTime( PaStream *stream );
-static double GetStreamCpuLoad( PaStream* stream );
-static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
-static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
-static signed long GetStreamReadAvailable( PaStream* stream );
-static signed long GetStreamWriteAvailable( PaStream* stream );
-
-// ------------------------------------------------------------------------------------------
-/*
- These are fields that can be gathered from IDevice and IAudioDevice PRIOR to Initialize, and
- done in first pass i assume that neither of these will cause the Driver to "load", but again,
- who knows how they implement their stuff
- */
-typedef struct PaWasapiDeviceInfo
-{
-    // Device
-    IMMDevice *device;
-
-	// from GetId
-    WCHAR szDeviceID[MAX_STR_LEN];
-
-	// from GetState
-    DWORD state;
-
-    // Fields filled from IMMEndpoint'sGetDataFlow
-    EDataFlow flow;
-
-    // Fields filled from IAudioDevice (_prior_ to Initialize)
-    // from GetDevicePeriod(
-    REFERENCE_TIME DefaultDevicePeriod;
-    REFERENCE_TIME MinimumDevicePeriod;
-
-    // from GetMixFormat
-    // WAVEFORMATEX *MixFormat;//needs to be CoTaskMemFree'd after use!
-
-	// Default format (setup through Control Panel by user)
-	WAVEFORMATEXTENSIBLE DefaultFormat;
-
-	// Formfactor
-	EndpointFormFactor formFactor;
-}
-PaWasapiDeviceInfo;
-
-// ------------------------------------------------------------------------------------------
-/* PaWasapiHostApiRepresentation - host api datastructure specific to this implementation */
-typedef struct
-{
-    PaUtilHostApiRepresentation inheritedHostApiRep;
-    PaUtilStreamInterface       callbackStreamInterface;
-    PaUtilStreamInterface       blockingStreamInterface;
-
-    PaUtilAllocationGroup      *allocations;
-
-    /* implementation specific data goes here */
-
-    PaWinUtilComInitializationResult comInitializationResult;
-
-    //in case we later need the synch
-    IMMDeviceEnumerator *enumerator;
-
-    //this is the REAL number of devices, whether they are usefull to PA or not!
-    UINT32 deviceCount;
-
-    WCHAR defaultRenderer [MAX_STR_LEN];
-    WCHAR defaultCapturer [MAX_STR_LEN];
-
-    PaWasapiDeviceInfo *devInfo;
-
-	// Is true when WOW64 Vista/7 Workaround is needed
-	BOOL useWOW64Workaround;
-}
-PaWasapiHostApiRepresentation;
-
-// ------------------------------------------------------------------------------------------
-/* PaWasapiAudioClientParams - audio client parameters */
-typedef struct PaWasapiAudioClientParams
-{
-	PaWasapiDeviceInfo *device_info;
-	PaStreamParameters  stream_params;
-	PaWasapiStreamInfo  wasapi_params;
-	UINT32              frames_per_buffer;
-	double              sample_rate;
-	BOOL                blocking;
-	BOOL                full_duplex;
-	BOOL                wow64_workaround;
-}
-PaWasapiAudioClientParams;
-
-// ------------------------------------------------------------------------------------------
-/* PaWasapiStream - a stream data structure specifically for this implementation */
-typedef struct PaWasapiSubStream
-{
-    IAudioClient        *clientParent;
-	IStream				*clientStream;
-	IAudioClient		*clientProc;
-
-    WAVEFORMATEXTENSIBLE wavex;
-    UINT32               bufferSize;
-    REFERENCE_TIME       deviceLatency;
-    REFERENCE_TIME       period;
-	double				 latencySeconds;
-    UINT32				 framesPerHostCallback;
-	AUDCLNT_SHAREMODE    shareMode;
-	UINT32               streamFlags; // AUDCLNT_STREAMFLAGS_EVENTCALLBACK, ...
-	UINT32               flags;
-	PaWasapiAudioClientParams params; //!< parameters
-
-	// Buffers
-	UINT32               buffers;			//!< number of buffers used (from host side)
-	UINT32               framesPerBuffer;	//!< number of frames per 1 buffer
-	BOOL                 userBufferAndHostMatch;
-
-	// Used for Mono >> Stereo workaround, if driver does not support it
-	// (in Exclusive mode WASAPI usually refuses to operate with Mono (1-ch)
-	void                *monoBuffer;	 //!< pointer to buffer
-	UINT32               monoBufferSize; //!< buffer size in bytes
-	MixMonoToStereoF     monoMixer;		 //!< pointer to mixer function
-
-	PaUtilRingBuffer    *tailBuffer;       //!< buffer with trailing sample for blocking mode operations (only for Input)
-	void                *tailBufferMemory; //!< tail buffer memory region
-}
-PaWasapiSubStream;
-
-// ------------------------------------------------------------------------------------------
-/* PaWasapiHostProcessor - redirects processing data */
-typedef struct PaWasapiHostProcessor
-{
-    PaWasapiHostProcessorCallback processor;
-    void *userData;
-}
-PaWasapiHostProcessor;
-
-// ------------------------------------------------------------------------------------------
-typedef struct PaWasapiStream
-{
-	/* IMPLEMENT ME: rename this */
-    PaUtilStreamRepresentation streamRepresentation;
-    PaUtilCpuLoadMeasurer      cpuLoadMeasurer;
-    PaUtilBufferProcessor      bufferProcessor;
-
-    // input
-	PaWasapiSubStream          in;
-    IAudioCaptureClient       *captureClientParent;
-	IStream                   *captureClientStream;
-	IAudioCaptureClient       *captureClient;
-    IAudioEndpointVolume      *inVol;
-
-	// output
-	PaWasapiSubStream          out;
-    IAudioRenderClient        *renderClientParent;
-	IStream                   *renderClientStream;
-	IAudioRenderClient        *renderClient;
-	IAudioEndpointVolume      *outVol;
-
-	// event handles for event-driven processing mode
-	HANDLE event[S_COUNT];
-
-	// buffer mode
-	PaUtilHostBufferSizeMode bufferMode;
-
-	// must be volatile to avoid race condition on user query while
-	// thread is being started
-    volatile BOOL running;
-
-    PA_THREAD_ID dwThreadId;
-    HANDLE hThread;
-	HANDLE hCloseRequest;
-	HANDLE hThreadStart;        //!< signalled by thread on start
-	HANDLE hThreadExit;         //!< signalled by thread on exit
-	HANDLE hBlockingOpStreamRD;
-	HANDLE hBlockingOpStreamWR;
-
-    // Host callback Output overrider
-	PaWasapiHostProcessor hostProcessOverrideOutput;
-
-    // Host callback Input overrider
-	PaWasapiHostProcessor hostProcessOverrideInput;
-
-	// Defines blocking/callback interface used
-	BOOL bBlocking;
-
-	// Av Task (MM thread management)
-	HANDLE hAvTask;
-
-	// Thread priority level
-	PaWasapiThreadPriority nThreadPriority;
-}
-PaWasapiStream;
-
-// Local stream methods
-void _StreamOnStop(PaWasapiStream *stream);
-void _StreamFinish(PaWasapiStream *stream);
-void _StreamCleanup(PaWasapiStream *stream);
-HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
-HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
-void *PaWasapi_ReallocateMemory(void *ptr, size_t size);
-void PaWasapi_FreeMemory(void *ptr);
-
-// Local statics
-
-// ------------------------------------------------------------------------------------------
-#define LogHostError(HRES) __LogHostError(HRES, __FUNCTION__, __FILE__, __LINE__)
-static HRESULT __LogHostError(HRESULT res, const char *func, const char *file, int line)
-{
-    const char *text = NULL;
-    switch (res)
-	{
-	case S_OK: return res;
-	case E_POINTER                              :text ="E_POINTER"; break;
-	case E_INVALIDARG                           :text ="E_INVALIDARG"; break;
-
-	case AUDCLNT_E_NOT_INITIALIZED              :text ="AUDCLNT_E_NOT_INITIALIZED"; break;
-	case AUDCLNT_E_ALREADY_INITIALIZED          :text ="AUDCLNT_E_ALREADY_INITIALIZED"; break;
-	case AUDCLNT_E_WRONG_ENDPOINT_TYPE          :text ="AUDCLNT_E_WRONG_ENDPOINT_TYPE"; break;
-	case AUDCLNT_E_DEVICE_INVALIDATED           :text ="AUDCLNT_E_DEVICE_INVALIDATED"; break;
-	case AUDCLNT_E_NOT_STOPPED                  :text ="AUDCLNT_E_NOT_STOPPED"; break;
-	case AUDCLNT_E_BUFFER_TOO_LARGE             :text ="AUDCLNT_E_BUFFER_TOO_LARGE"; break;
-	case AUDCLNT_E_OUT_OF_ORDER                 :text ="AUDCLNT_E_OUT_OF_ORDER"; break;
-	case AUDCLNT_E_UNSUPPORTED_FORMAT           :text ="AUDCLNT_E_UNSUPPORTED_FORMAT"; break;
-	case AUDCLNT_E_INVALID_SIZE                 :text ="AUDCLNT_E_INVALID_SIZE"; break;
-	case AUDCLNT_E_DEVICE_IN_USE                :text ="AUDCLNT_E_DEVICE_IN_USE"; break;
-	case AUDCLNT_E_BUFFER_OPERATION_PENDING     :text ="AUDCLNT_E_BUFFER_OPERATION_PENDING"; break;
-	case AUDCLNT_E_THREAD_NOT_REGISTERED        :text ="AUDCLNT_E_THREAD_NOT_REGISTERED"; break;
-	case AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED   :text ="AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED"; break;
-	case AUDCLNT_E_ENDPOINT_CREATE_FAILED       :text ="AUDCLNT_E_ENDPOINT_CREATE_FAILED"; break;
-	case AUDCLNT_E_SERVICE_NOT_RUNNING          :text ="AUDCLNT_E_SERVICE_NOT_RUNNING"; break;
-	case AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     :text ="AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED"; break;
-	case AUDCLNT_E_EXCLUSIVE_MODE_ONLY          :text ="AUDCLNT_E_EXCLUSIVE_MODE_ONLY"; break;
-	case AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL :text ="AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL"; break;
-	case AUDCLNT_E_EVENTHANDLE_NOT_SET          :text ="AUDCLNT_E_EVENTHANDLE_NOT_SET"; break;
-	case AUDCLNT_E_INCORRECT_BUFFER_SIZE        :text ="AUDCLNT_E_INCORRECT_BUFFER_SIZE"; break;
-	case AUDCLNT_E_BUFFER_SIZE_ERROR            :text ="AUDCLNT_E_BUFFER_SIZE_ERROR"; break;
-	case AUDCLNT_E_CPUUSAGE_EXCEEDED            :text ="AUDCLNT_E_CPUUSAGE_EXCEEDED"; break;
-	case AUDCLNT_E_BUFFER_ERROR					:text ="AUDCLNT_E_BUFFER_ERROR"; break;
-	case AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED		:text ="AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED"; break;
-	case AUDCLNT_E_INVALID_DEVICE_PERIOD		:text ="AUDCLNT_E_INVALID_DEVICE_PERIOD"; break;
-
-	case AUDCLNT_S_BUFFER_EMPTY                 :text ="AUDCLNT_S_BUFFER_EMPTY"; break;
-	case AUDCLNT_S_THREAD_ALREADY_REGISTERED    :text ="AUDCLNT_S_THREAD_ALREADY_REGISTERED"; break;
-	case AUDCLNT_S_POSITION_STALLED				:text ="AUDCLNT_S_POSITION_STALLED"; break;
-
-	// other windows common errors:
-	case CO_E_NOTINITIALIZED                    :text ="CO_E_NOTINITIALIZED: you must call CoInitialize() before Pa_OpenStream()"; break;
-
-	default:
-		text = "UNKNOWN ERROR";
-    }
-	PRINT(("WASAPI ERROR HRESULT: 0x%X : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", res, text, func, file, line));
-	PA_SKELETON_SET_LAST_HOST_ERROR(res, text);
-	return res;
-}
-
-// ------------------------------------------------------------------------------------------
-#define LogPaError(PAERR) __LogPaError(PAERR, __FUNCTION__, __FILE__, __LINE__)
-static PaError __LogPaError(PaError err, const char *func, const char *file, int line)
-{
-	if (err == paNoError)
-		return err;
-	PRINT(("WASAPI ERROR PAERROR: %i : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", err, Pa_GetErrorText(err), func, file, line));
-	return err;
-}
-
-// ------------------------------------------------------------------------------------------
-/*! \class ThreadSleepScheduler
-           Allows to emulate thread sleep of less than 1 millisecond under Windows. Scheduler
-		   calculates number of times the thread must run untill next sleep of 1 millisecond.
-		   It does not make thread sleeping for real number of microseconds but rather controls
-		   how many of imaginary microseconds the thread task can allow thread to sleep.
-*/
-typedef struct ThreadIdleScheduler
-{
-	UINT32 m_idle_microseconds; //!< number of microseconds to sleep
-	UINT32 m_next_sleep;        //!< next sleep round
-	UINT32 m_i;					//!< current round iterator position
-	UINT32 m_resolution;		//!< resolution in number of milliseconds
-}
-ThreadIdleScheduler;
-//! Setup scheduler.
-static void ThreadIdleScheduler_Setup(ThreadIdleScheduler *sched, UINT32 resolution, UINT32 microseconds)
-{
-	assert(microseconds != 0);
-	assert(resolution != 0);
-	assert((resolution * 1000) >= microseconds);
-
-	memset(sched, 0, sizeof(*sched));
-
-	sched->m_idle_microseconds = microseconds;
-	sched->m_resolution        = resolution;
-	sched->m_next_sleep        = (resolution * 1000) / microseconds;
-}
-//! Iterate and check if can sleep.
-static UINT32 ThreadIdleScheduler_NextSleep(ThreadIdleScheduler *sched)
-{
-	// advance and check if thread can sleep
-	if (++ sched->m_i == sched->m_next_sleep)
-	{
-		sched->m_i = 0;
-		return sched->m_resolution;
-	}
-	return 0;
-}
-
-// ------------------------------------------------------------------------------------------
-/*static double nano100ToMillis(REFERENCE_TIME ref)
-{
-    //  1 nano = 0.000000001 seconds
-    //100 nano = 0.0000001   seconds
-    //100 nano = 0.0001   milliseconds
-    return ((double)ref)*0.0001;
-}*/
-
-// ------------------------------------------------------------------------------------------
-static double nano100ToSeconds(REFERENCE_TIME ref)
-{
-    //  1 nano = 0.000000001 seconds
-    //100 nano = 0.0000001   seconds
-    //100 nano = 0.0001   milliseconds
-    return ((double)ref)*0.0000001;
-}
-
-// ------------------------------------------------------------------------------------------
-/*static REFERENCE_TIME MillisTonano100(double ref)
-{
-    //  1 nano = 0.000000001 seconds
-    //100 nano = 0.0000001   seconds
-    //100 nano = 0.0001   milliseconds
-    return (REFERENCE_TIME)(ref/0.0001);
-}*/
-
-// ------------------------------------------------------------------------------------------
-static REFERENCE_TIME SecondsTonano100(double ref)
-{
-    //  1 nano = 0.000000001 seconds
-    //100 nano = 0.0000001   seconds
-    //100 nano = 0.0001   milliseconds
-    return (REFERENCE_TIME)(ref/0.0000001);
-}
-
-// ------------------------------------------------------------------------------------------
-// Makes Hns period from frames and sample rate
-static REFERENCE_TIME MakeHnsPeriod(UINT32 nFrames, DWORD nSamplesPerSec)
-{
-	return (REFERENCE_TIME)((10000.0 * 1000 / nSamplesPerSec * nFrames) + 0.5);
-}
-
-// ------------------------------------------------------------------------------------------
-// Converts PaSampleFormat to bits per sample value
-static WORD PaSampleFormatToBitsPerSample(PaSampleFormat format_id)
-{
-	switch (format_id & ~paNonInterleaved)
-	{
-		case paFloat32:
-		case paInt32: return 32;
-		case paInt24: return 24;
-		case paInt16: return 16;
-		case paInt8:
-		case paUInt8: return 8;
-	}
-	return 0;
-}
-
-// ------------------------------------------------------------------------------------------
-// Converts PaSampleFormat to bits per sample value
-/*static WORD PaSampleFormatToBytesPerSample(PaSampleFormat format_id)
-{
-	return PaSampleFormatToBitsPerSample(format_id) >> 3; // 'bits/8'
-}*/
-
-// ------------------------------------------------------------------------------------------
-// Converts Hns period into number of frames
-static UINT32 MakeFramesFromHns(REFERENCE_TIME hnsPeriod, UINT32 nSamplesPerSec)
-{
-    UINT32 nFrames = (UINT32)(	// frames =
-        1.0 * hnsPeriod *		// hns *
-        nSamplesPerSec /		// (frames / s) /
-        1000 /					// (ms / s) /
-        10000					// (hns / s) /
-        + 0.5					// rounding
-    );
-	return nFrames;
-}
-
-// Aligning function type
-typedef UINT32 (*ALIGN_FUNC) (UINT32 v, UINT32 align);
-
-// ------------------------------------------------------------------------------------------
-// Aligns 'v' backwards
-static UINT32 ALIGN_BWD(UINT32 v, UINT32 align)
-{
-	return ((v - (align ? v % align : 0)));
-}
-
-// ------------------------------------------------------------------------------------------
-// Aligns 'v' forward
-static UINT32 ALIGN_FWD(UINT32 v, UINT32 align)
-{
-	UINT32 remainder = (align ? (v % align) : 0);
-	if (remainder == 0)
-		return v;
-	return v + (align - remainder);
-}
-
-// ------------------------------------------------------------------------------------------
-// Get next value power of 2
-UINT32 ALIGN_NEXT_POW2(UINT32 v)
-{
-	UINT32 v2 = 1;
-	while (v > (v2 <<= 1)) { }
-	v = v2;
-	return v;
-}
-
-// ------------------------------------------------------------------------------------------
-// Aligns WASAPI buffer to 128 byte packet boundary. HD Audio will fail to play if buffer
-// is misaligned. This problem was solved in Windows 7 were AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
-// is thrown although we must align for Vista anyway.
-static UINT32 AlignFramesPerBuffer(UINT32 nFrames, UINT32 nSamplesPerSec, UINT32 nBlockAlign,
-								   ALIGN_FUNC pAlignFunc)
-{
-#define HDA_PACKET_SIZE (128)
-
-	long frame_bytes = nFrames * nBlockAlign;
-	long packets;
-
-	// align to packet size
-	frame_bytes  = pAlignFunc(frame_bytes, HDA_PACKET_SIZE); // use ALIGN_FWD if bigger but safer period is more desired
-
-	// atlest 1 frame must be available
-	if (frame_bytes < HDA_PACKET_SIZE)
-		frame_bytes = HDA_PACKET_SIZE;
-
-	nFrames      = frame_bytes / nBlockAlign;
-	packets      = frame_bytes / HDA_PACKET_SIZE;
-
-	frame_bytes = packets * HDA_PACKET_SIZE;
-	nFrames     = frame_bytes / nBlockAlign;
-
-	return nFrames;
-
-#undef HDA_PACKET_SIZE
-}
-
-// ------------------------------------------------------------------------------------------
-static UINT32 GetFramesSleepTime(UINT32 nFrames, UINT32 nSamplesPerSec)
-{
-	REFERENCE_TIME nDuration;
-	if (nSamplesPerSec == 0)
-		return 0;
-#define REFTIMES_PER_SEC  10000000
-#define REFTIMES_PER_MILLISEC  10000
-	// Calculate the actual duration of the allocated buffer.
-	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
-	return (UINT32)(nDuration/REFTIMES_PER_MILLISEC/2);
-}
-
-// ------------------------------------------------------------------------------------------
-static UINT32 GetFramesSleepTimeMicroseconds(UINT32 nFrames, UINT32 nSamplesPerSec)
-{
-	REFERENCE_TIME nDuration;
-	if (nSamplesPerSec == 0)
-		return 0;
-#define REFTIMES_PER_SEC  10000000
-#define REFTIMES_PER_MILLISEC  10000
-	// Calculate the actual duration of the allocated buffer.
-	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
-	return (UINT32)(nDuration/10/2);
-}
-
-// ------------------------------------------------------------------------------------------
-static BOOL SetupAVRT()
-{
-    hDInputDLL = LoadLibraryA("avrt.dll");
-    if (hDInputDLL == NULL)
-        return FALSE;
-
-    _GetProc(pAvRtCreateThreadOrderingGroup,  FAvRtCreateThreadOrderingGroup,  "AvRtCreateThreadOrderingGroup");
-    _GetProc(pAvRtDeleteThreadOrderingGroup,  FAvRtDeleteThreadOrderingGroup,  "AvRtDeleteThreadOrderingGroup");
-    _GetProc(pAvRtWaitOnThreadOrderingGroup,  FAvRtWaitOnThreadOrderingGroup,  "AvRtWaitOnThreadOrderingGroup");
-    _GetProc(pAvSetMmThreadCharacteristics,   FAvSetMmThreadCharacteristics,   "AvSetMmThreadCharacteristicsA");
-	_GetProc(pAvRevertMmThreadCharacteristics,FAvRevertMmThreadCharacteristics,"AvRevertMmThreadCharacteristics");
-    _GetProc(pAvSetMmThreadPriority,          FAvSetMmThreadPriority,          "AvSetMmThreadPriority");
-
-	return pAvRtCreateThreadOrderingGroup &&
-		pAvRtDeleteThreadOrderingGroup &&
-		pAvRtWaitOnThreadOrderingGroup &&
-		pAvSetMmThreadCharacteristics &&
-		pAvRevertMmThreadCharacteristics &&
-		pAvSetMmThreadPriority;
-}
-
-// ------------------------------------------------------------------------------------------
-static void CloseAVRT()
-{
-	if (hDInputDLL != NULL)
-		FreeLibrary(hDInputDLL);
-	hDInputDLL = NULL;
-}
-
-// ------------------------------------------------------------------------------------------
-static BOOL IsWow64()
-{
-	// http://msdn.microsoft.com/en-us/library/ms684139(VS.85).aspx
-
-	typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
-	LPFN_ISWOW64PROCESS fnIsWow64Process;
-
-    BOOL bIsWow64 = FALSE;
-
-    // IsWow64Process is not available on all supported versions of Windows.
-    // Use GetModuleHandle to get a handle to the DLL that contains the function
-    // and GetProcAddress to get a pointer to the function if available.
-
-    fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress(
-        GetModuleHandleA("kernel32"), "IsWow64Process");
-
-    if (fnIsWow64Process == NULL)
-		return FALSE;
-
-    if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64))
-		return FALSE;
-
-    return bIsWow64;
-}
-
-// ------------------------------------------------------------------------------------------
-typedef enum EWindowsVersion
-{
-	WINDOWS_UNKNOWN			 = 0,
-	WINDOWS_VISTA_SERVER2008 = (1 << 0),
-	WINDOWS_7_SERVER2008R2	 = (1 << 1),
-	WINDOWS_FUTURE           = (1 << 2)
-}
-EWindowsVersion;
-// Defines Windows 7/Windows Server 2008 R2 and up (future versions)
-#define WINDOWS_7_SERVER2008R2_AND_UP (WINDOWS_7_SERVER2008R2|WINDOWS_FUTURE)
-// The function is limited to Vista/7 mostly as we need just to find out Vista/WOW64 combination
-// in order to use WASAPI WOW64 workarounds.
-static UINT32 GetWindowsVersion()
-{
-	static UINT32 version = WINDOWS_UNKNOWN;
-
-	if (version == WINDOWS_UNKNOWN)
-	{
-		DWORD dwVersion = 0;
-		DWORD dwMajorVersion = 0;
-		DWORD dwMinorVersion = 0;
-		DWORD dwBuild = 0;
-
-		typedef DWORD (WINAPI *LPFN_GETVERSION)(VOID);
-		LPFN_GETVERSION fnGetVersion;
-
-		fnGetVersion = (LPFN_GETVERSION) GetProcAddress(GetModuleHandleA("kernel32"), "GetVersion");
-		if (fnGetVersion == NULL)
-			return WINDOWS_UNKNOWN;
-
-		dwVersion = fnGetVersion();
-
-		// Get the Windows version
-		dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
-		dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
-
-		// Get the build number
-		if (dwVersion < 0x80000000)
-			dwBuild = (DWORD)(HIWORD(dwVersion));
-
-		switch (dwMajorVersion)
-		{
-		case 0:
-		case 1:
-		case 2:
-		case 3:
-		case 4:
-		case 5:
-			break; // skip lower
-		case 6:
-			switch (dwMinorVersion)
-			{
-			case 0:
-				version |= WINDOWS_VISTA_SERVER2008;
-				break;
-			case 1:
-				version |= WINDOWS_7_SERVER2008R2;
-				break;
-			default:
-				version |= WINDOWS_FUTURE;
-			}
-			break;
-		default:
-			version |= WINDOWS_FUTURE;
-		}
-	}
-
-	return version;
-}
-
-// ------------------------------------------------------------------------------------------
-static BOOL UseWOW64Workaround()
-{
-	// note: WOW64 bug is common to Windows Vista x64, thus we fall back to safe Poll-driven
-	//       method. Windows 7 x64 seems has WOW64 bug fixed.
-
-	return (IsWow64() && (GetWindowsVersion() & WINDOWS_VISTA_SERVER2008));
-}
-
-// ------------------------------------------------------------------------------------------
-typedef enum EMixerDir { MIX_DIR__1TO2, MIX_DIR__2TO1, MIX_DIR__2TO1_L } EMixerDir;
-
-// ------------------------------------------------------------------------------------------
-#define _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(TYPE)\
-	TYPE * __restrict to   = __to;\
-	TYPE * __restrict from = __from;\
-	TYPE * __restrict end  = from + count;\
-	while (from != end)\
-	{\
-		*to ++ = *from;\
-		*to ++ = *from;\
-		++ from;\
-	}
-
-// ------------------------------------------------------------------------------------------
-#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(TYPE)\
-	TYPE * __restrict to   = (TYPE *)__to;\
-	TYPE * __restrict from = (TYPE *)__from;\
-	TYPE * __restrict end  = to + count;\
-	while (to != end)\
-	{\
-		*to ++ = (TYPE)((float)(from[0] + from[1]) * 0.5f);\
-		from += 2;\
-	}
-
-// ------------------------------------------------------------------------------------------
-#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(TYPE)\
-	TYPE * __restrict to   = (TYPE *)__to;\
-	TYPE * __restrict from = (TYPE *)__from;\
-	TYPE * __restrict end  = to + count;\
-	while (to != end)\
-	{\
-		*to ++ = (TYPE)(((INT32)from[0] + (INT32)from[1]) >> 1);\
-		from += 2;\
-	}
-
-// ------------------------------------------------------------------------------------------
-#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(TYPE)\
-	TYPE * __restrict to   = (TYPE *)__to;\
-	TYPE * __restrict from = (TYPE *)__from;\
-	TYPE * __restrict end  = to + count;\
-	while (to != end)\
-	{\
-		*to ++ = (TYPE)(((INT64)from[0] + (INT64)from[1]) >> 1);\
-		from += 2;\
-	}
-
-// ------------------------------------------------------------------------------------------
-#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(TYPE)\
-	TYPE * __restrict to   = (TYPE *)__to;\
-	TYPE * __restrict from = (TYPE *)__from;\
-	TYPE * __restrict end  = to + count;\
-	while (to != end)\
-	{\
-		*to ++ = from[0];\
-		from += 2;\
-	}
-
-// ------------------------------------------------------------------------------------------
-static void _MixMonoToStereo_1TO2_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(BYTE); }
-static void _MixMonoToStereo_1TO2_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(short); }
-static void _MixMonoToStereo_1TO2_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); /* !!! int24 data is contained in 32-bit containers*/ }
-static void _MixMonoToStereo_1TO2_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); }
-static void _MixMonoToStereo_1TO2_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(float); }
-
-// ------------------------------------------------------------------------------------------
-static void _MixMonoToStereo_2TO1_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(BYTE); }
-static void _MixMonoToStereo_2TO1_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(short); }
-static void _MixMonoToStereo_2TO1_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(int); /* !!! int24 data is contained in 32-bit containers*/ }
-static void _MixMonoToStereo_2TO1_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(int); }
-static void _MixMonoToStereo_2TO1_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(float); }
-
-// ------------------------------------------------------------------------------------------
-static void _MixMonoToStereo_2TO1_8_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(BYTE); }
-static void _MixMonoToStereo_2TO1_16_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(short); }
-static void _MixMonoToStereo_2TO1_24_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); /* !!! int24 data is contained in 32-bit containers*/ }
-static void _MixMonoToStereo_2TO1_32_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); }
-static void _MixMonoToStereo_2TO1_32f_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(float); }
-
-// ------------------------------------------------------------------------------------------
-static MixMonoToStereoF _GetMonoToStereoMixer(PaSampleFormat format, EMixerDir dir)
-{
-	switch (dir)
-	{
-	case MIX_DIR__1TO2:
-		switch (format & ~paNonInterleaved)
-		{
-		case paUInt8:	return _MixMonoToStereo_1TO2_8;
-		case paInt16:	return _MixMonoToStereo_1TO2_16;
-		case paInt24:	return _MixMonoToStereo_1TO2_24;
-		case paInt32:	return _MixMonoToStereo_1TO2_32;
-		case paFloat32: return _MixMonoToStereo_1TO2_32f;
-		}
-		break;
-
-	case MIX_DIR__2TO1:
-		switch (format & ~paNonInterleaved)
-		{
-		case paUInt8:	return _MixMonoToStereo_2TO1_8;
-		case paInt16:	return _MixMonoToStereo_2TO1_16;
-		case paInt24:	return _MixMonoToStereo_2TO1_24;
-		case paInt32:	return _MixMonoToStereo_2TO1_32;
-		case paFloat32: return _MixMonoToStereo_2TO1_32f;
-		}
-		break;
-
-	case MIX_DIR__2TO1_L:
-		switch (format & ~paNonInterleaved)
-		{
-		case paUInt8:	return _MixMonoToStereo_2TO1_8_L;
-		case paInt16:	return _MixMonoToStereo_2TO1_16_L;
-		case paInt24:	return _MixMonoToStereo_2TO1_24_L;
-		case paInt32:	return _MixMonoToStereo_2TO1_32_L;
-		case paFloat32: return _MixMonoToStereo_2TO1_32f_L;
-		}
-		break;
-	}
-
-	return NULL;
-}
-
-// ------------------------------------------------------------------------------------------
-PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
-{
-    PaError result = paNoError;
-    PaWasapiHostApiRepresentation *paWasapi;
-    PaDeviceInfo *deviceInfoArray;
-    HRESULT hr = S_OK;
-    IMMDeviceCollection* pEndPoints = NULL;
-	UINT i;
-
-    if (!SetupAVRT())
-	{
-        PRINT(("WASAPI: No AVRT! (not VISTA?)"));
-        return paNoError;
-    }
-
-    paWasapi = (PaWasapiHostApiRepresentation *)PaUtil_AllocateMemory( sizeof(PaWasapiHostApiRepresentation) );
-    if (paWasapi == NULL)
-	{
-        result = paInsufficientMemory;
-        goto error;
-    }
-	
-    memset( paWasapi, 0, sizeof(PaWasapiHostApiRepresentation) ); /* ensure all fields are zeroed. especially paWasapi->allocations */
-
-    result = PaWinUtil_CoInitialize( paWASAPI, &paWasapi->comInitializationResult );
-    if( result != paNoError )
-    {
-        goto error;
-    }
-
-    paWasapi->allocations = PaUtil_CreateAllocationGroup();
-    if (paWasapi->allocations == NULL)
-	{
-        result = paInsufficientMemory;
-        goto error;
-    }
-
-    *hostApi                             = &paWasapi->inheritedHostApiRep;
-    (*hostApi)->info.structVersion		 = 1;
-    (*hostApi)->info.type				 = paWASAPI;
-    (*hostApi)->info.name				 = "Windows WASAPI";
-    (*hostApi)->info.deviceCount		 = 0;
-    (*hostApi)->info.defaultInputDevice	 = paNoDevice;
-    (*hostApi)->info.defaultOutputDevice = paNoDevice;
-
-    paWasapi->enumerator = NULL;
-    hr = CoCreateInstance(&pa_CLSID_IMMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER,
-             &pa_IID_IMMDeviceEnumerator, (void **)&paWasapi->enumerator);
-    
-	// We need to set the result to a value otherwise we will return paNoError
-	// [IF_FAILED_JUMP(hResult, error);]
-	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-    // getting default device ids in the eMultimedia "role"
-    {
-        {
-            IMMDevice *defaultRenderer = NULL;
-            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eRender, eMultimedia, &defaultRenderer);
-            if (hr != S_OK)
-			{
-				if (hr != E_NOTFOUND) {
-					// We need to set the result to a value otherwise we will return paNoError
-					// [IF_FAILED_JUMP(hResult, error);]
-					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-				}
-			}
-			else
-			{
-				WCHAR *pszDeviceId = NULL;
-				hr = IMMDevice_GetId(defaultRenderer, &pszDeviceId);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hResult, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-				wcsncpy(paWasapi->defaultRenderer, pszDeviceId, MAX_STR_LEN-1);
-				CoTaskMemFree(pszDeviceId);
-				IMMDevice_Release(defaultRenderer);
-			}
-        }
-
-        {
-            IMMDevice *defaultCapturer = NULL;
-            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eCapture, eMultimedia, &defaultCapturer);
-            if (hr != S_OK)
-			{
-				if (hr != E_NOTFOUND) {
-					// We need to set the result to a value otherwise we will return paNoError
-					// [IF_FAILED_JUMP(hResult, error);]
-					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-				}
-			}
-			else
-			{
-				WCHAR *pszDeviceId = NULL;
-				hr = IMMDevice_GetId(defaultCapturer, &pszDeviceId);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hResult, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-				wcsncpy(paWasapi->defaultCapturer, pszDeviceId, MAX_STR_LEN-1);
-				CoTaskMemFree(pszDeviceId);
-				IMMDevice_Release(defaultCapturer);
-			}
-        }
-    }
-
-    hr = IMMDeviceEnumerator_EnumAudioEndpoints(paWasapi->enumerator, eAll, DEVICE_STATE_ACTIVE, &pEndPoints);
-	// We need to set the result to a value otherwise we will return paNoError
-	// [IF_FAILED_JUMP(hResult, error);]
-	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-    hr = IMMDeviceCollection_GetCount(pEndPoints, &paWasapi->deviceCount);
-	// We need to set the result to a value otherwise we will return paNoError
-	// [IF_FAILED_JUMP(hResult, error);]
-	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-    paWasapi->devInfo = (PaWasapiDeviceInfo *)PaUtil_AllocateMemory(sizeof(PaWasapiDeviceInfo) * paWasapi->deviceCount);
-	for (i = 0; i < paWasapi->deviceCount; ++i)
-		memset(&paWasapi->devInfo[i], 0, sizeof(PaWasapiDeviceInfo));
-
-    if (paWasapi->deviceCount > 0)
-    {
-        (*hostApi)->deviceInfos = (PaDeviceInfo **)PaUtil_GroupAllocateMemory(
-                paWasapi->allocations, sizeof(PaDeviceInfo *) * paWasapi->deviceCount);
-        if ((*hostApi)->deviceInfos == NULL)
-		{
-            result = paInsufficientMemory;
-            goto error;
-        }
-
-        /* allocate all device info structs in a contiguous block */
-        deviceInfoArray = (PaDeviceInfo *)PaUtil_GroupAllocateMemory(
-                paWasapi->allocations, sizeof(PaDeviceInfo) * paWasapi->deviceCount);
-        if (deviceInfoArray == NULL)
-		{
-            result = paInsufficientMemory;
-            goto error;
-        }
-
-        for (i = 0; i < paWasapi->deviceCount; ++i)
-		{
-			DWORD state				  = 0;
-            PaDeviceInfo *deviceInfo  = &deviceInfoArray[i];
-            deviceInfo->structVersion = 2;
-            deviceInfo->hostApi       = hostApiIndex;
-
-			PA_DEBUG(("WASAPI: device idx: %02d\n", i));
-			PA_DEBUG(("WASAPI: ---------------\n"));
-
-            hr = IMMDeviceCollection_Item(pEndPoints, i, &paWasapi->devInfo[i].device);
-			// We need to set the result to a value otherwise we will return paNoError
-			// [IF_FAILED_JUMP(hResult, error);]
-			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-            // getting ID
-            {
-                WCHAR *pszDeviceId = NULL;
-                hr = IMMDevice_GetId(paWasapi->devInfo[i].device, &pszDeviceId);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hr, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-                wcsncpy(paWasapi->devInfo[i].szDeviceID, pszDeviceId, MAX_STR_LEN-1);
-                CoTaskMemFree(pszDeviceId);
-
-                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultCapturer) == 0)
-				{// we found the default input!
-                    (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
-                }
-                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultRenderer) == 0)
-				{// we found the default output!
-                    (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
-                }
-            }
-
-            hr = IMMDevice_GetState(paWasapi->devInfo[i].device, &paWasapi->devInfo[i].state);
-			// We need to set the result to a value otherwise we will return paNoError
-			// [IF_FAILED_JUMP(hResult, error);]
-			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-            if (paWasapi->devInfo[i].state != DEVICE_STATE_ACTIVE)
-			{
-                PRINT(("WASAPI device: %d is not currently available (state:%d)\n",i,state));
-            }
-
-            {
-                IPropertyStore *pProperty;
-                hr = IMMDevice_OpenPropertyStore(paWasapi->devInfo[i].device, STGM_READ, &pProperty);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hResult, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-                // "Friendly" Name
-                {
-					char *deviceName;
-                    PROPVARIANT value;
-                    PropVariantInit(&value);
-                    hr = IPropertyStore_GetValue(pProperty, &PKEY_Device_FriendlyName, &value);
-					// We need to set the result to a value otherwise we will return paNoError
-					// [IF_FAILED_JUMP(hResult, error);]
-					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-                    deviceInfo->name = NULL;
-                    deviceName = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
-                    if (deviceName == NULL)
-					{
-                        result = paInsufficientMemory;
-                        goto error;
-                    }
-					if (value.pwszVal)
-						WideCharToMultiByte(CP_UTF8, 0, value.pwszVal, (int)wcslen(value.pwszVal), deviceName, MAX_STR_LEN-1, 0, 0);
-					else
-						_snprintf(deviceName, MAX_STR_LEN-1, "baddev%d", i);
-                    deviceInfo->name = deviceName;
-                    PropVariantClear(&value);
-					PA_DEBUG(("WASAPI:%d| name[%s]\n", i, deviceInfo->name));
-                }
-
-                // Default format
-                {
-                    PROPVARIANT value;
-                    PropVariantInit(&value);
-                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEngine_DeviceFormat, &value);
-					// We need to set the result to a value otherwise we will return paNoError
-					// [IF_FAILED_JUMP(hResult, error);]
-					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-					memcpy(&paWasapi->devInfo[i].DefaultFormat, value.blob.pBlobData, min(sizeof(paWasapi->devInfo[i].DefaultFormat), value.blob.cbSize));
-                    // cleanup
-                    PropVariantClear(&value);
-                }
-
-                // Formfactor
-                {
-                    PROPVARIANT value;
-                    PropVariantInit(&value);
-                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEndpoint_FormFactor, &value);
-					// We need to set the result to a value otherwise we will return paNoError
-					// [IF_FAILED_JUMP(hResult, error);]
-					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-					// set
-					#if defined(DUMMYUNIONNAME) && defined(NONAMELESSUNION)
-						// avoid breaking strict-aliasing rules in such line: (EndpointFormFactor)(*((UINT *)(((WORD *)&value.wReserved3)+1)));
-						UINT v;
-						memcpy(&v, (((WORD *)&value.wReserved3)+1), sizeof(v));
-						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)v;
-					#else
-						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)value.uintVal;
-					#endif
-					PA_DEBUG(("WASAPI:%d| form-factor[%d]\n", i, paWasapi->devInfo[i].formFactor));
-                    // cleanup
-                    PropVariantClear(&value);
-                }
-
-				SAFE_RELEASE(pProperty);
-            }
-
-
-            // Endpoint data
-            {
-                IMMEndpoint *endpoint = NULL;
-                hr = IMMDevice_QueryInterface(paWasapi->devInfo[i].device, &pa_IID_IMMEndpoint, (void **)&endpoint);
-                if (SUCCEEDED(hr))
-				{
-                    hr = IMMEndpoint_GetDataFlow(endpoint, &paWasapi->devInfo[i].flow);
-                    SAFE_RELEASE(endpoint);
-                }
-            }
-
-            // Getting a temporary IAudioClient for more fields
-            // we make sure NOT to call Initialize yet!
-            {
-                IAudioClient *tmpClient = NULL;
-
-                hr = IMMDevice_Activate(paWasapi->devInfo[i].device, &pa_IID_IAudioClient,
-					CLSCTX_INPROC_SERVER, NULL, (void **)&tmpClient);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hResult, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-                hr = IAudioClient_GetDevicePeriod(tmpClient,
-                    &paWasapi->devInfo[i].DefaultDevicePeriod,
-                    &paWasapi->devInfo[i].MinimumDevicePeriod);
-				// We need to set the result to a value otherwise we will return paNoError
-				// [IF_FAILED_JUMP(hResult, error);]
-				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
-
-                //hr = tmpClient->GetMixFormat(&paWasapi->devInfo[i].MixFormat);
-
-				// Release client
-				SAFE_RELEASE(tmpClient);
-
-				if (hr != S_OK)
-				{
-					//davidv: this happened with my hardware, previously for that same device in DirectSound:
-					//Digital Output (Realtek AC'97 Audio)'s GUID: {0x38f2cf50,0x7b4c,0x4740,0x86,0xeb,0xd4,0x38,0x66,0xd8,0xc8, 0x9f}
-					//so something must be _really_ wrong with this device, TODO handle this better. We kind of need GetMixFormat
-					LogHostError(hr);
-					// We need to set the result to a value otherwise we will return paNoError
-					result = paInternalError;
-					goto error;
-				}
-            }
-
-            // we can now fill in portaudio device data
-            deviceInfo->maxInputChannels  = 0;
-            deviceInfo->maxOutputChannels = 0;
-			deviceInfo->defaultSampleRate = paWasapi->devInfo[i].DefaultFormat.Format.nSamplesPerSec;
-            switch (paWasapi->devInfo[i].flow)
-			{
-			case eRender: {
-                deviceInfo->maxOutputChannels		 = paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
-                deviceInfo->defaultHighOutputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
-                deviceInfo->defaultLowOutputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
-				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
-					deviceInfo->maxOutputChannels, (float)deviceInfo->defaultHighOutputLatency, (float)deviceInfo->defaultLowOutputLatency));
-				break;}
-			case eCapture: {
-                deviceInfo->maxInputChannels		= paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
-                deviceInfo->defaultHighInputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
-                deviceInfo->defaultLowInputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
-				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
-					deviceInfo->maxInputChannels, (float)deviceInfo->defaultHighInputLatency, (float)deviceInfo->defaultLowInputLatency));
-				break; }
-            default:
-                PRINT(("WASAPI:%d| bad Data Flow!\n", i));
-				// We need to set the result to a value otherwise we will return paNoError
-				result = paInternalError;
-                //continue; // do not skip from list, allow to initialize
-            break;
-            }
-
-            (*hostApi)->deviceInfos[i] = deviceInfo;
-            ++(*hostApi)->info.deviceCount;
-        }
-    }
-
-    (*hostApi)->Terminate = Terminate;
-    (*hostApi)->OpenStream = OpenStream;
-    (*hostApi)->IsFormatSupported = IsFormatSupported;
-
-    PaUtil_InitializeStreamInterface( &paWasapi->callbackStreamInterface, CloseStream, StartStream,
-                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
-                                      GetStreamTime, GetStreamCpuLoad,
-                                      PaUtil_DummyRead, PaUtil_DummyWrite,
-                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );
-
-    PaUtil_InitializeStreamInterface( &paWasapi->blockingStreamInterface, CloseStream, StartStream,
-                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
-                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
-                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );
-
-
-	// findout if platform workaround is required
-	paWasapi->useWOW64Workaround = UseWOW64Workaround();
-
-    SAFE_RELEASE(pEndPoints);
-
-	PRINT(("WASAPI: initialized ok\n"));
-
-    return paNoError;
-
-error:
-
-	PRINT(("WASAPI: failed %s error[%d|%s]\n", __FUNCTION__, result, Pa_GetErrorText(result)));
-
-    SAFE_RELEASE(pEndPoints);
-
-	Terminate((PaUtilHostApiRepresentation *)paWasapi);
-
-	// Safety if error was not set so that we do not think initialize was a success
-	if (result == paNoError) {
-		result = paInternalError;
-	}
-
-    return result;
-}
-
-// ------------------------------------------------------------------------------------------
-static void Terminate( PaUtilHostApiRepresentation *hostApi )
-{
-	UINT i;
-    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
-	if (paWasapi == NULL)
-		return;
-
-	// Release IMMDeviceEnumerator
-    SAFE_RELEASE(paWasapi->enumerator);
-
-    for (i = 0; i < paWasapi->deviceCount; ++i)
-	{
-        PaWasapiDeviceInfo *info = &paWasapi->devInfo[i];
-        SAFE_RELEASE(info->device);
-
-		//if (info->MixFormat)
-        //    CoTaskMemFree(info->MixFormat);
-    }
-    PaUtil_FreeMemory(paWasapi->devInfo);
-
-    if (paWasapi->allocations)
-	{
-        PaUtil_FreeAllAllocations(paWasapi->allocations);
-        PaUtil_DestroyAllocationGroup(paWasapi->allocations);
-    }
-
-    PaWinUtil_CoUninitialize( paWASAPI, &paWasapi->comInitializationResult );
-
-    PaUtil_FreeMemory(paWasapi);
-
-	// Close AVRT
-	CloseAVRT();
-}
-
-// ------------------------------------------------------------------------------------------
-static PaWasapiHostApiRepresentation *_GetHostApi(PaError *_error)
-{
-	PaError error;
-
-	PaUtilHostApiRepresentation *pApi;
-	if ((error = PaUtil_GetHostApiRepresentation(&pApi, paWASAPI)) != paNoError)
-	{
-		if (_error != NULL)
-			(*_error) = error;
-
-		return NULL;
-	}
-	return (PaWasapiHostApiRepresentation *)pApi;
-}
-
-// ------------------------------------------------------------------------------------------
-int PaWasapi_GetDeviceDefaultFormat( void *pFormat, unsigned int nFormatSize, PaDeviceIndex nDevice )
-{
-	PaError ret;
-	PaWasapiHostApiRepresentation *paWasapi;
-	UINT32 size;
-	PaDeviceIndex index;
-
-	if (pFormat == NULL)
-		return paBadBufferPtr;
-	if (nFormatSize <= 0)
-		return paBufferTooSmall;
-
-	// Get API
-	paWasapi = _GetHostApi(&ret);
-	if (paWasapi == NULL)
-		return ret;
-
-	// Get device index
-	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
-    if (ret != paNoError)
-        return ret;
-
-	// Validate index
-	if ((UINT32)index >= paWasapi->deviceCount)
-		return paInvalidDevice;
-
-	size = min(nFormatSize, (UINT32)sizeof(paWasapi->devInfo[ index ].DefaultFormat));
-	memcpy(pFormat, &paWasapi->devInfo[ index ].DefaultFormat, size);
-
-	return size;
-}
-
-// ------------------------------------------------------------------------------------------
-int PaWasapi_GetDeviceRole( PaDeviceIndex nDevice )
-{
-	PaError ret;
-	PaDeviceIndex index;
-
-	// Get API
-	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
-	if (paWasapi == NULL)
-		return paNotInitialized;
-
-	// Get device index
-	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
-    if (ret != paNoError)
-        return ret;
-
-	// Validate index
-	if ((UINT32)index >= paWasapi->deviceCount)
-		return paInvalidDevice;
-
-	return paWasapi->devInfo[ index ].formFactor;
-}
-
-// ------------------------------------------------------------------------------------------
-PaError PaWasapi_GetFramesPerHostBuffer( PaStream *pStream, unsigned int *nInput, unsigned int *nOutput )
-{
-    PaWasapiStream *stream = (PaWasapiStream *)pStream;
-	if (stream == NULL)
-		return paBadStreamPtr;
-
-	if (nInput != NULL)
-		(*nInput) = stream->in.framesPerHostCallback;
-
-	if (nOutput != NULL)
-		(*nOutput) = stream->out.framesPerHostCallback;
-
-	return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-static void LogWAVEFORMATEXTENSIBLE(const WAVEFORMATEXTENSIBLE *in)
-{
-    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;
-	switch (old->wFormatTag)
-	{
-	case WAVE_FORMAT_EXTENSIBLE: {
-
-		PRINT(("wFormatTag     =WAVE_FORMAT_EXTENSIBLE\n"));
-
-		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
-		{
-			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\n"));
-		}
-		else
-		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
-		{
-			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_PCM\n"));
-		}
-		else
-		{
-			PRINT(("SubFormat      =CUSTOM GUID{%d:%d:%d:%d%d%d%d%d%d%d%d}\n",
-										in->SubFormat.Data1,
-										in->SubFormat.Data2,
-										in->SubFormat.Data3,
-										(int)in->SubFormat.Data4[0],
-										(int)in->SubFormat.Data4[1],
-										(int)in->SubFormat.Data4[2],
-										(int)in->SubFormat.Data4[3],
-										(int)in->SubFormat.Data4[4],
-										(int)in->SubFormat.Data4[5],
-										(int)in->SubFormat.Data4[6],
-										(int)in->SubFormat.Data4[7]));
-		}
-		PRINT(("Samples.wValidBitsPerSample =%d\n",  in->Samples.wValidBitsPerSample));
-		PRINT(("dwChannelMask  =0x%X\n",in->dwChannelMask));
-
-		break; }
-
-	case WAVE_FORMAT_PCM:        PRINT(("wFormatTag     =WAVE_FORMAT_PCM\n")); break;
-	case WAVE_FORMAT_IEEE_FLOAT: PRINT(("wFormatTag     =WAVE_FORMAT_IEEE_FLOAT\n")); break;
-	default: 
-		PRINT(("wFormatTag     =UNKNOWN(%d)\n",old->wFormatTag)); break;
-	}
-
-	PRINT(("nChannels      =%d\n",old->nChannels));
-	PRINT(("nSamplesPerSec =%d\n",old->nSamplesPerSec));
-	PRINT(("nAvgBytesPerSec=%d\n",old->nAvgBytesPerSec));
-	PRINT(("nBlockAlign    =%d\n",old->nBlockAlign));
-	PRINT(("wBitsPerSample =%d\n",old->wBitsPerSample));
-	PRINT(("cbSize         =%d\n",old->cbSize));
-}
-
-// ------------------------------------------------------------------------------------------
-static PaSampleFormat WaveToPaFormat(const WAVEFORMATEXTENSIBLE *in)
-{
-    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;
-
-    switch (old->wFormatTag)
-	{
-    case WAVE_FORMAT_EXTENSIBLE: {
-        if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
-		{
-            if (in->Samples.wValidBitsPerSample == 32)
-                return paFloat32;
-        }
-        else
-		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
-		{
-            switch (old->wBitsPerSample)
-			{
-                case 32: return paInt32;
-                case 24: return paInt24;
-                case  8: return paUInt8;
-                case 16: return paInt16;
-            }
-        }
-		break; }
-
-    case WAVE_FORMAT_IEEE_FLOAT:
-		return paFloat32;
-
-    case WAVE_FORMAT_PCM: {
-        switch (old->wBitsPerSample)
-		{
-            case 32: return paInt32;
-            case 24: return paInt24;
-            case  8: return paUInt8;
-            case 16: return paInt16;
-        }
-		break; }
-    }
-
-    return paCustomFormat;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError MakeWaveFormatFromParams(WAVEFORMATEXTENSIBLE *wavex, const PaStreamParameters *params,
-									double sampleRate)
-{
-	WORD bitsPerSample;
-	WAVEFORMATEX *old;
-	DWORD channelMask = 0;
-	PaWasapiStreamInfo *streamInfo = (PaWasapiStreamInfo *)params->hostApiSpecificStreamInfo;
-
-	// Get user assigned channel mask
-	if ((streamInfo != NULL) && (streamInfo->flags & paWinWasapiUseChannelMask))
-		channelMask = streamInfo->channelMask;
-
-	// Convert PaSampleFormat to bits per sample
-	if ((bitsPerSample = PaSampleFormatToBitsPerSample(params->sampleFormat)) == 0)
-		return paSampleFormatNotSupported;
-
-    memset(wavex, 0, sizeof(*wavex));
-
-    old					 = (WAVEFORMATEX *)wavex;
-    old->nChannels       = (WORD)params->channelCount;
-    old->nSamplesPerSec  = (DWORD)sampleRate;
-	if ((old->wBitsPerSample = bitsPerSample) > 16)
-	{
-		old->wBitsPerSample = 32; // 20 or 24 bits must go in 32 bit containers (ints)
-	}
-    old->nBlockAlign     = (old->nChannels * (old->wBitsPerSample/8));
-    old->nAvgBytesPerSec = (old->nSamplesPerSec * old->nBlockAlign);
-
-    // WAVEFORMATEX
-    if ((params->channelCount <= 2) && ((bitsPerSample == 16) || (bitsPerSample == 8)))
-	{
-        old->cbSize		= 0;
-        old->wFormatTag	= WAVE_FORMAT_PCM;
-    }
-    // WAVEFORMATEXTENSIBLE
-    else
-	{
-        old->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
-        old->cbSize		= sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
-
-        if ((params->sampleFormat & ~paNonInterleaved) == paFloat32)
-            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
-        else
-            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
-
-        wavex->Samples.wValidBitsPerSample = bitsPerSample; //no extra padding!
-
-		// Set channel mask
-		if (channelMask != 0)
-		{
-			wavex->dwChannelMask = channelMask;
-		}
-		else
-		{
-			switch (params->channelCount)
-			{
-			case 1:  wavex->dwChannelMask = KSAUDIO_SPEAKER_MONO; break;
-			case 2:  wavex->dwChannelMask = KSAUDIO_SPEAKER_STEREO; break;
-			case 3:  wavex->dwChannelMask = KSAUDIO_SPEAKER_STEREO|SPEAKER_LOW_FREQUENCY; break;
-			case 4:  wavex->dwChannelMask = KSAUDIO_SPEAKER_QUAD; break;
-			case 5:  wavex->dwChannelMask = KSAUDIO_SPEAKER_QUAD|SPEAKER_LOW_FREQUENCY; break;
-#ifdef KSAUDIO_SPEAKER_5POINT1_SURROUND
-			case 6:  wavex->dwChannelMask = KSAUDIO_SPEAKER_5POINT1_SURROUND; break;
-#else
-			case 6:  wavex->dwChannelMask = KSAUDIO_SPEAKER_5POINT1; break;
-#endif
-#ifdef KSAUDIO_SPEAKER_5POINT1_SURROUND
-			case 7:  wavex->dwChannelMask = KSAUDIO_SPEAKER_5POINT1_SURROUND|SPEAKER_BACK_CENTER; break;
-#else
-			case 7:  wavex->dwChannelMask = KSAUDIO_SPEAKER_5POINT1|SPEAKER_BACK_CENTER; break;
-#endif	
-#ifdef KSAUDIO_SPEAKER_7POINT1_SURROUND
-			case 8:  wavex->dwChannelMask = KSAUDIO_SPEAKER_7POINT1_SURROUND; break;
-#else
-			case 8:  wavex->dwChannelMask = KSAUDIO_SPEAKER_7POINT1; break;
-#endif
-
-			default: wavex->dwChannelMask = 0;
-			}
-		}
-	}
-    return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-/*static void wasapiFillWFEXT( WAVEFORMATEXTENSIBLE* pwfext, PaSampleFormat sampleFormat, double sampleRate, int channelCount)
-{
-    PA_DEBUG(( "sampleFormat = %lx\n" , sampleFormat ));
-    PA_DEBUG(( "sampleRate = %f\n" , sampleRate ));
-    PA_DEBUG(( "chanelCount = %d\n", channelCount ));
-
-    pwfext->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
-    pwfext->Format.nChannels = (WORD)channelCount;
-    pwfext->Format.nSamplesPerSec = (DWORD)sampleRate;
-    if(channelCount == 1)
-        pwfext->dwChannelMask = KSAUDIO_SPEAKER_DIRECTOUT;
-    else
-        pwfext->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
-    if(sampleFormat == paFloat32)
-    {
-        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
-        pwfext->Format.wBitsPerSample = 32;
-        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
-        pwfext->Samples.wValidBitsPerSample = 32;
-        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
-    }
-    else if(sampleFormat == paInt32)
-    {
-        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
-        pwfext->Format.wBitsPerSample = 32;
-        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
-        pwfext->Samples.wValidBitsPerSample = 32;
-        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
-    }
-    else if(sampleFormat == paInt24)
-    {
-        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
-        pwfext->Format.wBitsPerSample = 32; // 24-bit in 32-bit int container
-        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
-        pwfext->Samples.wValidBitsPerSample = 24;
-        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
-    }
-    else if(sampleFormat == paInt16)
-    {
-        pwfext->Format.nBlockAlign = (WORD)(channelCount * 2);
-        pwfext->Format.wBitsPerSample = 16;
-        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
-        pwfext->Samples.wValidBitsPerSample = 16;
-        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
-    }
-    pwfext->Format.nAvgBytesPerSec = pwfext->Format.nSamplesPerSec * pwfext->Format.nBlockAlign;
-}*/
-
-// ------------------------------------------------------------------------------------------
-static PaError GetClosestFormat(IAudioClient *myClient, double sampleRate,
-	const PaStreamParameters *_params, AUDCLNT_SHAREMODE shareMode, WAVEFORMATEXTENSIBLE *outWavex,
-	BOOL output)
-{
-	PaError answer                   = paInvalidSampleRate;
-	WAVEFORMATEX *sharedClosestMatch = NULL;
-	HRESULT hr                       = !S_OK;
-	PaStreamParameters params       = (*_params);
-
-	/* It was not noticed that 24-bit Input producing no output while device accepts this format.
-	   To fix this issue let's ask for 32-bits and let PA converters convert host 32-bit data
-	   to 24-bit for user-space. The bug concerns Vista, if Windows 7 supports 24-bits for Input
-	   please report to PortAudio developers to exclude Windows 7.
-	*/
-	/*if ((params.sampleFormat == paInt24) && (output == FALSE))
-		params.sampleFormat = paFloat32;*/ // <<< The silence was due to missing Int32_To_Int24_Dither implementation
-
-    MakeWaveFormatFromParams(outWavex, &params, sampleRate);
-
-	hr = IAudioClient_IsFormatSupported(myClient, shareMode, &outWavex->Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
-	if (hr == S_OK)
-		answer = paFormatIsSupported;
-    else
-	if (sharedClosestMatch)
-	{
-		WORD bitsPerSample;
-        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)sharedClosestMatch;
-
-		GUID subf_guid = GUID_NULL;
-		if (sharedClosestMatch->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
-		{
-			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEXTENSIBLE));
-			subf_guid = ext->SubFormat;
-		}
-		else
-			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEX));
-
-        CoTaskMemFree(sharedClosestMatch);
-
-		// Make supported by default
-		answer = paFormatIsSupported;
-
-		// Validate SampleRate
-		if ((DWORD)sampleRate != outWavex->Format.nSamplesPerSec)
-			return paInvalidSampleRate;
-
-		// Validate Channel count
-		if ((WORD)params.channelCount != outWavex->Format.nChannels)
-		{
-			// If mono, then driver does not support 1 channel, we use internal workaround
-			// of tiny software mixing functionality, e.g. we provide to user buffer 1 channel
-			// but then mix into 2 for device buffer
-			if ((params.channelCount == 1) && (outWavex->Format.nChannels == 2))
-				return paFormatIsSupported;
-			else
-				return paInvalidChannelCount;
-		}
-
-		// Validate Sample format
-		if ((bitsPerSample = PaSampleFormatToBitsPerSample(params.sampleFormat)) == 0)
-			return paSampleFormatNotSupported;
-
-		// Validate Sample format: bit size (WASAPI does not limit 'bit size')
-		//if (bitsPerSample != outWavex->Format.wBitsPerSample)
-		//	return paSampleFormatNotSupported;
-
-		// Validate Sample format: paFloat32 (WASAPI does not limit 'bit type')
-		//if ((params->sampleFormat == paFloat32) && (subf_guid != KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
-		//	return paSampleFormatNotSupported;
-
-		// Validate Sample format: paInt32 (WASAPI does not limit 'bit type')
-		//if ((params->sampleFormat == paInt32) && (subf_guid != KSDATAFORMAT_SUBTYPE_PCM))
-		//	return paSampleFormatNotSupported;
-	}
-	else
-	{
-		static const int BestToWorst[] = { paFloat32, paInt24, paInt16 };
-		int i;
-
-		// Try combination stereo and we will use built-in mono-stereo mixer then
-		if (params.channelCount == 1)
-		{
-			WAVEFORMATEXTENSIBLE stereo = { 0 };
-
-			PaStreamParameters stereo_params = params;
-			stereo_params.channelCount = 2;
-
-			MakeWaveFormatFromParams(&stereo, &stereo_params, sampleRate);
-
-			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &stereo.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
-			if (hr == S_OK)
-			{
-				memcpy(outWavex, &stereo, sizeof(WAVEFORMATEXTENSIBLE));
-				CoTaskMemFree(sharedClosestMatch);
-				return (answer = paFormatIsSupported);
-			}
-
-			// Try selecting suitable sample type
-			for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
-			{
-				WAVEFORMATEXTENSIBLE sample = { 0 };
-
-				PaStreamParameters sample_params = stereo_params;
-				sample_params.sampleFormat = BestToWorst[i];
-
-				MakeWaveFormatFromParams(&sample, &sample_params, sampleRate);
-
-				hr = IAudioClient_IsFormatSupported(myClient, shareMode, &sample.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
-				if (hr == S_OK)
-				{
-					memcpy(outWavex, &sample, sizeof(WAVEFORMATEXTENSIBLE));
-					CoTaskMemFree(sharedClosestMatch);
-					return (answer = paFormatIsSupported);
-				}
-			}
-		}
-
-		// Try selecting suitable sample type
-		for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
-		{
-			WAVEFORMATEXTENSIBLE spfmt = { 0 };
-
-			PaStreamParameters spfmt_params = params;
-			spfmt_params.sampleFormat = BestToWorst[i];
-
-			MakeWaveFormatFromParams(&spfmt, &spfmt_params, sampleRate);
-
-			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &spfmt.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
-			if (hr == S_OK)
-			{
-				memcpy(outWavex, &spfmt, sizeof(WAVEFORMATEXTENSIBLE));
-				CoTaskMemFree(sharedClosestMatch);
-				answer = paFormatIsSupported;
-				break;
-			}
-		}
-
-		// Nothing helped
-		LogHostError(hr);
-	}
-
-	return answer;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError IsStreamParamsValid(struct PaUtilHostApiRepresentation *hostApi,
-                                   const  PaStreamParameters *inputParameters,
-                                   const  PaStreamParameters *outputParameters,
-                                   double sampleRate)
-{
-	if (hostApi == NULL)
-		return paHostApiNotFound;
-	if ((UINT32)sampleRate == 0)
-		return paInvalidSampleRate;
-
-	if (inputParameters != NULL)
-    {
-        /* all standard sample formats are supported by the buffer adapter,
-            this implementation doesn't support any custom sample formats */
-		if (inputParameters->sampleFormat & paCustomFormat)
-            return paSampleFormatNotSupported;
-
-        /* unless alternate device specification is supported, reject the use of
-            paUseHostApiSpecificDeviceSpecification */
-        if (inputParameters->device == paUseHostApiSpecificDeviceSpecification)
-            return paInvalidDevice;
-
-        /* check that input device can support inputChannelCount */
-        if (inputParameters->channelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels)
-            return paInvalidChannelCount;
-
-        /* validate inputStreamInfo */
-        if (inputParameters->hostApiSpecificStreamInfo)
-		{
-			PaWasapiStreamInfo *inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
-	        if ((inputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
-	            (inputStreamInfo->version != 1) ||
-                (inputStreamInfo->hostApiType != paWASAPI))
-	        {
-	            return paIncompatibleHostApiSpecificStreamInfo;
-	        }
-		}
-
-        return paNoError;
-    }
-
-    if (outputParameters != NULL)
-    {
-        /* all standard sample formats are supported by the buffer adapter,
-            this implementation doesn't support any custom sample formats */
-        if (outputParameters->sampleFormat & paCustomFormat)
-            return paSampleFormatNotSupported;
-
-        /* unless alternate device specification is supported, reject the use of
-            paUseHostApiSpecificDeviceSpecification */
-        if (outputParameters->device == paUseHostApiSpecificDeviceSpecification)
-            return paInvalidDevice;
-
-        /* check that output device can support outputChannelCount */
-        if (outputParameters->channelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels)
-            return paInvalidChannelCount;
-
-        /* validate outputStreamInfo */
-        if(outputParameters->hostApiSpecificStreamInfo)
-        {
-			PaWasapiStreamInfo *outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
-	        if ((outputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
-	            (outputStreamInfo->version != 1) ||
-                (outputStreamInfo->hostApiType != paWASAPI))
-	        {
-	            return paIncompatibleHostApiSpecificStreamInfo;
-	        }
-        }
-
-		return paNoError;
-    }
-
-	return (inputParameters || outputParameters ? paNoError : paInternalError);
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
-                                  const  PaStreamParameters *inputParameters,
-                                  const  PaStreamParameters *outputParameters,
-                                  double sampleRate )
-{
-	IAudioClient *tmpClient = NULL;
-	PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
-	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;
-
-	// Validate PaStreamParameters
-	PaError error;
-	if ((error = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
-		return error;
-
-    if (inputParameters != NULL)
-    {
-		WAVEFORMATEXTENSIBLE wavex;
-		HRESULT hr;
-		PaError answer;
-		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
-		inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
-
-		if (inputStreamInfo && (inputStreamInfo->flags & paWinWasapiExclusive))
-			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;
-
-		hr = IMMDevice_Activate(paWasapi->devInfo[inputParameters->device].device,
-			&pa_IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void **)&tmpClient);
-		if (hr != S_OK)
-		{
-			LogHostError(hr);
-			return paInvalidDevice;
-		}
-
-		answer = GetClosestFormat(tmpClient, sampleRate, inputParameters, shareMode, &wavex, FALSE);
-		SAFE_RELEASE(tmpClient);
-
-		if (answer != paFormatIsSupported)
-			return answer;
-    }
-
-    if (outputParameters != NULL)
-    {
-		HRESULT hr;
-		WAVEFORMATEXTENSIBLE wavex;
-		PaError answer;
-		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
-        outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
-
-		if (outputStreamInfo && (outputStreamInfo->flags & paWinWasapiExclusive))
-			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;
-
-		hr = IMMDevice_Activate(paWasapi->devInfo[outputParameters->device].device,
-			&pa_IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void **)&tmpClient);
-		if (hr != S_OK)
-		{
-			LogHostError(hr);
-			return paInvalidDevice;
-		}
-
-		answer = GetClosestFormat(tmpClient, sampleRate, outputParameters, shareMode, &wavex, TRUE);
-		SAFE_RELEASE(tmpClient);
-
-		if (answer != paFormatIsSupported)
-			return answer;
-    }
-
-    return paFormatIsSupported;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaUint32 PaUtil_GetFramesPerHostBuffer(PaUint32 userFramesPerBuffer, PaTime suggestedLatency, double sampleRate, PaUint32 TimerJitterMs)
-{
-	PaUint32 frames = userFramesPerBuffer + max( userFramesPerBuffer, (PaUint32)(suggestedLatency * sampleRate) );
-    frames += (PaUint32)((sampleRate * 0.001) * TimerJitterMs);
-	return frames;
-}
-
-// ------------------------------------------------------------------------------------------
-static void _RecalculateBuffersCount(PaWasapiSubStream *sub, UINT32 userFramesPerBuffer, UINT32 framesPerLatency, BOOL fullDuplex)
-{
-	// Count buffers (must be at least 1)
-	sub->buffers = (userFramesPerBuffer ? framesPerLatency / userFramesPerBuffer : 0);
-	if (sub->buffers == 0)
-		sub->buffers = 1;
-
-	// Determine amount of buffers used:
-	// - Full-duplex mode will lead to period difference, thus only 1.
-	// - Input mode, only 1, as WASAPI allows extraction of only 1 packet.
-	// - For Shared mode we use double buffering.
-	if ((sub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) || fullDuplex)
-	{
-		// Exclusive mode does not allow >1 buffers be used for Event interface, e.g. GetBuffer
-		// call must acquire max buffer size and it all must be processed.
-		if (sub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)
-			sub->userBufferAndHostMatch = 1;
-
-		// Use paUtilBoundedHostBufferSize because exclusive mode will starve and produce
-		// bad quality of audio
-		sub->buffers = 1;
-	}
-}
-
-// ------------------------------------------------------------------------------------------
-static void _CalculateAlignedPeriod(PaWasapiSubStream *pSub, UINT32 *nFramesPerLatency,
-									ALIGN_FUNC pAlignFunc)
-{
-	// Align frames to HD Audio packet size of 128 bytes for Exclusive mode only.
-	// Not aligning on Windows Vista will cause Event timeout, although Windows 7 will
-	// return AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED error to realign buffer. Aligning is necessary
-	// for Exclusive mode only! when audio data is feeded directly to hardware.
-	if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
-	{
-		(*nFramesPerLatency) = AlignFramesPerBuffer((*nFramesPerLatency),
-			pSub->wavex.Format.nSamplesPerSec, pSub->wavex.Format.nBlockAlign, pAlignFunc);
-	}
-
-	// Calculate period
-	pSub->period = MakeHnsPeriod((*nFramesPerLatency), pSub->wavex.Format.nSamplesPerSec);
-}
-
-// ------------------------------------------------------------------------------------------
-static HRESULT CreateAudioClient(PaWasapiStream *pStream, PaWasapiSubStream *pSub, BOOL output, PaError *pa_error)
-{
-	PaError error;
-    HRESULT hr;
-
-	const PaWasapiDeviceInfo *pInfo  = pSub->params.device_info;
-	const PaStreamParameters *params = &pSub->params.stream_params;
-	UINT32 framesPerLatency          = pSub->params.frames_per_buffer;
-	double sampleRate                = pSub->params.sample_rate;
-	BOOL blocking                    = pSub->params.blocking;
-	BOOL fullDuplex                  = pSub->params.full_duplex;
-
-	const UINT32 userFramesPerBuffer = framesPerLatency;
-    IAudioClient *audioClient	     = NULL;
-
-	// Assume default failure due to some reason
-	(*pa_error) = paInvalidDevice;
-
-	// Validate parameters
-    if (!pSub || !pInfo || !params)
-	{
-		(*pa_error) = paBadStreamPtr;
-        return E_POINTER;
-	}
-	if ((UINT32)sampleRate == 0)
-	{
-		(*pa_error) = paInvalidSampleRate;
-        return E_INVALIDARG;
-	}
-
-    // Get the audio client
-    hr = IMMDevice_Activate(pInfo->device, &pa_IID_IAudioClient, CLSCTX_ALL, NULL, (void **)&audioClient);
-	if (hr != S_OK)
-	{
-		(*pa_error) = paInsufficientMemory;
-		LogHostError(hr);
-		goto done;
-	}
-
-	// Get closest format
-	if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
-	{
-		(*pa_error) = error;
-		LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
-		goto done; // fail, format not supported
-	}
-
-	// Check for Mono <<>> Stereo workaround
-	if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
-	{
-		/*if (blocking)
-		{
-			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
-			goto done; // fail, blocking mode not supported
-		}*/
-
-		// select mixer
-		pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
-		if (pSub->monoMixer == NULL)
-		{
-			(*pa_error) = paInvalidChannelCount;
-			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
-			goto done; // fail, no mixer for format
-		}
-	}
-
-#if 0
-	// Add suggestd latency
-	framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);
-#else
-	// Calculate host buffer size
-	if ((pSub->shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE) &&
-		(!pSub->streamFlags || ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
-	{
-		framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
-			params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
-			(pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);
-	}
-	else
-	{
-		REFERENCE_TIME overall;
-
-		// Work 1:1 with user buffer (only polling allows to use >1)
-		framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);
-
-		// Use Polling if overall latency is > 5ms as it allows to use 100% CPU in a callback,
-		// or user specified latency parameter
-		overall = MakeHnsPeriod(framesPerLatency, pSub->wavex.Format.nSamplesPerSec);
-		if ((overall >= (106667*2)/*21.33ms*/) || ((INT32)(params->suggestedLatency*100000.0) != 0/*0.01 msec granularity*/))
-		{
-			framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
-				params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
-				(streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);
-
-			// Use Polling interface
-			pSub->streamFlags &= ~AUDCLNT_STREAMFLAGS_EVENTCALLBACK;
-			PRINT(("WASAPI: CreateAudioClient: forcing POLL mode\n"));
-		}
-	}
-#endif
-
-	// For full-duplex output resize buffer to be the same as for input
-	if (output && fullDuplex)
-		framesPerLatency = pStream->in.framesPerHostCallback;
-
-	// Avoid 0 frames
-	if (framesPerLatency == 0)
-		framesPerLatency = MakeFramesFromHns(pInfo->DefaultDevicePeriod, pSub->wavex.Format.nSamplesPerSec);
-
-	// Exclusive Input stream renders data in 6 packets, we must set then the size of
-	// single packet, total buffer size, e.g. required latency will be PacketSize * 6
-	if (!output && (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE))
-	{
-		// Do it only for Polling mode
-		if ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)
-		{
-			framesPerLatency /= WASAPI_PACKETS_PER_INPUT_BUFFER;
-		}
-	}
-
-	// Calculate aligned period
-	_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
-
-	/*! Enforce min/max period for device in Shared mode to avoid bad audio quality.
-        Avoid doing so for Exclusive mode as alignment will suffer.
-	*/
-	if (pSub->shareMode == AUDCLNT_SHAREMODE_SHARED)
-	{
-		if (pSub->period < pInfo->DefaultDevicePeriod)
-		{
-			pSub->period = pInfo->DefaultDevicePeriod;
-			// Recalculate aligned period
-			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
-			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
-		}
-	}
-	else
-	{
-		if (pSub->period < pInfo->MinimumDevicePeriod)
-		{
-			pSub->period = pInfo->MinimumDevicePeriod;
-			// Recalculate aligned period
-			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
-			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_FWD);
-		}
-	}
-
-	/*! Windows 7 does not allow to set latency lower than minimal device period and will
-	    return error: AUDCLNT_E_INVALID_DEVICE_PERIOD. Under Vista we enforce the same behavior
-	    manually for unified behavior on all platforms.
-	*/
-	{
-		/*!	AUDCLNT_E_BUFFER_SIZE_ERROR: Applies to Windows 7 and later.
-			Indicates that the buffer duration value requested by an exclusive-mode client is
-			out of range. The requested duration value for pull mode must not be greater than
-			500 milliseconds; for push mode the duration value must not be greater than 2 seconds.
-		*/
-		if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
-		{
-			static const REFERENCE_TIME MAX_BUFFER_EVENT_DURATION = 500  * 10000;
-			static const REFERENCE_TIME MAX_BUFFER_POLL_DURATION  = 2000 * 10000;
-
-			if (pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)	// pull mode, max 500ms
-			{
-				if (pSub->period > MAX_BUFFER_EVENT_DURATION)
-				{
-					pSub->period = MAX_BUFFER_EVENT_DURATION;
-					// Recalculate aligned period
-					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
-					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
-				}
-			}
-			else														// push mode, max 2000ms
-			{
-				if (pSub->period > MAX_BUFFER_POLL_DURATION)
-				{
-					pSub->period = MAX_BUFFER_POLL_DURATION;
-					// Recalculate aligned period
-					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
-					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
-				}
-			}
-		}
-	}
-
-	// Open the stream and associate it with an audio session
-    hr = IAudioClient_Initialize(audioClient,
-        pSub->shareMode,
-        pSub->streamFlags,
-		pSub->period,
-		(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
-		&pSub->wavex.Format,
-        NULL);
-
-	/*! WASAPI is tricky on large device buffer, sometimes 2000ms can be allocated sometimes
-	    less. There is no known guaranteed level thus we make subsequent tries by decreasing
-		buffer by 100ms per try.
-	*/
-	while ((hr == E_OUTOFMEMORY) && (pSub->period > (100 * 10000)))
-	{
-		PRINT(("WASAPI: CreateAudioClient: decreasing buffer size to %d milliseconds\n", (pSub->period / 10000)));
-
-		// Decrease by 100ms and try again
-		pSub->period -= (100 * 10000);
-
-		// Recalculate aligned period
-		framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
-		_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
-
-        // Release the previous allocations
-        SAFE_RELEASE(audioClient);
-
-        // Create a new audio client
-        hr = IMMDevice_Activate(pInfo->device, &pa_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&audioClient);
-    	if (hr != S_OK)
-		{
-			(*pa_error) = paInsufficientMemory;
-			LogHostError(hr);
-			goto done;
-		}
-
-		// Open the stream and associate it with an audio session
-		hr = IAudioClient_Initialize(audioClient,
-			pSub->shareMode,
-			pSub->streamFlags,
-			pSub->period,
-			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
-			&pSub->wavex.Format,
-			NULL);
-	}
-
-	/*! WASAPI buffer size failure. Fallback to using default size.
-	*/
-	if (hr == AUDCLNT_E_BUFFER_SIZE_ERROR)
-	{
-		// Use default
-		pSub->period = pInfo->DefaultDevicePeriod;
-
-		PRINT(("WASAPI: CreateAudioClient: correcting buffer size to device default\n"));
-
-        // Release the previous allocations
-        SAFE_RELEASE(audioClient);
-
-        // Create a new audio client
-        hr = IMMDevice_Activate(pInfo->device, &pa_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&audioClient);
-    	if (hr != S_OK)
-		{
-			(*pa_error) = paInsufficientMemory;
-			LogHostError(hr);
-			goto done;
-		}
-
-		// Open the stream and associate it with an audio session
-		hr = IAudioClient_Initialize(audioClient,
-			pSub->shareMode,
-			pSub->streamFlags,
-			pSub->period,
-			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
-			&pSub->wavex.Format,
-			NULL);
-	}
-
-    /*! If the requested buffer size is not aligned. Can be triggered by Windows 7 and up.
-	    Should not be be triggered ever as we do align buffers always with _CalculateAlignedPeriod.
-	*/
-    if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED)
-    {
-		UINT32 frames = 0;
-
-        // Get the next aligned frame
-        hr = IAudioClient_GetBufferSize(audioClient, &frames);
-		if (hr != S_OK)
-		{
-			(*pa_error) = paInvalidDevice;
-			LogHostError(hr);
-			goto done;
-		}
-
-		PRINT(("WASAPI: CreateAudioClient: aligning buffer size to % frames\n", frames));
-
-        // Release the previous allocations
-        SAFE_RELEASE(audioClient);
-
-        // Create a new audio client
-        hr = IMMDevice_Activate(pInfo->device, &pa_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&audioClient);
-    	if (hr != S_OK)
-		{
-			(*pa_error) = paInsufficientMemory;
-			LogHostError(hr);
-			goto done;
-		}
-
-		// Get closest format
-		if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
-		{
-			(*pa_error) = error;
-			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT); // fail, format not supported
-			goto done;
-		}
-
-		// Check for Mono >> Stereo workaround
-		if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
-		{
-			/*if (blocking)
-			{
-				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
-				goto done; // fail, blocking mode not supported
-			}*/
-
-			// Select mixer
-			pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
-			if (pSub->monoMixer == NULL)
-			{
-				(*pa_error) = paInvalidChannelCount;
-				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
-				goto done; // fail, no mixer for format
-			}
-		}
-
-		// Calculate period
-		pSub->period = MakeHnsPeriod(frames, pSub->wavex.Format.nSamplesPerSec);
-
-        // Open the stream and associate it with an audio session
-        hr = IAudioClient_Initialize(audioClient,
-            pSub->shareMode,
-            pSub->streamFlags,
-			pSub->period,
-			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
-            &pSub->wavex.Format,
-            NULL);
-    	if (hr != S_OK)
-		{
-			(*pa_error) = paInvalidDevice;
-			LogHostError(hr);
-			goto done;
-		}
-    }
-    else
-	if (hr != S_OK)
-    {
-		(*pa_error) = paInvalidDevice;
-		LogHostError(hr);
-		goto done;
-    }
-
-    // Set client
-	pSub->clientParent = audioClient;
-    IAudioClient_AddRef(pSub->clientParent);
-
-	// Recalculate buffers count
-	_RecalculateBuffersCount(pSub,
-		userFramesPerBuffer,
-		MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec),
-		fullDuplex);
-
-	// No error, client is succesfully created
-	(*pa_error) = paNoError;
-
-done:
-
-    // Clean up
-    SAFE_RELEASE(audioClient);
-    return hr;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError ActivateAudioClientOutput(PaWasapiStream *stream)
-{
-	HRESULT hr;
-	PaError result;
-
-	UINT32 maxBufferSize   = 0;
-	PaTime buffer_latency  = 0;
-	UINT32 framesPerBuffer = stream->out.params.frames_per_buffer;
-
-	// Create Audio client
-	hr = CreateAudioClient(stream, &stream->out, TRUE, &result);
-    if (hr != S_OK)
-	{
-		LogPaError(result);
-		goto error;
-    }
-	LogWAVEFORMATEXTENSIBLE(&stream->out.wavex);
-
-	// Activate volume
-	stream->outVol = NULL;
-    /*hr = info->device->Activate(
-        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
-        (void**)&stream->outVol);
-    if (hr != S_OK)
-        return paInvalidDevice;*/
-
-    // Get max possible buffer size to check if it is not less than that we request
-    hr = IAudioClient_GetBufferSize(stream->out.clientParent, &maxBufferSize);
-    if (hr != S_OK)
-	{
-		LogHostError(hr);
-		LogPaError(result = paInvalidDevice);
-		goto error;
-	}
-
-    // Correct buffer to max size if it maxed out result of GetBufferSize
-	stream->out.bufferSize = maxBufferSize;
-
-	// Get interface latency (actually uneeded as we calculate latency from the size
-	// of maxBufferSize).
-    hr = IAudioClient_GetStreamLatency(stream->out.clientParent, &stream->out.deviceLatency);
-    if (hr != S_OK)
-	{
-		LogHostError(hr);
-		LogPaError(result = paInvalidDevice);
-		goto error;
-	}
-	//stream->out.latencySeconds = nano100ToSeconds(stream->out.deviceLatency);
-
-    // Number of frames that are required at each period
-	stream->out.framesPerHostCallback = maxBufferSize;
-
-	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
-	stream->out.framesPerBuffer =
-		(stream->out.userBufferAndHostMatch ? stream->out.framesPerHostCallback : framesPerBuffer);
-
-	// Calculate buffer latency
-	buffer_latency = (PaTime)maxBufferSize / stream->out.wavex.Format.nSamplesPerSec;
-
-	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
-	stream->out.latencySeconds = buffer_latency;
-
-	PRINT(("WASAPI::OpenStream(output): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->out.framesPerHostCallback, (float)(stream->out.latencySeconds*1000.0f), (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->out.params.wow64_workaround ? "YES" : "NO"), (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));
-
-	return paNoError;
-
-error:
-
-	return result;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError ActivateAudioClientInput(PaWasapiStream *stream)
-{
-	HRESULT hr;
-	PaError result;
-
-	UINT32 maxBufferSize   = 0;
-	PaTime buffer_latency  = 0;
-	UINT32 framesPerBuffer = stream->in.params.frames_per_buffer;
-
-	// Create Audio client
-	hr = CreateAudioClient(stream, &stream->in, FALSE, &result);
-    if (hr != S_OK)
-	{
-		LogPaError(result);
-		goto error;
-    }
-	LogWAVEFORMATEXTENSIBLE(&stream->in.wavex);
-
-	// Create volume mgr
-	stream->inVol = NULL;
-    /*hr = info->device->Activate(
-        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
-        (void**)&stream->inVol);
-    if (hr != S_OK)
-        return paInvalidDevice;*/
-
-    // Get max possible buffer size to check if it is not less than that we request
-    hr = IAudioClient_GetBufferSize(stream->in.clientParent, &maxBufferSize);
-    if (hr != S_OK)
-	{
-		LogHostError(hr);
-		LogPaError(result = paInvalidDevice);
-		goto error;
-	}
-
-    // Correct buffer to max size if it maxed out result of GetBufferSize
-	stream->in.bufferSize = maxBufferSize;
-
-	// Get interface latency (actually uneeded as we calculate latency from the size
-	// of maxBufferSize).
-    hr = IAudioClient_GetStreamLatency(stream->in.clientParent, &stream->in.deviceLatency);
-    if (hr != S_OK)
-	{
-		LogHostError(hr);
-		LogPaError(result = paInvalidDevice);
-		goto error;
-	}
-	//stream->in.latencySeconds = nano100ToSeconds(stream->in.deviceLatency);
-
-    // Number of frames that are required at each period
-	stream->in.framesPerHostCallback = maxBufferSize;
-
-	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
-	stream->in.framesPerBuffer =
-		(stream->in.userBufferAndHostMatch ? stream->in.framesPerHostCallback : framesPerBuffer);
-
-	// Calculate buffer latency
-	buffer_latency = (PaTime)maxBufferSize / stream->in.wavex.Format.nSamplesPerSec;
-
-	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
-	stream->in.latencySeconds = buffer_latency;
-
-	PRINT(("WASAPI::OpenStream(input): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->in.framesPerHostCallback, (float)(stream->in.latencySeconds*1000.0f), (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->in.params.wow64_workaround ? "YES" : "NO"), (stream->in.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));
-
-	return paNoError;
-
-error:
-
-	return result;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
-                           PaStream** s,
-                           const PaStreamParameters *inputParameters,
-                           const PaStreamParameters *outputParameters,
-                           double sampleRate,
-                           unsigned long framesPerBuffer,
-                           PaStreamFlags streamFlags,
-                           PaStreamCallback *streamCallback,
-                           void *userData )
-{
-    PaError result = paNoError;
-	HRESULT hr;
-    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
-    PaWasapiStream *stream = NULL;
-    int inputChannelCount, outputChannelCount;
-    PaSampleFormat inputSampleFormat, outputSampleFormat;
-    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
-	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;
-	PaWasapiDeviceInfo *info = NULL;
-	ULONG framesPerHostCallback;
-	PaUtilHostBufferSizeMode bufferMode;
-	const BOOL fullDuplex = ((inputParameters != NULL) && (outputParameters != NULL));
-
-	// validate PaStreamParameters
-	if ((result = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
-		return LogPaError(result);
-
-    // Validate platform specific flags
-    if ((streamFlags & paPlatformSpecificFlags) != 0)
-	{
-		LogPaError(result = paInvalidFlag); /* unexpected platform specific flag */
-		goto error;
-	}
-
-	// Allocate memory for PaWasapiStream
-    if ((stream = (PaWasapiStream *)PaUtil_AllocateMemory(sizeof(PaWasapiStream))) == NULL)
-	{
-        LogPaError(result = paInsufficientMemory);
-        goto error;
-    }
-
-	// Default thread priority is Audio: for exclusive mode we will use Pro Audio.
-	stream->nThreadPriority = eThreadPriorityAudio;
-
-	// Set default number of frames: paFramesPerBufferUnspecified
-	if (framesPerBuffer == paFramesPerBufferUnspecified)
-	{
-		UINT32 framesPerBufferIn  = 0, framesPerBufferOut = 0;
-		if (inputParameters != NULL)
-		{
-			info = &paWasapi->devInfo[inputParameters->device];
-			framesPerBufferIn = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
-		}
-		if (outputParameters != NULL)
-		{
-			info = &paWasapi->devInfo[outputParameters->device];
-			framesPerBufferOut = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
-		}
-		// choosing maximum default size
-		framesPerBuffer = max(framesPerBufferIn, framesPerBufferOut);
-	}
-	if (framesPerBuffer == 0)
-		framesPerBuffer = ((UINT32)sampleRate / 100) * 2;
-
-	// Try create device: Input
-	if (inputParameters != NULL)
-    {
-        inputChannelCount = inputParameters->channelCount;
-        inputSampleFormat = inputParameters->sampleFormat;
-		inputStreamInfo   = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
-        info              = &paWasapi->devInfo[inputParameters->device];
-		stream->in.flags  = (inputStreamInfo ? inputStreamInfo->flags : 0);
-
-		// Select Exclusive/Shared mode
-		stream->in.shareMode = AUDCLNT_SHAREMODE_SHARED;
-        if ((inputStreamInfo != NULL) && (inputStreamInfo->flags & paWinWasapiExclusive))
-		{
-			// Boost thread priority
-			stream->nThreadPriority = eThreadPriorityProAudio;
-			// Make Exclusive
-			stream->in.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
-		}
-
-		// If user provided explicit thread priority level, use it
-        if ((inputStreamInfo != NULL) && (inputStreamInfo->flags & paWinWasapiThreadPriority))
-		{
-			if ((inputStreamInfo->threadPriority > eThreadPriorityNone) &&
-				(inputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
-				stream->nThreadPriority = inputStreamInfo->threadPriority;
-		}
-
-		// Choose processing mode
-		stream->in.streamFlags = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
-		if (paWasapi->useWOW64Workaround)
-			stream->in.streamFlags = 0; // polling interface
-		else
-		if (streamCallback == NULL)
-			stream->in.streamFlags = 0; // polling interface
-		else
-		if ((inputStreamInfo != NULL) && (inputStreamInfo->flags & paWinWasapiPolling))
-			stream->in.streamFlags = 0; // polling interface
-		else
-		if (fullDuplex)
-			stream->in.streamFlags = 0; // polling interface is implemented for full-duplex mode also
-
-		// Fill parameters for Audio Client creation
-		stream->in.params.device_info       = info;
-		stream->in.params.stream_params     = (*inputParameters);
-		if (inputStreamInfo != NULL)
-		{
-			stream->in.params.wasapi_params = (*inputStreamInfo);
-			stream->in.params.stream_params.hostApiSpecificStreamInfo = &stream->in.params.wasapi_params;
-		}
-		stream->in.params.frames_per_buffer = framesPerBuffer;
-		stream->in.params.sample_rate       = sampleRate;
-		stream->in.params.blocking          = (streamCallback == NULL);
-		stream->in.params.full_duplex       = fullDuplex;
-		stream->in.params.wow64_workaround  = paWasapi->useWOW64Workaround;
-
-		// Create and activate audio client
-		hr = ActivateAudioClientInput(stream);
-        if (hr != S_OK)
-		{
-			LogPaError(result = paInvalidDevice);
-			goto error;
-        }
-
-		// Get closest format
-        hostInputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->in.wavex), inputSampleFormat );
-
-        // Set user-side custom host processor
-        if ((inputStreamInfo != NULL) &&
-            (inputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
-        {
-            stream->hostProcessOverrideInput.processor = inputStreamInfo->hostProcessorInput;
-            stream->hostProcessOverrideInput.userData = userData;
-        }
-
-		// Only get IAudioCaptureClient input once here instead of getting it at multiple places based on the use
-		hr = IAudioClient_GetService(stream->in.clientParent, &pa_IID_IAudioCaptureClient, (void **)&stream->captureClientParent);
-		if (hr != S_OK)
-		{
-			LogHostError(hr);
-			LogPaError(result = paUnanticipatedHostError);
-			goto error;
-		}
-
-		// Create ring buffer for blocking mode (It is needed because we fetch Input packets, not frames,
-		// and thus we have to save partial packet if such remains unread)
-		if (stream->in.params.blocking == TRUE)
-		{
-			UINT32 bufferFrames = ALIGN_NEXT_POW2((stream->in.framesPerHostCallback / WASAPI_PACKETS_PER_INPUT_BUFFER) * 2);
-			UINT32 frameSize    = stream->in.wavex.Format.nBlockAlign;
-
-			// buffer
-			if ((stream->in.tailBuffer = PaUtil_AllocateMemory(sizeof(PaUtilRingBuffer))) == NULL)
-			{
-				LogPaError(result = paInsufficientMemory);
-				goto error;
-			}
-			memset(stream->in.tailBuffer, 0, sizeof(PaUtilRingBuffer));
-
-			// buffer memory region
-			stream->in.tailBufferMemory = PaUtil_AllocateMemory(frameSize * bufferFrames);
-			if (stream->in.tailBufferMemory == NULL)
-			{
-				LogPaError(result = paInsufficientMemory);
-				goto error;
-			}
-
-			// initialize
-			if (PaUtil_InitializeRingBuffer(stream->in.tailBuffer, frameSize, bufferFrames,	stream->in.tailBufferMemory) != 0)
-			{
-				LogPaError(result = paInternalError);
-				goto error;
-			}
-		}
-	}
-    else
-    {
-        inputChannelCount = 0;
-        inputSampleFormat = hostInputSampleFormat = paInt16; /* Surpress 'uninitialised var' warnings. */
-    }
-
-	// Try create device: Output
-    if (outputParameters != NULL)
-    {
-        outputChannelCount = outputParameters->channelCount;
-        outputSampleFormat = outputParameters->sampleFormat;
-		outputStreamInfo   = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
-		info               = &paWasapi->devInfo[outputParameters->device];
-		stream->out.flags  = (outputStreamInfo ? outputStreamInfo->flags : 0);
-
-		// Select Exclusive/Shared mode
-		stream->out.shareMode = AUDCLNT_SHAREMODE_SHARED;
-        if ((outputStreamInfo != NULL) && (outputStreamInfo->flags & paWinWasapiExclusive))
-		{
-			// Boost thread priority
-			stream->nThreadPriority = eThreadPriorityProAudio;
-			// Make Exclusive
-			stream->out.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
-		}
-
-		// If user provided explicit thread priority level, use it
-        if ((outputStreamInfo != NULL) && (outputStreamInfo->flags & paWinWasapiThreadPriority))
-		{
-			if ((outputStreamInfo->threadPriority > eThreadPriorityNone) &&
-				(outputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
-				stream->nThreadPriority = outputStreamInfo->threadPriority;
-		}
-
-		// Choose processing mode
-		stream->out.streamFlags = (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
-		if (paWasapi->useWOW64Workaround)
-			stream->out.streamFlags = 0; // polling interface
-		else
-		if (streamCallback == NULL)
-			stream->out.streamFlags = 0; // polling interface
-		else
-		if ((outputStreamInfo != NULL) && (outputStreamInfo->flags & paWinWasapiPolling))
-			stream->out.streamFlags = 0; // polling interface
-		else
-		if (fullDuplex)
-			stream->out.streamFlags = 0; // polling interface is implemented for full-duplex mode also
-
-		// Fill parameters for Audio Client creation
-		stream->out.params.device_info       = info;
-		stream->out.params.stream_params     = (*outputParameters);
-		if (inputStreamInfo != NULL)
-		{
-			stream->out.params.wasapi_params = (*outputStreamInfo);
-			stream->out.params.stream_params.hostApiSpecificStreamInfo = &stream->out.params.wasapi_params;
-		}
-		stream->out.params.frames_per_buffer = framesPerBuffer;
-		stream->out.params.sample_rate       = sampleRate;
-		stream->out.params.blocking          = (streamCallback == NULL);
-		stream->out.params.full_duplex       = fullDuplex;
-		stream->out.params.wow64_workaround  = paWasapi->useWOW64Workaround;
-
-		// Create and activate audio client
-		hr = ActivateAudioClientOutput(stream);
-        if (hr != S_OK)
-		{
-			LogPaError(result = paInvalidDevice);
-			goto error;
-        }
-
-		// Get closest format
-        hostOutputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->out.wavex), outputSampleFormat );
-
-        // Set user-side custom host processor
-        if ((outputStreamInfo != NULL) &&
-            (outputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
-        {
-            stream->hostProcessOverrideOutput.processor = outputStreamInfo->hostProcessorOutput;
-            stream->hostProcessOverrideOutput.userData = userData;
-        }
-
-		// Only get IAudioCaptureClient output once here instead of getting it at multiple places based on the use
-		hr = IAudioClient_GetService(stream->out.clientParent, &pa_IID_IAudioRenderClient, (void **)&stream->renderClientParent);
-		if (hr != S_OK)
-		{
-			LogHostError(hr);
-			LogPaError(result = paUnanticipatedHostError);
-			goto error;
-		}
-	}
-    else
-    {
-        outputChannelCount = 0;
-        outputSampleFormat = hostOutputSampleFormat = paInt16; /* Surpress 'uninitialized var' warnings. */
-    }
-
-	// log full-duplex
-	if (fullDuplex)
-		PRINT(("WASAPI::OpenStream: full-duplex mode\n"));
-
-	// paWinWasapiPolling must be on/or not on both streams
-	if ((inputParameters != NULL) && (outputParameters != NULL))
-	{
-		if ((inputStreamInfo != NULL) && (outputStreamInfo != NULL))
-		{
-			if (((inputStreamInfo->flags & paWinWasapiPolling) &&
-				!(outputStreamInfo->flags & paWinWasapiPolling))
-				||
-				(!(inputStreamInfo->flags & paWinWasapiPolling) &&
-				 (outputStreamInfo->flags & paWinWasapiPolling)))
-			{
-				LogPaError(result = paInvalidFlag);
-				goto error;
-			}
-		}
-	}
-
-	// Initialize stream representation
-    if (streamCallback)
-    {
-		stream->bBlocking = FALSE;
-        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
-                                              &paWasapi->callbackStreamInterface,
-											  streamCallback, userData);
-    }
-    else
-    {
-		stream->bBlocking = TRUE;
-        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
-                                              &paWasapi->blockingStreamInterface,
-											  streamCallback, userData);
-    }
-
-	// Initialize CPU measurer
-    PaUtil_InitializeCpuLoadMeasurer(&stream->cpuLoadMeasurer, sampleRate);
-
-	if (outputParameters && inputParameters)
-	{
-		// serious problem #1 - No, Not a problem, especially concerning Exclusive mode.
-		// Input device in exclusive mode somehow is getting large buffer always, thus we
-		// adjust Output latency to reflect it, thus period will differ but playback will be
-		// normal.
-		/*if (stream->in.period != stream->out.period)
-		{
-			PRINT(("WASAPI: OpenStream: period discrepancy\n"));
-			LogPaError(result = paBadIODeviceCombination);
-			goto error;
-		}*/
-
-		// serious problem #2 - No, Not a problem, as framesPerHostCallback take into account
-		// sample size while it is not a problem for PA full-duplex, we must care of
-		// preriod only!
-		/*if (stream->out.framesPerHostCallback != stream->in.framesPerHostCallback)
-		{
-			PRINT(("WASAPI: OpenStream: framesPerHostCallback discrepancy\n"));
-			goto error;
-		}*/
-	}
-
-	// Calculate frames per host for processor
-	framesPerHostCallback = (outputParameters ? stream->out.framesPerBuffer : stream->in.framesPerBuffer);
-
-	// Choose correct mode of buffer processing:
-	// Exclusive/Shared non paWinWasapiPolling mode: paUtilFixedHostBufferSize - always fixed
-	// Exclusive/Shared paWinWasapiPolling mode: paUtilBoundedHostBufferSize - may vary for Exclusive or Full-duplex
-	bufferMode = paUtilFixedHostBufferSize;
-	if (inputParameters) // !!! WASAPI IAudioCaptureClient::GetBuffer extracts not number of frames but 1 packet, thus we always must adapt
-		bufferMode = paUtilBoundedHostBufferSize;
-	else
-	if (outputParameters)
-	{
-		if ((stream->out.buffers == 1) &&
-			(!stream->out.streamFlags || ((stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
-			bufferMode = paUtilBoundedHostBufferSize;
-	}
-	stream->bufferMode = bufferMode;
-
-    // Initialize buffer processor
-    result =  PaUtil_InitializeBufferProcessor(
-		&stream->bufferProcessor,
-        inputChannelCount,
-		inputSampleFormat,
-		hostInputSampleFormat,
-        outputChannelCount,
-		outputSampleFormat,
-		hostOutputSampleFormat,
-        sampleRate,
-		streamFlags,
-		framesPerBuffer,
-        framesPerHostCallback,
-		bufferMode,
-        streamCallback,
-		userData);
-    if (result != paNoError)
-	{
-		LogPaError(result);
-        goto error;
-	}
-
-	// Set Input latency
-    stream->streamRepresentation.streamInfo.inputLatency =
-            ((double)PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor) / sampleRate)
-			+ ((inputParameters)?stream->in.latencySeconds : 0);
-
-	// Set Output latency
-    stream->streamRepresentation.streamInfo.outputLatency =
-            ((double)PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor) / sampleRate)
-			+ ((outputParameters)?stream->out.latencySeconds : 0);
-
-	// Set SR
-    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;
-
-    (*s) = (PaStream *)stream;
-    return result;
-
-error:
-
-    if (stream != NULL)
-		CloseStream(stream);
-
-    return result;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError CloseStream( PaStream* s )
-{
-    PaError result = paNoError;
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-
-	// abort active stream
-	if (IsStreamActive(s))
-	{
-		result = AbortStream(s);
-	}
-
-    SAFE_RELEASE(stream->captureClientParent);
-    SAFE_RELEASE(stream->renderClientParent);
-    SAFE_RELEASE(stream->out.clientParent);
-    SAFE_RELEASE(stream->in.clientParent);
-	SAFE_RELEASE(stream->inVol);
-	SAFE_RELEASE(stream->outVol);
-
-	CloseHandle(stream->event[S_INPUT]);
-	CloseHandle(stream->event[S_OUTPUT]);
-
-	_StreamCleanup(stream);
-
-	PaWasapi_FreeMemory(stream->in.monoBuffer);
-	PaWasapi_FreeMemory(stream->out.monoBuffer);
-
-	PaUtil_FreeMemory(stream->in.tailBuffer);
-	PaUtil_FreeMemory(stream->in.tailBufferMemory);
-
-	PaUtil_FreeMemory(stream->out.tailBuffer);
-	PaUtil_FreeMemory(stream->out.tailBufferMemory);
-
-    PaUtil_TerminateBufferProcessor(&stream->bufferProcessor);
-    PaUtil_TerminateStreamRepresentation(&stream->streamRepresentation);
-    PaUtil_FreeMemory(stream);
-
-    return result;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT UnmarshalSubStreamComPointers(PaWasapiSubStream *substream) 
-{
-	HRESULT hResult = S_OK;
-	HRESULT hFirstBadResult = S_OK;
-	substream->clientProc = NULL;
-
-	// IAudioClient
-	hResult = CoGetInterfaceAndReleaseStream(substream->clientStream, &pa_IID_IAudioClient, (LPVOID*)&substream->clientProc);
-	substream->clientStream = NULL;
-	if (hResult != S_OK) 
-	{
-		hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
-	}
-
-	return hFirstBadResult;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT UnmarshalStreamComPointers(PaWasapiStream *stream) 
-{
-	HRESULT hResult = S_OK;
-	HRESULT hFirstBadResult = S_OK;
-	stream->captureClient = NULL;
-	stream->renderClient = NULL;
-	stream->in.clientProc = NULL;
-	stream->out.clientProc = NULL;
-
-	if (NULL != stream->in.clientParent) 
-	{
-		// SubStream pointers
-		hResult = UnmarshalSubStreamComPointers(&stream->in);
-		if (hResult != S_OK) 
-		{
-			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
-		}
-
-		// IAudioCaptureClient
-		hResult = CoGetInterfaceAndReleaseStream(stream->captureClientStream, &pa_IID_IAudioCaptureClient, (LPVOID*)&stream->captureClient);
-		stream->captureClientStream = NULL;
-		if (hResult != S_OK) 
-		{
-			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
-		}
-	}
-
-	if (NULL != stream->out.clientParent) 
-	{
-		// SubStream pointers
-		hResult = UnmarshalSubStreamComPointers(&stream->out);
-		if (hResult != S_OK) 
-		{
-			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
-		}
-
-		// IAudioRenderClient
-		hResult = CoGetInterfaceAndReleaseStream(stream->renderClientStream, &pa_IID_IAudioRenderClient, (LPVOID*)&stream->renderClient);
-		stream->renderClientStream = NULL;
-		if (hResult != S_OK) 
-		{
-			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
-		}
-	}
-
-	return hFirstBadResult;
-}
-
-// -----------------------------------------------------------------------------------------
-void ReleaseUnmarshaledSubComPointers(PaWasapiSubStream *substream) 
-{
-	SAFE_RELEASE(substream->clientProc);
-}
-
-// -----------------------------------------------------------------------------------------
-void ReleaseUnmarshaledComPointers(PaWasapiStream *stream) 
-{
-	// Release AudioClient services first
-	SAFE_RELEASE(stream->captureClient);
-	SAFE_RELEASE(stream->renderClient);
-
-	// Release AudioClients
-	ReleaseUnmarshaledSubComPointers(&stream->in);
-	ReleaseUnmarshaledSubComPointers(&stream->out);
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT MarshalSubStreamComPointers(PaWasapiSubStream *substream) 
-{
-	HRESULT hResult;
-	substream->clientStream = NULL;
-
-	// IAudioClient
-	hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioClient, (LPUNKNOWN)substream->clientParent, &substream->clientStream);
-	if (hResult != S_OK)
-		goto marshal_sub_error;
-
-	return hResult;
-
-	// If marshaling error occurred, make sure to release everything.
-marshal_sub_error:
-
-	UnmarshalSubStreamComPointers(substream);
-	ReleaseUnmarshaledSubComPointers(substream);
-	return hResult;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT MarshalStreamComPointers(PaWasapiStream *stream) 
-{
-	HRESULT hResult = S_OK;
-	stream->captureClientStream = NULL;
-	stream->in.clientStream = NULL;
-	stream->renderClientStream = NULL;
-	stream->out.clientStream = NULL;
-
-	if (NULL != stream->in.clientParent) 
-	{
-		// SubStream pointers
-		hResult = MarshalSubStreamComPointers(&stream->in);
-		if (hResult != S_OK) 
-			goto marshal_error;
-
-		// IAudioCaptureClient
-		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioCaptureClient, (LPUNKNOWN)stream->captureClientParent, &stream->captureClientStream);
-		if (hResult != S_OK) 
-			goto marshal_error;
-	}
-
-	if (NULL != stream->out.clientParent) 
-	{
-		// SubStream pointers
-		hResult = MarshalSubStreamComPointers(&stream->out);
-		if (hResult != S_OK) 
-			goto marshal_error;
-
-		// IAudioRenderClient
-		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioRenderClient, (LPUNKNOWN)stream->renderClientParent, &stream->renderClientStream);
-		if (hResult != S_OK) 
-			goto marshal_error;
-	}
-
-	return hResult;
-
-	// If marshaling error occurred, make sure to release everything.
-marshal_error:
-
-	UnmarshalStreamComPointers(stream);
-	ReleaseUnmarshaledComPointers(stream);
-	return hResult;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError StartStream( PaStream *s )
-{
-	HRESULT hr;
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-	PaError result = paNoError;
-
-	// check if stream is active already
-	if (IsStreamActive(s))
-		return paStreamIsNotStopped;
-
-    PaUtil_ResetBufferProcessor(&stream->bufferProcessor);
-
-	// Cleanup handles (may be necessary if stream was stopped by itself due to error)
-	_StreamCleanup(stream);
-
-	// Create close event
-	if ((stream->hCloseRequest = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) 
-	{
-		result = paInsufficientMemory;
-		goto start_error;
-	}
-
-	// Create thread
-	if (!stream->bBlocking)
-	{
-		// Create thread events
-		stream->hThreadStart = CreateEvent(NULL, TRUE, FALSE, NULL);
-		stream->hThreadExit  = CreateEvent(NULL, TRUE, FALSE, NULL);
-		if ((stream->hThreadStart == NULL) || (stream->hThreadExit == NULL))
-		{
-			result = paInsufficientMemory;
-			goto start_error;
-		}
-
-		// Marshal WASAPI interface pointers for safe use in thread created below.
-		if ((hr = MarshalStreamComPointers(stream)) != S_OK) 
-		{
-			PRINT(("Failed marshaling stream COM pointers."));
-			result = paUnanticipatedHostError;
-			goto nonblocking_start_error;
-		}
-
-		if ((stream->in.clientParent  && (stream->in.streamFlags  & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)) ||
-			(stream->out.clientParent && (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)))
-		{
-			if ((stream->hThread = CREATE_THREAD(ProcThreadEvent)) == NULL) 
-			{
-				PRINT(("Failed creating thread: ProcThreadEvent."));
-				result = paUnanticipatedHostError;
-				goto nonblocking_start_error;
-			}
-		}
-		else
-		{
-			if ((stream->hThread = CREATE_THREAD(ProcThreadPoll)) == NULL) 
-			{
-				PRINT(("Failed creating thread: ProcThreadPoll."));
-				result = paUnanticipatedHostError;
-				goto nonblocking_start_error;
-			}
-		}
-
-		// Wait for thread to start
-		if (WaitForSingleObject(stream->hThreadStart, 60*1000) == WAIT_TIMEOUT) 
-		{
-			PRINT(("Failed starting thread: timeout."));
-			result = paUnanticipatedHostError;
-			goto nonblocking_start_error;
-		}
-	}
-	else
-	{
-		// Create blocking operation events (non-signaled event means - blocking operation is pending)
-		if (stream->out.clientParent != NULL) 
-		{
-			if ((stream->hBlockingOpStreamWR = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
-			{
-				result = paInsufficientMemory;
-				goto start_error;
-			}
-		}
-		if (stream->in.clientParent != NULL) 
-		{
-			if ((stream->hBlockingOpStreamRD = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
-			{
-				result = paInsufficientMemory;
-				goto start_error;
-			}
-		}
-
-		// Initialize event & start INPUT stream
-		if (stream->in.clientParent != NULL)
-		{
-			if ((hr = IAudioClient_Start(stream->in.clientParent)) != S_OK)
-			{
-				LogHostError(hr);
-				result = paUnanticipatedHostError;
-				goto start_error;
-			}
-		}
-
-		// Initialize event & start OUTPUT stream
-		if (stream->out.clientParent != NULL)
-		{
-			// Start
-			if ((hr = IAudioClient_Start(stream->out.clientParent)) != S_OK)
-			{
-				LogHostError(hr);
-				result = paUnanticipatedHostError;
-				goto start_error;
-			}
-		}
-
-		// Set parent to working pointers to use shared functions.
-		stream->captureClient  = stream->captureClientParent;
-		stream->renderClient   = stream->renderClientParent;
-		stream->in.clientProc  = stream->in.clientParent;
-		stream->out.clientProc = stream->out.clientParent;
-
-		// Signal: stream running.
-		stream->running = TRUE;
-	}
-
-    return result;
-
-nonblocking_start_error:
-
-	// Set hThreadExit event to prevent blocking during cleanup
-	SetEvent(stream->hThreadExit);
-	UnmarshalStreamComPointers(stream);
-	ReleaseUnmarshaledComPointers(stream);
-
-start_error:
-
-	StopStream(s);
-	return result;
-}
-
-// ------------------------------------------------------------------------------------------
-void _StreamFinish(PaWasapiStream *stream)
-{
-	// Issue command to thread to stop processing and wait for thread exit
-	if (!stream->bBlocking)
-	{
-		SignalObjectAndWait(stream->hCloseRequest, stream->hThreadExit, INFINITE, FALSE);
-	}
-	else
-	// Blocking mode does not own thread
-	{
-		// Signal close event and wait for each of 2 blocking operations to complete
-		if (stream->out.clientParent)
-			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamWR, INFINITE, TRUE);
-		if (stream->out.clientParent)
-			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamRD, INFINITE, TRUE);
-
-		// Process stop
-		_StreamOnStop(stream);
-	}
-
-	// Cleanup handles
-	_StreamCleanup(stream);
-
-    stream->running = FALSE;
-}
-
-// ------------------------------------------------------------------------------------------
-void _StreamCleanup(PaWasapiStream *stream)
-{
-	// Close thread handles to allow restart
-	SAFE_CLOSE(stream->hThread);
-	SAFE_CLOSE(stream->hThreadStart);
-	SAFE_CLOSE(stream->hThreadExit);
-	SAFE_CLOSE(stream->hCloseRequest);
-	SAFE_CLOSE(stream->hBlockingOpStreamRD);
-	SAFE_CLOSE(stream->hBlockingOpStreamWR);
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError StopStream( PaStream *s )
-{
-	// Finish stream
-	_StreamFinish((PaWasapiStream *)s);
-    return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError AbortStream( PaStream *s )
-{
-	// Finish stream
-	_StreamFinish((PaWasapiStream *)s);
-    return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError IsStreamStopped( PaStream *s )
-{
-	return !((PaWasapiStream *)s)->running;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError IsStreamActive( PaStream *s )
-{
-    return ((PaWasapiStream *)s)->running;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaTime GetStreamTime( PaStream *s )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-
-    /* suppress unused variable warnings */
-    (void) stream;
-
-    return PaUtil_GetTime();
-}
-
-// ------------------------------------------------------------------------------------------
-static double GetStreamCpuLoad( PaStream* s )
-{
-	return PaUtil_GetCpuLoad(&((PaWasapiStream *)s)->cpuLoadMeasurer);
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError ReadStream( PaStream* s, void *_buffer, unsigned long frames )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-
-	HRESULT hr = S_OK;
-	BYTE *user_buffer = (BYTE *)_buffer;
-	BYTE *wasapi_buffer = NULL;
-	DWORD flags = 0;
-	UINT32 i, available, sleep = 0;
-	unsigned long processed;
-	ThreadIdleScheduler sched;
-
-	// validate
-	if (!stream->running)
-		return paStreamIsStopped;
-	if (stream->captureClient == NULL)
-		return paBadStreamPtr;
-
-	// Notify blocking op has begun
-	ResetEvent(stream->hBlockingOpStreamRD);
-
-	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
-	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
-	ThreadIdleScheduler_Setup(&sched, 1, 250/* microseconds */);
-
-    // Make a local copy of the user buffer pointer(s), this is necessary
-	// because PaUtil_CopyOutput() advances these pointers every time it is called
-    if (!stream->bufferProcessor.userInputIsInterleaved)
-    {
-		user_buffer = (BYTE *)alloca(sizeof(BYTE *) * stream->bufferProcessor.inputChannelCount);
-        if (user_buffer == NULL)
-            return paInsufficientMemory;
-
-        for (i = 0; i < stream->bufferProcessor.inputChannelCount; ++i)
-            ((BYTE **)user_buffer)[i] = ((BYTE **)_buffer)[i];
-    }
-
-	// Findout if there are tail frames, flush them all before reading hardware
-	if ((available = PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer)) != 0)
-	{
-		ring_buffer_size_t buf1_size = 0, buf2_size = 0, read, desired;
-		void *buf1 = NULL, *buf2 = NULL;
-
-		// Limit desired to amount of requested frames
-		desired = available;
-		if ((UINT32)desired > frames)
-			desired = frames;
-		
-		// Get pointers to read regions
-		read = PaUtil_GetRingBufferReadRegions(stream->in.tailBuffer, desired, &buf1, &buf1_size, &buf2, &buf2_size);
-
-		if (buf1 != NULL)
-		{
-			// Register available frames to processor
-			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf1_size);
-
-			// Register host buffer pointer to processor
-			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf1, stream->bufferProcessor.inputChannelCount);
-
-			// Copy user data to host buffer (with conversion if applicable)
-			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf1_size);
-			frames -= processed;
-		}
-
-		if (buf2 != NULL)
-		{
-			// Register available frames to processor
-			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf2_size);
-
-			// Register host buffer pointer to processor
-			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf2, stream->bufferProcessor.inputChannelCount);
-
-			// Copy user data to host buffer (with conversion if applicable)
-			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf2_size);
-			frames -= processed;
-		}
-
-		// Advance
-		PaUtil_AdvanceRingBufferReadIndex(stream->in.tailBuffer, read);
-	}
-
-	// Read hardware
-	while (frames != 0)
-	{
-		// Check if blocking call must be interrupted
-		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
-			break;
-
-		// Get available frames (must be finding out available frames before call to IAudioCaptureClient_GetBuffer
-		// othervise audio glitches will occur inExclusive mode as it seems that WASAPI has some scheduling/
-		// processing problems when such busy polling with IAudioCaptureClient_GetBuffer occurs)
-		if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
-		{
-			LogHostError(hr);
-			return paUnanticipatedHostError;
-		}
-
-		// Wait for more frames to become available
-		if (available == 0)
-		{
-			// Exclusive mode may require latency of 1 millisecond, thus we shall sleep
-			// around 500 microseconds (emulated) to collect packets in time
-			if (stream->in.shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE)
-			{
-				UINT32 sleep_frames = (frames < stream->in.framesPerHostCallback ? frames : stream->in.framesPerHostCallback);
-
-				sleep  = GetFramesSleepTime(sleep_frames, stream->in.wavex.Format.nSamplesPerSec);
-				sleep /= 4; // wait only for 1/4 of the buffer
-
-				// WASAPI input provides packets, thus expiring packet will result in bad audio
-				// limit waiting time to 2 seconds (will always work for smallest buffer in Shared)
-				if (sleep > 2)
-					sleep = 2;
-
-				// Avoid busy waiting, schedule next 1 millesecond wait
-				if (sleep == 0)
-					sleep = ThreadIdleScheduler_NextSleep(&sched);
-			}
-			else
-			{
-				if ((sleep = ThreadIdleScheduler_NextSleep(&sched)) != 0)
-				{
-					Sleep(sleep);
-					sleep = 0;
-				}
-			}
-
-			continue;
-		}
-
-		// Get the available data in the shared buffer.
-		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &wasapi_buffer, &available, &flags, NULL, NULL)) != S_OK)
-		{
-			// Buffer size is too small, waiting
-			if (hr != AUDCLNT_S_BUFFER_EMPTY)
-			{
-				LogHostError(hr);
-				goto end;
-			}
-
-			continue;
-		}
-
-		// Register available frames to processor
-        PaUtil_SetInputFrameCount(&stream->bufferProcessor, available);
-
-		// Register host buffer pointer to processor
-        PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, wasapi_buffer, stream->bufferProcessor.inputChannelCount);
-
-		// Copy user data to host buffer (with conversion if applicable)
-		processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, frames);
-		frames -= processed;
-
-		// Save tail into buffer
-		if ((frames == 0) && (available > processed))
-		{
-			UINT32 bytes_processed = processed * stream->in.wavex.Format.nBlockAlign;
-			UINT32 frames_to_save  = available - processed;
-
-			PaUtil_WriteRingBuffer(stream->in.tailBuffer, wasapi_buffer + bytes_processed, frames_to_save);
-		}
-
-		// Release host buffer
-		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, available)) != S_OK)
-		{
-			LogHostError(hr);
-			goto end;
-		}
-	}
-
-end:
-
-	// Notify blocking op has ended
-	SetEvent(stream->hBlockingOpStreamRD);
-
-	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
-}
-
-// ------------------------------------------------------------------------------------------
-static PaError WriteStream( PaStream* s, const void *_buffer, unsigned long frames )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-
-	//UINT32 frames;
-	const BYTE *user_buffer = (const BYTE *)_buffer;
-	BYTE *wasapi_buffer;
-	HRESULT hr = S_OK;
-	UINT32 i, available, sleep = 0;
-	unsigned long processed;
-	ThreadIdleScheduler sched;
-
-	// validate
-	if (!stream->running)
-		return paStreamIsStopped;
-	if (stream->renderClient == NULL)
-		return paBadStreamPtr;
-
-	// Notify blocking op has begun
-	ResetEvent(stream->hBlockingOpStreamWR);
-
-	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
-	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
-	ThreadIdleScheduler_Setup(&sched, 1, 500/* microseconds */);
-
-    // Make a local copy of the user buffer pointer(s), this is necessary
-	// because PaUtil_CopyOutput() advances these pointers every time it is called
-    if (!stream->bufferProcessor.userOutputIsInterleaved)
-    {
-        user_buffer = (const BYTE *)alloca(sizeof(const BYTE *) * stream->bufferProcessor.outputChannelCount);
-        if (user_buffer == NULL)
-            return paInsufficientMemory;
-
-        for (i = 0; i < stream->bufferProcessor.outputChannelCount; ++i)
-            ((const BYTE **)user_buffer)[i] = ((const BYTE **)_buffer)[i];
-    }
-
-	// Blocking (potentially, untill 'frames' are consumed) loop
-	while (frames != 0)
-	{
-		// Check if blocking call must be interrupted
-		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
-			break;
-
-		// Get frames available
-		if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
-		{
-			LogHostError(hr);
-			goto end;
-		}
-
-		// Wait for more frames to become available
-		if (available == 0)
-		{
-			UINT32 sleep_frames = (frames < stream->out.framesPerHostCallback ? frames : stream->out.framesPerHostCallback);
-
-			sleep  = GetFramesSleepTime(sleep_frames, stream->out.wavex.Format.nSamplesPerSec);
-			sleep /= 2; // wait only for half of the buffer
-
-			// Avoid busy waiting, schedule next 1 millesecond wait
-			if (sleep == 0)
-				sleep = ThreadIdleScheduler_NextSleep(&sched);
-
-			continue;
-		}
-
-		// Keep in 'frmaes' range
-		if (available > frames)
-			available = frames;
-
-		// Get pointer to host buffer
-		if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, available, &wasapi_buffer)) != S_OK)
-		{
-			// Buffer size is too big, waiting
-			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
-				continue;
-
-			LogHostError(hr);
-			goto end;
-		}
-
-		// Keep waiting again (on Vista it was noticed that WASAPI could SOMETIMES return NULL pointer 
-		// to buffer without returning AUDCLNT_E_BUFFER_TOO_LARGE instead)
-		if (wasapi_buffer == NULL)
-			continue;
-
-		// Register available frames to processor
-        PaUtil_SetOutputFrameCount(&stream->bufferProcessor, available);
-
-		// Register host buffer pointer to processor
-        PaUtil_SetInterleavedOutputChannels(&stream->bufferProcessor, 0, wasapi_buffer,	stream->bufferProcessor.outputChannelCount);
-
-		// Copy user data to host buffer (with conversion if applicable), this call will advance
-		// pointer 'user_buffer' to consumed portion of data
-		processed = PaUtil_CopyOutput(&stream->bufferProcessor, (const void **)&user_buffer, frames);
-		frames -= processed;
-
-		// Release host buffer
-		if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, available, 0)) != S_OK)
-		{
-			LogHostError(hr);
-			goto end;
-		}
-	}
-
-end:
-
-	// Notify blocking op has ended
-	SetEvent(stream->hBlockingOpStreamWR);
-
-	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
-}
-
-unsigned long PaUtil_GetOutputFrameCount( PaUtilBufferProcessor* bp )
-{
-	return bp->hostOutputFrameCount[0];
-}
-
-// ------------------------------------------------------------------------------------------
-static signed long GetStreamReadAvailable( PaStream* s )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-
-	HRESULT hr;
-	UINT32  available = 0;
-
-	// validate
-	if (!stream->running)
-		return paStreamIsStopped;
-	if (stream->captureClient == NULL)
-		return paBadStreamPtr;
-
-	// available in hardware buffer
-	if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
-	{
-		LogHostError(hr);
-		return paUnanticipatedHostError;
-	}
-
-	// available in software tail buffer
-	available += PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer);
-
-    return available;
-}
-
-// ------------------------------------------------------------------------------------------
-static signed long GetStreamWriteAvailable( PaStream* s )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)s;
-	HRESULT hr;
-	UINT32  available = 0;
-
-	// validate
-	if (!stream->running)
-		return paStreamIsStopped;
-	if (stream->renderClient == NULL)
-		return paBadStreamPtr;
-
-	if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
-	{
-		LogHostError(hr);
-		return paUnanticipatedHostError;
-	}
-
-	return (signed long)available;
-}
-
-
-// ------------------------------------------------------------------------------------------
-static void WaspiHostProcessingLoop( void *inputBuffer,  long inputFrames,
-                                     void *outputBuffer, long outputFrames,
-                                     void *userData )
-{
-    PaWasapiStream *stream = (PaWasapiStream*)userData;
-    PaStreamCallbackTimeInfo timeInfo = {0,0,0};
-	PaStreamCallbackFlags flags = 0;
-    int callbackResult;
-    unsigned long framesProcessed;
-	HRESULT hr;
-	UINT32 pending;
-
-    PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );
-
-    /*
-		Pa_GetStreamTime:
-            - generate timing information
-            - handle buffer slips
-    */
-	timeInfo.currentTime = PaUtil_GetTime();
-	// Query input latency
-	if (stream->in.clientProc != NULL)
-	{
-		PaTime pending_time;
-		if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, &pending)) == S_OK)
-			pending_time = (PaTime)pending / (PaTime)stream->in.wavex.Format.nSamplesPerSec;
-		else
-			pending_time = (PaTime)stream->in.latencySeconds;
-
-		timeInfo.inputBufferAdcTime = timeInfo.currentTime + pending_time;
-	}
-	// Query output current latency
-	if (stream->out.clientProc != NULL)
-	{
-		PaTime pending_time;
-		if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &pending)) == S_OK)
-			pending_time = (PaTime)pending / (PaTime)stream->out.wavex.Format.nSamplesPerSec;
-		else
-			pending_time = (PaTime)stream->out.latencySeconds;
-
-		timeInfo.outputBufferDacTime = timeInfo.currentTime + pending_time;
-	}
-
-    /*
-        If you need to byte swap or shift inputBuffer to convert it into a
-        portaudio format, do it here.
-    */
-
-    PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, flags );
-
-    /*
-        depending on whether the host buffers are interleaved, non-interleaved
-        or a mixture, you will want to call PaUtil_SetInterleaved*Channels(),
-        PaUtil_SetNonInterleaved*Channel() or PaUtil_Set*Channel() here.
-    */
-
-    if (stream->bufferProcessor.inputChannelCount > 0)
-    {
-        PaUtil_SetInputFrameCount( &stream->bufferProcessor, inputFrames );
-        PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor,
-            0, /* first channel of inputBuffer is channel 0 */
-            inputBuffer,
-            0 ); /* 0 - use inputChannelCount passed to init buffer processor */
-    }
-
-    if (stream->bufferProcessor.outputChannelCount > 0)
-    {
-        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, outputFrames);
-        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor,
-            0, /* first channel of outputBuffer is channel 0 */
-            outputBuffer,
-            0 ); /* 0 - use outputChannelCount passed to init buffer processor */
-    }
-
-    /* you must pass a valid value of callback result to PaUtil_EndBufferProcessing()
-        in general you would pass paContinue for normal operation, and
-        paComplete to drain the buffer processor's internal output buffer.
-        You can check whether the buffer processor's output buffer is empty
-        using PaUtil_IsBufferProcessorOuputEmpty( bufferProcessor )
-    */
-    callbackResult = paContinue;
-    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );
-
-    /*
-        If you need to byte swap or shift outputBuffer to convert it to
-        host format, do it here.
-    */
-
-	PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );
-
-    if (callbackResult == paContinue)
-    {
-        /* nothing special to do */
-    }
-    else
-	if (callbackResult == paAbort)
-    {
-		// stop stream
-        SetEvent(stream->hCloseRequest);
-    }
-    else
-    {
-		// stop stream
-        SetEvent(stream->hCloseRequest);
-    }
-}
-
-// ------------------------------------------------------------------------------------------
-HANDLE MMCSS_activate(const char *name)
-{
-    DWORD task_idx = 0;
-    HANDLE hTask = pAvSetMmThreadCharacteristics(name, &task_idx);
-    if (hTask == NULL)
-	{
-        PRINT(("WASAPI: AvSetMmThreadCharacteristics failed!\n"));
-    }
-
-    /*BOOL priority_ok = pAvSetMmThreadPriority(hTask, AVRT_PRIORITY_NORMAL);
-    if (priority_ok == FALSE)
-	{
-        PRINT(("WASAPI: AvSetMmThreadPriority failed!\n"));
-    }*/
-
-	// debug
-    {
-        int    cur_priority		  = GetThreadPriority(GetCurrentThread());
-        DWORD  cur_priority_class = GetPriorityClass(GetCurrentProcess());
-		PRINT(("WASAPI: thread[ priority-0x%X class-0x%X ]\n", cur_priority, cur_priority_class));
-    }
-
-	return hTask;
-}
-
-// ------------------------------------------------------------------------------------------
-void MMCSS_deactivate(HANDLE hTask)
-{
-	if (!hTask)
-		return;
-
-	if (pAvRevertMmThreadCharacteristics(hTask) == FALSE)
-	{
-        PRINT(("WASAPI: AvRevertMmThreadCharacteristics failed!\n"));
-    }
-}
-
-// ------------------------------------------------------------------------------------------
-PaError PaWasapi_ThreadPriorityBoost(void **hTask, PaWasapiThreadPriority nPriorityClass)
-{
-	static const char *mmcs_name[] =
-	{
-		NULL,
-		"Audio",
-		"Capture",
-		"Distribution",
-		"Games",
-		"Playback",
-		"Pro Audio",
-		"Window Manager"
-	};
-	HANDLE task;
-
-	if (hTask == NULL)
-		return paUnanticipatedHostError;
-
-	if ((UINT32)nPriorityClass >= STATIC_ARRAY_SIZE(mmcs_name))
-		return paUnanticipatedHostError;
-
-	task = MMCSS_activate(mmcs_name[nPriorityClass]);
-	if (task == NULL)
-		return paUnanticipatedHostError;
-
-	(*hTask) = task;
-	return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-PaError PaWasapi_ThreadPriorityRevert(void *hTask)
-{
-	if (hTask == NULL)
-		return paUnanticipatedHostError;
-
-	MMCSS_deactivate((HANDLE)hTask);
-
-	return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-// Described at:
-// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx
-
-PaError PaWasapi_GetJackCount(PaDeviceIndex nDevice, int *jcount)
-{
-	PaError ret;
-	HRESULT hr = S_OK;
-	PaDeviceIndex index;
-    IDeviceTopology *pDeviceTopology = NULL;
-    IConnector *pConnFrom = NULL;
-    IConnector *pConnTo = NULL;
-    IPart *pPart = NULL;
-    IKsJackDescription *pJackDesc = NULL;
-	UINT jackCount = 0;
-
-	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
-	if (paWasapi == NULL)
-		return paNotInitialized;
-
-	// Get device index.
-	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
-    if (ret != paNoError)
-        return ret;
-
-	// Validate index.
-	if ((UINT32)index >= paWasapi->deviceCount)
-		return paInvalidDevice;
-
-	// Get the endpoint device's IDeviceTopology interface.
-	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
-		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
-	IF_FAILED_JUMP(hr, error);
-
-    // The device topology for an endpoint device always contains just one connector (connector number 0).
-	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
-	IF_FAILED_JUMP(hr, error);
-
-    // Step across the connection to the jack on the adapter.
-	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
-    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
-    {
-        // The adapter device is not currently active.
-        hr = E_NOINTERFACE;
-    }
-	IF_FAILED_JUMP(hr, error);
-
-	// Get the connector's IPart interface.
-	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
-	IF_FAILED_JUMP(hr, error);
-
-	// Activate the connector's IKsJackDescription interface.
-	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
-	IF_FAILED_JUMP(hr, error);
-
-	// Return jack count for this device.
-	hr = IKsJackDescription_GetJackCount(pJackDesc, &jackCount);
-	IF_FAILED_JUMP(hr, error);
-
-	// Set.
-	(*jcount) = jackCount;
-
-	// Ok.
-	ret = paNoError;
-
-error:
-
-	SAFE_RELEASE(pDeviceTopology);
-	SAFE_RELEASE(pConnFrom);
-	SAFE_RELEASE(pConnTo);
-	SAFE_RELEASE(pPart);
-	SAFE_RELEASE(pJackDesc);
-
-	LogHostError(hr);
-	return paNoError;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaWasapiJackConnectionType ConvertJackConnectionTypeWASAPIToPA(int connType)
-{
-	switch (connType)
-	{
-		case eConnTypeUnknown:			return eJackConnTypeUnknown;
-#ifdef _KS_
-		case eConnType3Point5mm:		return eJackConnType3Point5mm;
-#else
-		case eConnTypeEighth:		    return eJackConnType3Point5mm;
-#endif
-		case eConnTypeQuarter:			return eJackConnTypeQuarter;
-		case eConnTypeAtapiInternal:	return eJackConnTypeAtapiInternal;
-		case eConnTypeRCA:				return eJackConnTypeRCA;
-		case eConnTypeOptical:			return eJackConnTypeOptical;
-		case eConnTypeOtherDigital:		return eJackConnTypeOtherDigital;
-		case eConnTypeOtherAnalog:		return eJackConnTypeOtherAnalog;
-		case eConnTypeMultichannelAnalogDIN: return eJackConnTypeMultichannelAnalogDIN;
-		case eConnTypeXlrProfessional:	return eJackConnTypeXlrProfessional;
-		case eConnTypeRJ11Modem:		return eJackConnTypeRJ11Modem;
-		case eConnTypeCombination:		return eJackConnTypeCombination;
-	}
-	return eJackConnTypeUnknown;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaWasapiJackGeoLocation ConvertJackGeoLocationWASAPIToPA(int geoLoc)
-{
-	switch (geoLoc)
-	{
-	case eGeoLocRear:				return eJackGeoLocRear;
-	case eGeoLocFront:				return eJackGeoLocFront;
-	case eGeoLocLeft:				return eJackGeoLocLeft;
-	case eGeoLocRight:				return eJackGeoLocRight;
-	case eGeoLocTop:				return eJackGeoLocTop;
-	case eGeoLocBottom:				return eJackGeoLocBottom;
-#ifdef _KS_
-	case eGeoLocRearPanel:			return eJackGeoLocRearPanel;
-#else
-	case eGeoLocRearOPanel:         return eJackGeoLocRearPanel;
-#endif
-	case eGeoLocRiser:				return eJackGeoLocRiser;
-	case eGeoLocInsideMobileLid:	return eJackGeoLocInsideMobileLid;
-	case eGeoLocDrivebay:			return eJackGeoLocDrivebay;
-	case eGeoLocHDMI:				return eJackGeoLocHDMI;
-	case eGeoLocOutsideMobileLid:	return eJackGeoLocOutsideMobileLid;
-	case eGeoLocATAPI:				return eJackGeoLocATAPI;
-	}
-	return eJackGeoLocUnk;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaWasapiJackGenLocation ConvertJackGenLocationWASAPIToPA(int genLoc)
-{
-	switch (genLoc)
-	{
-	case eGenLocPrimaryBox:	return eJackGenLocPrimaryBox;
-	case eGenLocInternal:	return eJackGenLocInternal;
-#ifdef _KS_
-	case eGenLocSeparate:	return eJackGenLocSeparate;
-#else
-	case eGenLocSeperate:	return eJackGenLocSeparate;
-#endif
-	case eGenLocOther:		return eJackGenLocOther;
-	}
-	return eJackGenLocPrimaryBox;
-}
-
-// ------------------------------------------------------------------------------------------
-static PaWasapiJackPortConnection ConvertJackPortConnectionWASAPIToPA(int portConn)
-{
-	switch (portConn)
-	{
-	case ePortConnJack:					return eJackPortConnJack;
-	case ePortConnIntegratedDevice:		return eJackPortConnIntegratedDevice;
-	case ePortConnBothIntegratedAndJack:return eJackPortConnBothIntegratedAndJack;
-	case ePortConnUnknown:				return eJackPortConnUnknown;
-	}
-	return eJackPortConnJack;
-}
-
-// ------------------------------------------------------------------------------------------
-// Described at:
-// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx
-
-PaError PaWasapi_GetJackDescription(PaDeviceIndex nDevice, int jindex, PaWasapiJackDescription *pJackDescription)
-{
-	PaError ret;
-	HRESULT hr = S_OK;
-	PaDeviceIndex index;
-    IDeviceTopology *pDeviceTopology = NULL;
-    IConnector *pConnFrom = NULL;
-    IConnector *pConnTo = NULL;
-    IPart *pPart = NULL;
-    IKsJackDescription *pJackDesc = NULL;
-	KSJACK_DESCRIPTION jack = { 0 };
-
-	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
-	if (paWasapi == NULL)
-		return paNotInitialized;
-
-	// Get device index.
-	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
-    if (ret != paNoError)
-        return ret;
-
-	// Validate index.
-	if ((UINT32)index >= paWasapi->deviceCount)
-		return paInvalidDevice;
-
-	// Get the endpoint device's IDeviceTopology interface.
-	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
-		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
-	IF_FAILED_JUMP(hr, error);
-
-    // The device topology for an endpoint device always contains just one connector (connector number 0).
-	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
-	IF_FAILED_JUMP(hr, error);
-
-    // Step across the connection to the jack on the adapter.
-	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
-    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
-    {
-        // The adapter device is not currently active.
-        hr = E_NOINTERFACE;
-    }
-	IF_FAILED_JUMP(hr, error);
-
-	// Get the connector's IPart interface.
-	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
-	IF_FAILED_JUMP(hr, error);
-
-	// Activate the connector's IKsJackDescription interface.
-	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
-	IF_FAILED_JUMP(hr, error);
-
-	// Test to return jack description struct for index 0.
-	hr = IKsJackDescription_GetJackDescription(pJackDesc, jindex, &jack);
-	IF_FAILED_JUMP(hr, error);
-
-	// Convert WASAPI values to PA format.
-	pJackDescription->channelMapping = jack.ChannelMapping;
-	pJackDescription->color          = jack.Color;
-	pJackDescription->connectionType = ConvertJackConnectionTypeWASAPIToPA(jack.ConnectionType);
-	pJackDescription->genLocation    = ConvertJackGenLocationWASAPIToPA(jack.GenLocation);
-	pJackDescription->geoLocation    = ConvertJackGeoLocationWASAPIToPA(jack.GeoLocation);
-	pJackDescription->isConnected    = jack.IsConnected;
-	pJackDescription->portConnection = ConvertJackPortConnectionWASAPIToPA(jack.PortConnection);
-
-	// Ok.
-	ret = paNoError;
-
-error:
-
-	SAFE_RELEASE(pDeviceTopology);
-	SAFE_RELEASE(pConnFrom);
-	SAFE_RELEASE(pConnTo);
-	SAFE_RELEASE(pPart);
-	SAFE_RELEASE(pJackDesc);
-
-	LogHostError(hr);
-	return ret;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
-{
-	HRESULT hr;
-	UINT32 frames  = stream->out.framesPerHostCallback,
-		   padding = 0;
-
-	(*available) = 0;
-
-	// get read position
-	if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding)) != S_OK)
-		return LogHostError(hr);
-
-	// get available
-	frames -= padding;
-
-	// set
-	(*available) = frames;
-	return hr;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
-{
-	HRESULT hr;
-
-	(*available) = 0;
-
-	// GetCurrentPadding() has opposite meaning to Output stream 
-	if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, available)) != S_OK)
-		return LogHostError(hr);
-
-	return hr;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT ProcessOutputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor, UINT32 frames)
-{
-	HRESULT hr;
-	BYTE *data = NULL;
-
-	// Get buffer
-	if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
-	{
-		if (stream->out.shareMode == AUDCLNT_SHAREMODE_SHARED)
-		{
-			// Using GetCurrentPadding to overcome AUDCLNT_E_BUFFER_TOO_LARGE in
-			// shared mode results in no sound in Event-driven mode (MSDN does not
-			// document this, or is it WASAPI bug?), thus we better
-			// try to acquire buffer next time when GetBuffer allows to do so.
-#if 0
-			// Get Read position
-			UINT32 padding = 0;
-			hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding);
-			if (hr != S_OK)
-				return LogHostError(hr);
-
-			// Get frames to write
-			frames -= padding;
-			if (frames == 0)
-				return S_OK;
-
-			if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
-				return LogHostError(hr);
-#else
-			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
-				return S_OK; // be silent in shared mode, try again next time
-#endif
-		}
-		else
-			return LogHostError(hr);
-	}
-
-	// Process data
-	if (stream->out.monoMixer != NULL)
-	{
-		// expand buffer
-		UINT32 mono_frames_size = frames * (stream->out.wavex.Format.wBitsPerSample / 8);
-		if (mono_frames_size > stream->out.monoBufferSize)
-			stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
-
-		// process
-		processor[S_OUTPUT].processor(NULL, 0, (BYTE *)stream->out.monoBuffer, frames, processor[S_OUTPUT].userData);
-
-		// mix 1 to 2 channels
-		stream->out.monoMixer(data, stream->out.monoBuffer, frames);
-	}
-	else
-	{
-		processor[S_OUTPUT].processor(NULL, 0, data, frames, processor[S_OUTPUT].userData);
-	}
-
-	// Release buffer
-	if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, frames, 0)) != S_OK)
-		LogHostError(hr);
-
-	return hr;
-}
-
-// ------------------------------------------------------------------------------------------
-HRESULT ProcessInputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor)
-{
-	HRESULT hr = S_OK;
-	UINT32 frames;
-	BYTE *data = NULL;
-	DWORD flags = 0;
-
-	for (;;)
-	{
-		// Check if blocking call must be interrupted
-		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
-			break;
-
-		// Findout if any frames available
-		frames = 0;
-		if ((hr = _PollGetInputFramesAvailable(stream, &frames)) != S_OK)
-			return hr;
-
-		// Empty/consumed buffer
-		if (frames == 0)
-			break;
-
-		// Get the available data in the shared buffer.
-		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &data, &frames, &flags, NULL, NULL)) != S_OK)
-		{
-			if (hr == AUDCLNT_S_BUFFER_EMPTY)
-			{
-				hr = S_OK;
-				break; // Empty/consumed buffer
-			}
-
-			return LogHostError(hr);
-			break;
-		}
-
-		// Detect silence
-		// if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
-		//	data = NULL;
-
-		// Process data
-		if (stream->in.monoMixer != NULL)
-		{
-			// expand buffer
-			UINT32 mono_frames_size = frames * (stream->in.wavex.Format.wBitsPerSample / 8);
-			if (mono_frames_size > stream->in.monoBufferSize)
-				stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
-
-			// mix 1 to 2 channels
-			stream->in.monoMixer(stream->in.monoBuffer, data, frames);
-
-			// process
-			processor[S_INPUT].processor((BYTE *)stream->in.monoBuffer, frames, NULL, 0, processor[S_INPUT].userData);
-		}
-		else
-		{
-			processor[S_INPUT].processor(data, frames, NULL, 0, processor[S_INPUT].userData);
-		}
-
-		// Release buffer
-		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, frames)) != S_OK)
-			return LogHostError(hr);
-
-		//break;
-	}
-
-	return hr;
-}
-
-// ------------------------------------------------------------------------------------------
-void _StreamOnStop(PaWasapiStream *stream)
-{
-	// Stop INPUT/OUTPUT clients
-	if (!stream->bBlocking) 
-	{
-		if (stream->in.clientProc != NULL)
-			IAudioClient_Stop(stream->in.clientProc);
-		if (stream->out.clientProc != NULL)
-			IAudioClient_Stop(stream->out.clientProc);
-	} 
-	else 
-	{
-		if (stream->in.clientParent != NULL)
-			IAudioClient_Stop(stream->in.clientParent);
-		if (stream->out.clientParent != NULL)
-			IAudioClient_Stop(stream->out.clientParent);
-	}
-
-	// Restore thread priority
-	if (stream->hAvTask != NULL)
-	{
-		PaWasapi_ThreadPriorityRevert(stream->hAvTask);
-		stream->hAvTask = NULL;
-	}
-
-    // Notify
-    if (stream->streamRepresentation.streamFinishedCallback != NULL)
-        stream->streamRepresentation.streamFinishedCallback(stream->streamRepresentation.userData);
-}
-
-// ------------------------------------------------------------------------------------------
-PA_THREAD_FUNC ProcThreadEvent(void *param)
-{
-    PaWasapiHostProcessor processor[S_COUNT];
-	HRESULT hr;
-	DWORD dwResult;
-    PaWasapiStream *stream = (PaWasapiStream *)param;
-	PaWasapiHostProcessor defaultProcessor;
-	BOOL set_event[S_COUNT] = { FALSE, FALSE };
-	BOOL bWaitAllEvents = FALSE;
-	BOOL bThreadComInitialized = FALSE;
-
-	/*
-	If COM is already initialized CoInitialize will either return
-	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
-	threading mode. In either case we shouldn't consider it an error
-	but we need to be careful to not call CoUninitialize() if 
-	RPC_E_CHANGED_MODE was returned.
-	*/
-	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
-	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
-	{
-		PRINT(("WASAPI: failed ProcThreadEvent CoInitialize"));
-		return paUnanticipatedHostError;
-	}
-	if (hr != RPC_E_CHANGED_MODE)
-		bThreadComInitialized = TRUE;
-
-	// Unmarshal stream pointers for safe COM operation
-	hr = UnmarshalStreamComPointers(stream);
-	if (hr != S_OK) {
-		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
-		goto thread_end;
-	}
-
-	// Waiting on all events in case of Full-Duplex/Exclusive mode.
-	if ((stream->in.clientProc != NULL) && (stream->out.clientProc != NULL))
-	{
-		bWaitAllEvents = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) &&
-			(stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE);
-	}
-
-    // Setup data processors
-    defaultProcessor.processor = WaspiHostProcessingLoop;
-    defaultProcessor.userData  = stream;
-    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
-    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);
-
-	// Boost thread priority
-	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);
-
-	// Create events
-	if (stream->event[S_OUTPUT] == NULL)
-	{
-		stream->event[S_OUTPUT] = CreateEvent(NULL, FALSE, FALSE, NULL);
-		set_event[S_OUTPUT] = TRUE;
-	}
-	if (stream->event[S_INPUT] == NULL)
-	{
-		stream->event[S_INPUT]  = CreateEvent(NULL, FALSE, FALSE, NULL);
-		set_event[S_INPUT] = TRUE;
-	}
-	if ((stream->event[S_OUTPUT] == NULL) || (stream->event[S_INPUT] == NULL))
-	{
-		PRINT(("WASAPI Thread: failed creating Input/Output event handle\n"));
-		goto thread_error;
-	}
-
-	// Initialize event & start INPUT stream
-	if (stream->in.clientProc)
-	{
-		// Create & set handle
-		if (set_event[S_INPUT])
-		{
-			if ((hr = IAudioClient_SetEventHandle(stream->in.clientProc, stream->event[S_INPUT])) != S_OK)
-			{
-				LogHostError(hr);
-				goto thread_error;
-			}
-		}
-
-		// Start
-		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
-		{
-			LogHostError(hr);
-			goto thread_error;
-		}
-	}
-
-	// Initialize event & start OUTPUT stream
-	if (stream->out.clientProc)
-	{
-		// Create & set handle
-		if (set_event[S_OUTPUT])
-		{
-			if ((hr = IAudioClient_SetEventHandle(stream->out.clientProc, stream->event[S_OUTPUT])) != S_OK)
-			{
-				LogHostError(hr);
-				goto thread_error;
-			}
-		}
-
-		// Preload buffer before start
-		if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
-		{
-			LogHostError(hr);
-			goto thread_error;
-		}
-
-		// Start
-		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
-		{
-			LogHostError(hr);
-			goto thread_error;
-		}
-
-	}
-
-	// Signal: stream running
-	stream->running = TRUE;
-
-	// Notify: thread started
-	SetEvent(stream->hThreadStart);
-
-	// Processing Loop
-	for (;;)
-    {
-	    // 10 sec timeout (on timeout stream will auto-stop when processed by WAIT_TIMEOUT case)
-        dwResult = WaitForMultipleObjects(S_COUNT, stream->event, bWaitAllEvents, 10*1000);
-
-		// Check for close event (after wait for buffers to avoid any calls to user
-		// callback when hCloseRequest was set)
-		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
-			break;
-
-		// Process S_INPUT/S_OUTPUT
-		switch (dwResult)
-		{
-		case WAIT_TIMEOUT: {
-			PRINT(("WASAPI Thread: WAIT_TIMEOUT - probably bad audio driver or Vista x64 bug: use paWinWasapiPolling instead\n"));
-			goto thread_end;
-			break; }
-
-		// Input stream
-		case WAIT_OBJECT_0 + S_INPUT: {
-
-            if (stream->captureClient == NULL)
-                break;
-
-			if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
-			{
-				LogHostError(hr);
-				goto thread_error;
-			}
-
-			break; }
-
-		// Output stream
-		case WAIT_OBJECT_0 + S_OUTPUT: {
-
-            if (stream->renderClient == NULL)
-                break;
-
-			if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
-			{
-				LogHostError(hr);
-				goto thread_error;
-			}
-
-			break; }
-		}
-	}
-
-thread_end:
-
-	// Process stop
-	_StreamOnStop(stream);
-
-	// Release unmarshaled COM pointers
-	ReleaseUnmarshaledComPointers(stream);
-
-	// Cleanup COM for this thread
-	if (bThreadComInitialized == TRUE)
-		CoUninitialize();
-
-	// Notify: not running
-	stream->running = FALSE;
-
-	// Notify: thread exited
-	SetEvent(stream->hThreadExit);
-
-	return 0;
-
-thread_error:
-
-	// Prevent deadlocking in Pa_StreamStart
-	SetEvent(stream->hThreadStart);
-
-	// Exit
-	goto thread_end;
-}
-
-// ------------------------------------------------------------------------------------------
-PA_THREAD_FUNC ProcThreadPoll(void *param)
-{
-    PaWasapiHostProcessor processor[S_COUNT];
-	HRESULT hr;
-    PaWasapiStream *stream = (PaWasapiStream *)param;
-	PaWasapiHostProcessor defaultProcessor;
-	INT32 i;
-	ThreadIdleScheduler scheduler;
-
-	// Calculate the actual duration of the allocated buffer.
-	DWORD sleep_ms     = 0;
-	DWORD sleep_ms_in;
-	DWORD sleep_ms_out;
-
-	BOOL bThreadComInitialized = FALSE;
-
-	/*
-	If COM is already initialized CoInitialize will either return
-	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
-	threading mode. In either case we shouldn't consider it an error
-	but we need to be careful to not call CoUninitialize() if 
-	RPC_E_CHANGED_MODE was returned.
-	*/
-	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
-	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
-	{
-		PRINT(("WASAPI: failed ProcThreadPoll CoInitialize"));
-		return paUnanticipatedHostError;
-	}
-	if (hr != RPC_E_CHANGED_MODE)
-		bThreadComInitialized = TRUE;
-
-	// Unmarshal stream pointers for safe COM operation
-	hr = UnmarshalStreamComPointers(stream);
-	if (hr != S_OK) 
-	{
-		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
-		return 0;
-	}
-
-	// Calculate timeout for next polling attempt.
-	sleep_ms_in  = GetFramesSleepTime(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
-	sleep_ms_out = GetFramesSleepTime(stream->out.framesPerBuffer, stream->out.wavex.Format.nSamplesPerSec);
-
-	// WASAPI Input packets tend to expire very easily, let's limit sleep time to 2 milliseconds
-	// for all cases. Please propose better solution if any.
-	if (sleep_ms_in > 2)
-		sleep_ms_in = 2;
-
-	// Adjust polling time for non-paUtilFixedHostBufferSize. Input stream is not adjustable as it is being
-	// polled according its packet length.
-	if (stream->bufferMode != paUtilFixedHostBufferSize)
-	{
-		//sleep_ms_in = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->in.wavex.Format.nSamplesPerSec);
-		sleep_ms_out = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);
-	}
-
-	// Choose smallest
-	if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
-		sleep_ms = min(sleep_ms_in, sleep_ms_out);
-	else
-	{
-		sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
-	}
-	// Make sure not 0, othervise use ThreadIdleScheduler
-	if (sleep_ms == 0)
-	{
-		sleep_ms_in  = GetFramesSleepTimeMicroseconds(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
-		sleep_ms_out = GetFramesSleepTimeMicroseconds(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);
-
-		// Choose smallest
-		if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
-			sleep_ms = min(sleep_ms_in, sleep_ms_out);
-		else
-		{
-			sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
-		}
-
-		// Setup thread sleep scheduler
-		ThreadIdleScheduler_Setup(&scheduler, 1, sleep_ms/* microseconds here */);
-		sleep_ms = 0;
-	}
-
-    // Setup data processors
-    defaultProcessor.processor = WaspiHostProcessingLoop;
-    defaultProcessor.userData  = stream;
-    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
-    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);
-
-	// Boost thread priority
-	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);
-
-	// Initialize event & start INPUT stream
-	if (stream->in.clientProc)
-	{
-		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
-		{
-			LogHostError(hr);
-			goto thread_error;
-		}
-	}
-
-	// Initialize event & start OUTPUT stream
-	if (stream->out.clientProc)
-	{
-		// Preload buffer (obligatory, othervise ->Start() will fail), avoid processing
-		// when in full-duplex mode as it requires input processing as well
-		if (!PA_WASAPI__IS_FULLDUPLEX(stream))
-		{
-			UINT32 frames = 0;
-			if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) == S_OK)
-            {
-				if (stream->bufferMode == paUtilFixedHostBufferSize)
-				{
-					if (frames >= stream->out.framesPerBuffer)
-					{
-						frames = stream->out.framesPerBuffer;
-
-						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
-						{
-							LogHostError(hr); // not fatal, just log
-						}
-					}
-				}
-				else
-				{
-					if (frames != 0)
-					{
-						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
-						{
-							LogHostError(hr); // not fatal, just log
-						}
-					}
-				}
-            }
-            else
-			{
-				LogHostError(hr); // not fatal, just log
-			}
-		}
-
-		// Start
-		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
-		{
-			LogHostError(hr);
-			goto thread_error;
-		}
-	}
-
-	// Signal: stream running
-	stream->running = TRUE;
-
-	// Notify: thread started
-	SetEvent(stream->hThreadStart);
-
-	if (!PA_WASAPI__IS_FULLDUPLEX(stream))
-	{
-		// Processing Loop
-		UINT32 next_sleep = sleep_ms;
-		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
-		{
-			// Get next sleep time
-			if (sleep_ms == 0)
-			{
-				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
-			}
-
-			for (i = 0; i < S_COUNT; ++i)
-			{
-				// Process S_INPUT/S_OUTPUT
-				switch (i)
-				{
-				// Input stream
-				case S_INPUT: {
-
-					if (stream->captureClient == NULL)
-						break;
-
-					if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
-					{
-						LogHostError(hr);
-						goto thread_error;
-					}
-
-					break; }
-
-				// Output stream
-				case S_OUTPUT: {
-
-					UINT32 frames;
-					if (stream->renderClient == NULL)
-						break;
-
-					// get available frames
-					if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) != S_OK)
-					{
-						LogHostError(hr);
-						goto thread_error;
-					}
-
-					// output
-					if (stream->bufferMode == paUtilFixedHostBufferSize)
-					{
-						while (frames >= stream->out.framesPerBuffer)
-						{
-							if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
-							{
-								LogHostError(hr);
-								goto thread_error;
-							}
-
-							frames -= stream->out.framesPerBuffer;
-						}
-					}
-					else
-					{
-						if (frames != 0)
-						{
-							if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
-							{
-								LogHostError(hr);
-								goto thread_error;
-							}
-						}
-					}
-
-					break; }
-				}
-			}
-		}
-	}
-	else
-	{
-#if 0
-		// Processing Loop
-		while (WaitForSingleObject(stream->hCloseRequest, 1) == WAIT_TIMEOUT)
-		{
-			UINT32 i_frames = 0, i_processed = 0;
-			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
-			DWORD i_flags = 0;
-			UINT32 o_frames = 0;
-
-			// get host input buffer
-			if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
-			{
-				if (hr == AUDCLNT_S_BUFFER_EMPTY)
-					continue; // no data in capture buffer
-
-				LogHostError(hr);
-				break;
-			}
-
-			// get available frames
-			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
-			{
-				// release input buffer
-				IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
-
-				LogHostError(hr);
-				break;
-			}
-
-			// process equal ammount of frames
-			if (o_frames >= i_frames)
-			{
-				// process input ammount of frames
-				UINT32 o_processed = i_frames;
-
-				// get host output buffer
-				if ((hr = IAudioRenderClient_GetBuffer(stream->procRCClient, o_processed, &o_data)) == S_OK)
-				{
-					// processed amount of i_frames
-					i_processed = i_frames;
-					o_data_host = o_data;
-
-					// convert output mono
-					if (stream->out.monoMixer)
-					{
-						UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
-						// expand buffer
-						if (mono_frames_size > stream->out.monoBufferSize)
-						{
-							stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
-							if (stream->out.monoBuffer == NULL)
-							{
-								// release input buffer
-								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
-								// release output buffer
-								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
-
-								LogPaError(paInsufficientMemory);
-								break;
-							}
-						}
-
-						// replace buffer pointer
-						o_data = (BYTE *)stream->out.monoBuffer;
-					}
-
-					// convert input mono
-					if (stream->in.monoMixer)
-					{
-						UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
-						// expand buffer
-						if (mono_frames_size > stream->in.monoBufferSize)
-						{
-							stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
-							if (stream->in.monoBuffer == NULL)
-							{
-								// release input buffer
-								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
-								// release output buffer
-								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
-
-								LogPaError(paInsufficientMemory);
-								break;
-							}
-						}
-
-						// mix 2 to 1 input channels
-						stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);
-
-						// replace buffer pointer
-						i_data = (BYTE *)stream->in.monoBuffer;
-					}
-
-					// process
-					processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);
-
-					// mix 1 to 2 output channels
-					if (stream->out.monoBuffer)
-						stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);
-
-					// release host output buffer
-					if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
-						LogHostError(hr);
-				}
-				else
-				{
-					if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
-						LogHostError(hr); // be silent in shared mode, try again next time
-				}
-			}
-
-			// release host input buffer
-			if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
-			{
-				LogHostError(hr);
-				break;
-			}
-		}
-#else
-		// Processing Loop
-		UINT32 next_sleep = sleep_ms;
-		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
-		{
-			UINT32 i_frames = 0, i_processed = 0;
-			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
-			DWORD i_flags = 0;
-			UINT32 o_frames = 0;
-
-			// Get next sleep time
-			if (sleep_ms == 0)
-			{
-				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
-			}
-
-			// get available frames
-			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
-			{
-				LogHostError(hr);
-				break;
-			}
-
-			while (o_frames != 0)
-			{
-				// get host input buffer
-				if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
-				{
-					if (hr == AUDCLNT_S_BUFFER_EMPTY)
-						break; // no data in capture buffer
-
-					LogHostError(hr);
-					break;
-				}
-
-				// process equal ammount of frames
-				if (o_frames >= i_frames)
-				{
-					// process input ammount of frames
-					UINT32 o_processed = i_frames;
-
-					// get host output buffer
-					if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, o_processed, &o_data)) == S_OK)
-					{
-						// processed amount of i_frames
-						i_processed = i_frames;
-						o_data_host = o_data;
-
-						// convert output mono
-						if (stream->out.monoMixer)
-						{
-							UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
-							// expand buffer
-							if (mono_frames_size > stream->out.monoBufferSize)
-							{
-								stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
-								if (stream->out.monoBuffer == NULL)
-								{
-									// release input buffer
-									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
-									// release output buffer
-									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
-
-									LogPaError(paInsufficientMemory);
-									goto thread_error;
-								}
-							}
-
-							// replace buffer pointer
-							o_data = (BYTE *)stream->out.monoBuffer;
-						}
-
-						// convert input mono
-						if (stream->in.monoMixer)
-						{
-							UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
-							// expand buffer
-							if (mono_frames_size > stream->in.monoBufferSize)
-							{
-								stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
-								if (stream->in.monoBuffer == NULL)
-								{
-									// release input buffer
-									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
-									// release output buffer
-									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
-
-									LogPaError(paInsufficientMemory);
-									goto thread_error;
-								}
-							}
-
-							// mix 2 to 1 input channels
-							stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);
-
-							// replace buffer pointer
-							i_data = (BYTE *)stream->in.monoBuffer;
-						}
-
-						// process
-						processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);
-
-						// mix 1 to 2 output channels
-						if (stream->out.monoBuffer)
-							stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);
-
-						// release host output buffer
-						if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
-							LogHostError(hr);
-
-						o_frames -= o_processed;
-					}
-					else
-					{
-						if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
-							LogHostError(hr); // be silent in shared mode, try again next time
-					}
-				}
-				else
-				{
-					i_processed = 0;
-					goto fd_release_buffer_in;
-				}
-
-fd_release_buffer_in:
-
-				// release host input buffer
-				if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
-				{
-					LogHostError(hr);
-					break;
-				}
-
-				// break processing, input hasn't been accumulated yet
-				if (i_processed == 0)
-					break;
-			}
-		}
-#endif
-	}
-
-thread_end:
-
-	// Process stop
-	_StreamOnStop(stream);
-
-	// Release unmarshaled COM pointers
-	ReleaseUnmarshaledComPointers(stream);
-
-	// Cleanup COM for this thread
-	if (bThreadComInitialized == TRUE)
-		CoUninitialize();
-
-	// Notify: not running
-	stream->running = FALSE;
-
-	// Notify: thread exited
-	SetEvent(stream->hThreadExit);
-
-	return 0;
-
-thread_error:
-
-	// Prevent deadlocking in Pa_StreamStart
-	SetEvent(stream->hThreadStart);
-
-	// Exit
-	goto thread_end;
-}
-
-// ------------------------------------------------------------------------------------------
-void *PaWasapi_ReallocateMemory(void *ptr, size_t size)
-{
-	return realloc(ptr, size);
-}
-
-// ------------------------------------------------------------------------------------------
-void PaWasapi_FreeMemory(void *ptr)
-{
-	free(ptr);
-}
-
-//#endif //VC 2005
-
-
-
-
-#if 0
-			if(bFirst) {
-				float masteur;
-				hr = stream->outVol->GetMasterVolumeLevelScalar(&masteur);
-				if (hr != S_OK)
-					LogHostError(hr);
-				float chan1, chan2;
-				hr = stream->outVol->GetChannelVolumeLevelScalar(0, &chan1);
-				if (hr != S_OK)
-					LogHostError(hr);
-				hr = stream->outVol->GetChannelVolumeLevelScalar(1, &chan2);
-				if (hr != S_OK)
-					LogHostError(hr);
-
-				BOOL bMute;
-				hr = stream->outVol->GetMute(&bMute);
-				if (hr != S_OK)
-					LogHostError(hr);
-
-				stream->outVol->SetMasterVolumeLevelScalar(0.5, NULL);
-				stream->outVol->SetChannelVolumeLevelScalar(0, 0.5, NULL);
-				stream->outVol->SetChannelVolumeLevelScalar(1, 0.5, NULL);
-				stream->outVol->SetMute(FALSE, NULL);
-				bFirst = FALSE;
-			}
-#endif
+/*
+ * Portable Audio I/O Library WASAPI implementation
+ * Copyright (c) 2006-2010 David Viens, Dmitry Kostjuchenko
+ *
+ * Based on the Open Source API proposed by Ross Bencina
+ * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however,
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also
+ * requested that these non-binding requests be included along with the
+ * license above.
+ */
+
+/** @file
+ @ingroup hostapi_src
+ @brief WASAPI implementation of support for a host API.
+ @note pa_wasapi currently requires minimum VC 2005, and the latest Vista SDK
+*/
+
+#include <windows.h>
+#include <stdio.h>
+#include <process.h>
+#include <assert.h>
+
+// WinRT
+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
+	#define PA_WINRT
+	#define INITGUID
+#endif
+
+// WASAPI
+#include <mmreg.h>  // must be before other Wasapi headers
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+	#include <Avrt.h>
+	#define COBJMACROS
+	#include <Audioclient.h>
+	#include <endpointvolume.h>
+	#define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
+	#include <mmdeviceapi.h>
+	#include <functiondiscoverykeys.h>
+    #include <devicetopology.h>	// Used to get IKsJackDescription interface
+	#undef INITGUID
+#endif
+#ifndef __MWERKS__
+	#include <malloc.h>
+	#include <memory.h>
+#endif
+
+#include "pa_util.h"
+#include "pa_allocation.h"
+#include "pa_hostapi.h"
+#include "pa_stream.h"
+#include "pa_cpuload.h"
+#include "pa_process.h"
+#include "pa_win_wasapi.h"
+#include "pa_debugprint.h"
+#include "pa_ringbuffer.h"
+#include "pa_win_coinitialize.h"
+
+#if !defined(NTDDI_VERSION)
+ 
+    #undef WINVER
+    #undef _WIN32_WINNT
+    #define WINVER       0x0600 // VISTA
+	#define _WIN32_WINNT WINVER
+
+	#ifndef _AVRT_ //<< fix MinGW dummy compile by defining missing type: AVRT_PRIORITY
+        typedef enum _AVRT_PRIORITY
+        {
+            AVRT_PRIORITY_LOW = -1,
+            AVRT_PRIORITY_NORMAL,
+            AVRT_PRIORITY_HIGH,
+            AVRT_PRIORITY_CRITICAL
+        } AVRT_PRIORITY, *PAVRT_PRIORITY;
+	#endif
+
+	#include <basetyps.h> // << for IID/CLSID
+    #include <rpcsal.h>
+    #include <sal.h>
+
+	#ifndef __LPCGUID_DEFINED__
+		#define __LPCGUID_DEFINED__
+		typedef const GUID *LPCGUID;
+	#endif
+
+    #ifndef PROPERTYKEY_DEFINED
+        #define PROPERTYKEY_DEFINED
+        typedef struct _tagpropertykey
+        {
+            GUID fmtid;
+            DWORD pid;
+        } 	PROPERTYKEY;
+    #endif
+
+    #ifdef __midl_proxy
+        #define __MIDL_CONST
+    #else
+        #define __MIDL_CONST const
+    #endif
+
+    #ifdef WIN64
+        #include <wtypes.h>
+        typedef LONG NTSTATUS;
+        #define FASTCALL
+        #include <oleidl.h>
+        #include <objidl.h>
+     #else
+        typedef struct _BYTE_BLOB
+        {
+            unsigned long clSize;
+            unsigned char abData[ 1 ];
+        } 	BYTE_BLOB;
+        typedef /* [unique] */  __RPC_unique_pointer BYTE_BLOB *UP_BYTE_BLOB;
+        typedef LONGLONG REFERENCE_TIME;
+        #define NONAMELESSUNION
+    #endif
+    
+    #ifndef WAVE_FORMAT_IEEE_FLOAT
+        #define WAVE_FORMAT_IEEE_FLOAT 0x0003 // 32-bit floating-point
+    #endif    
+    
+    #ifndef __MINGW_EXTENSION
+        #if defined(__GNUC__) || defined(__GNUG__)
+            #define __MINGW_EXTENSION __extension__
+        #else
+            #define __MINGW_EXTENSION
+        #endif
+    #endif 
+
+    #include <sdkddkver.h>
+    #include <propkeydef.h>
+    #define COBJMACROS
+    #define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
+    #include <audioclient.h>
+    #include <mmdeviceapi.h>
+    #include <endpointvolume.h>
+    #include <functiondiscoverykeys.h>
+	#include <devicetopology.h>	// Used to get IKsJackDescription interface
+    #undef INITGUID
+
+#endif // NTDDI_VERSION
+
+// Missing declarations for WinRT
+#ifdef PA_WINRT
+
+	#define DEVICE_STATE_ACTIVE 0x00000001
+
+	typedef	enum _EDataFlow
+	{	
+		eRender					= 0,
+		eCapture				= ( eRender + 1 ) ,
+		eAll					= ( eCapture + 1 ) ,
+		EDataFlow_enum_count	= ( eAll + 1 )
+	}
+	EDataFlow;
+
+	typedef enum _EndpointFormFactor
+	{	
+		RemoteNetworkDevice			= 0,
+		Speakers					= ( RemoteNetworkDevice + 1 ) ,
+		LineLevel					= ( Speakers + 1 ) ,
+		Headphones					= ( LineLevel + 1 ) ,
+		Microphone					= ( Headphones + 1 ) ,
+		Headset						= ( Microphone + 1 ) ,
+		Handset						= ( Headset + 1 ) ,
+		UnknownDigitalPassthrough	= ( Handset + 1 ) ,
+		SPDIF						= ( UnknownDigitalPassthrough + 1 ) ,
+		HDMI						= ( SPDIF + 1 ) ,
+		UnknownFormFactor			= ( HDMI + 1 ) 
+	} 	
+	EndpointFormFactor;
+
+#endif
+
+#ifndef GUID_SECT
+    #define GUID_SECT
+#endif
+
+#define __DEFINE_GUID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const GUID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+#define __DEFINE_IID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const IID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+#define __DEFINE_CLSID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) static const CLSID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
+#define PA_DEFINE_CLSID(className, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    __DEFINE_CLSID(pa_CLSID_##className, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)
+#define PA_DEFINE_IID(interfaceName, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    __DEFINE_IID(pa_IID_##interfaceName, 0x##l, 0x##w1, 0x##w2, 0x##b1, 0x##b2, 0x##b3, 0x##b4, 0x##b5, 0x##b6, 0x##b7, 0x##b8)
+
+// "1CB9AD4C-DBFA-4c32-B178-C2F568A703B2"
+PA_DEFINE_IID(IAudioClient,         1cb9ad4c, dbfa, 4c32, b1, 78, c2, f5, 68, a7, 03, b2);
+// "726778CD-F60A-4EDA-82DE-E47610CD78AA"
+PA_DEFINE_IID(IAudioClient2,        726778cd, f60a, 4eda, 82, de, e4, 76, 10, cd, 78, aa);
+// "1BE09788-6894-4089-8586-9A2A6C265AC5"
+PA_DEFINE_IID(IMMEndpoint,          1be09788, 6894, 4089, 85, 86, 9a, 2a, 6c, 26, 5a, c5);
+// "A95664D2-9614-4F35-A746-DE8DB63617E6"
+PA_DEFINE_IID(IMMDeviceEnumerator,  a95664d2, 9614, 4f35, a7, 46, de, 8d, b6, 36, 17, e6);
+// "BCDE0395-E52F-467C-8E3D-C4579291692E"
+PA_DEFINE_CLSID(IMMDeviceEnumerator,bcde0395, e52f, 467c, 8e, 3d, c4, 57, 92, 91, 69, 2e);
+// "F294ACFC-3146-4483-A7BF-ADDCA7C260E2"
+PA_DEFINE_IID(IAudioRenderClient,   f294acfc, 3146, 4483, a7, bf, ad, dc, a7, c2, 60, e2);
+// "C8ADBD64-E71E-48a0-A4DE-185C395CD317"
+PA_DEFINE_IID(IAudioCaptureClient,  c8adbd64, e71e, 48a0, a4, de, 18, 5c, 39, 5c, d3, 17);
+// *2A07407E-6497-4A18-9787-32F79BD0D98F*  Or this??
+PA_DEFINE_IID(IDeviceTopology,      2A07407E, 6497, 4A18, 97, 87, 32, f7, 9b, d0, d9, 8f);
+// *AE2DE0E4-5BCA-4F2D-AA46-5D13F8FDB3A9*
+PA_DEFINE_IID(IPart,                AE2DE0E4, 5BCA, 4F2D, aa, 46, 5d, 13, f8, fd, b3, a9);
+// *4509F757-2D46-4637-8E62-CE7DB944F57B*
+PA_DEFINE_IID(IKsJackDescription,   4509F757, 2D46, 4637, 8e, 62, ce, 7d, b9, 44, f5, 7b);
+
+// Media formats:
+__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_PCM,        0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
+__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_ADPCM,      0x00000002, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
+__DEFINE_GUID(pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, 0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 );
+
+#ifdef __IAudioClient2_INTERFACE_DEFINED__
+typedef enum _pa_AUDCLNT_STREAMOPTIONS { 
+	pa_AUDCLNT_STREAMOPTIONS_NONE          = 0x00,
+	pa_AUDCLNT_STREAMOPTIONS_RAW           = 0x01,
+	pa_AUDCLNT_STREAMOPTIONS_MATCH_FORMAT  = 0x02
+} pa_AUDCLNT_STREAMOPTIONS;
+typedef struct _pa_AudioClientProperties {
+	UINT32                   cbSize;
+	BOOL                     bIsOffload;
+	AUDIO_STREAM_CATEGORY    eCategory;
+	pa_AUDCLNT_STREAMOPTIONS Options;
+} pa_AudioClientProperties;
+#define PA_AUDIOCLIENTPROPERTIES_SIZE_CATEGORY (sizeof(pa_AudioClientProperties) - sizeof(pa_AUDCLNT_STREAMOPTIONS))
+#define PA_AUDIOCLIENTPROPERTIES_SIZE_OPTIONS   sizeof(pa_AudioClientProperties)
+#endif // __IAudioClient2_INTERFACE_DEFINED__
+
+/* use CreateThread for CYGWIN/Windows Mobile, _beginthreadex for all others */
+#if !defined(__CYGWIN__) && !defined(_WIN32_WCE) && !defined(PA_WINRT)
+	#define CREATE_THREAD(PROC) (HANDLE)_beginthreadex( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
+	#define PA_THREAD_FUNC static unsigned WINAPI
+	#define PA_THREAD_ID unsigned
+#else
+	#define CREATE_THREAD(PROC) CreateThread( NULL, 0, (PROC), stream, 0, &stream->dwThreadId )
+	#define PA_THREAD_FUNC static DWORD WINAPI
+	#define PA_THREAD_ID DWORD
+#endif
+
+// Thread function forward decl.
+PA_THREAD_FUNC ProcThreadEvent(void *param);
+PA_THREAD_FUNC ProcThreadPoll(void *param);
+
+// Availabe from Windows 7
+#ifndef AUDCLNT_E_BUFFER_ERROR
+	#define AUDCLNT_E_BUFFER_ERROR AUDCLNT_ERR(0x018)
+#endif
+#ifndef AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
+	#define AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED AUDCLNT_ERR(0x019)
+#endif
+#ifndef AUDCLNT_E_INVALID_DEVICE_PERIOD
+	#define AUDCLNT_E_INVALID_DEVICE_PERIOD AUDCLNT_ERR(0x020)
+#endif
+
+#define MAX_STR_LEN 512
+
+enum { S_INPUT = 0, S_OUTPUT = 1, S_COUNT = 2, S_FULLDUPLEX = 0 };
+
+// Number of packets which compose single contignous buffer. With trial and error it was calculated
+// that WASAPI Input sub-system uses 6 packets per whole buffer. Please provide more information
+// or corrections if available.
+enum { WASAPI_PACKETS_PER_INPUT_BUFFER = 6 };
+
+#define STATIC_ARRAY_SIZE(array) (sizeof(array)/sizeof(array[0]))
+
+#define PRINT(x) PA_DEBUG(x);
+
+#define PA_SKELETON_SET_LAST_HOST_ERROR( errorCode, errorText ) \
+    PaUtil_SetLastHostErrorInfo( paWASAPI, errorCode, errorText )
+
+#define PA_WASAPI__IS_FULLDUPLEX(STREAM) ((STREAM)->in.clientProc && (STREAM)->out.clientProc)
+
+#ifndef IF_FAILED_JUMP
+#define IF_FAILED_JUMP(hr, label) if(FAILED(hr)) goto label;
+#endif
+
+#ifndef IF_FAILED_INTERNAL_ERROR_JUMP
+#define IF_FAILED_INTERNAL_ERROR_JUMP(hr, error, label) if(FAILED(hr)) { error = paInternalError; goto label; }
+#endif
+
+#define SAFE_CLOSE(h) if ((h) != NULL) { CloseHandle((h)); (h) = NULL; }
+#define SAFE_RELEASE(punk) if ((punk) != NULL) { (punk)->lpVtbl->Release((punk)); (punk) = NULL; }
+
+// Mixer function
+typedef void (*MixMonoToStereoF) (void *__to, void *__from, UINT32 count);
+
+// AVRT is the new "multimedia schedulling stuff"
+#ifndef PA_WINRT
+typedef BOOL   (WINAPI *FAvRtCreateThreadOrderingGroup)  (PHANDLE,PLARGE_INTEGER,GUID*,PLARGE_INTEGER);
+typedef BOOL   (WINAPI *FAvRtDeleteThreadOrderingGroup)  (HANDLE);
+typedef BOOL   (WINAPI *FAvRtWaitOnThreadOrderingGroup)  (HANDLE);
+typedef HANDLE (WINAPI *FAvSetMmThreadCharacteristics)   (LPCSTR,LPDWORD);
+typedef BOOL   (WINAPI *FAvRevertMmThreadCharacteristics)(HANDLE);
+typedef BOOL   (WINAPI *FAvSetMmThreadPriority)          (HANDLE,AVRT_PRIORITY);
+static HMODULE hDInputDLL = 0;
+FAvRtCreateThreadOrderingGroup   pAvRtCreateThreadOrderingGroup = NULL;
+FAvRtDeleteThreadOrderingGroup   pAvRtDeleteThreadOrderingGroup = NULL;
+FAvRtWaitOnThreadOrderingGroup   pAvRtWaitOnThreadOrderingGroup = NULL;
+FAvSetMmThreadCharacteristics    pAvSetMmThreadCharacteristics = NULL;
+FAvRevertMmThreadCharacteristics pAvRevertMmThreadCharacteristics = NULL;
+FAvSetMmThreadPriority           pAvSetMmThreadPriority = NULL;
+#endif
+
+#define _GetProc(fun, type, name)  {                                                        \
+                                        fun = (type) GetProcAddress(hDInputDLL,name);       \
+                                        if (fun == NULL) {                                  \
+                                            PRINT(("GetProcAddr failed for %s" ,name));     \
+                                            return FALSE;                                   \
+                                        }                                                   \
+                                    }                                                       \
+
+// ------------------------------------------------------------------------------------------
+/* prototypes for functions declared in this file */
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex index );
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+// dummy entry point for other compilers and sdks
+// currently built using RC1 SDK (5600)
+//#if _MSC_VER < 1400
+//PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
+//{
+    //return paNoError;
+//}
+//#else
+
+// ------------------------------------------------------------------------------------------
+static void Terminate( struct PaUtilHostApiRepresentation *hostApi );
+static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
+                                  const PaStreamParameters *inputParameters,
+                                  const PaStreamParameters *outputParameters,
+                                  double sampleRate );
+static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
+                           PaStream** s,
+                           const PaStreamParameters *inputParameters,
+                           const PaStreamParameters *outputParameters,
+                           double sampleRate,
+                           unsigned long framesPerBuffer,
+                           PaStreamFlags streamFlags,
+                           PaStreamCallback *streamCallback,
+                           void *userData );
+static PaError CloseStream( PaStream* stream );
+static PaError StartStream( PaStream *stream );
+static PaError StopStream( PaStream *stream );
+static PaError AbortStream( PaStream *stream );
+static PaError IsStreamStopped( PaStream *s );
+static PaError IsStreamActive( PaStream *stream );
+static PaTime GetStreamTime( PaStream *stream );
+static double GetStreamCpuLoad( PaStream* stream );
+static PaError ReadStream( PaStream* stream, void *buffer, unsigned long frames );
+static PaError WriteStream( PaStream* stream, const void *buffer, unsigned long frames );
+static signed long GetStreamReadAvailable( PaStream* stream );
+static signed long GetStreamWriteAvailable( PaStream* stream );
+
+// ------------------------------------------------------------------------------------------
+/*
+ These are fields that can be gathered from IDevice and IAudioDevice PRIOR to Initialize, and
+ done in first pass i assume that neither of these will cause the Driver to "load", but again,
+ who knows how they implement their stuff
+ */
+typedef struct PaWasapiDeviceInfo
+{
+    // Device
+#ifndef PA_WINRT
+    IMMDevice *device;
+#endif
+
+	// from GetId
+    WCHAR szDeviceID[MAX_STR_LEN];
+
+	// from GetState
+    DWORD state;
+
+    // Fields filled from IAudioDevice (_prior_ to Initialize)
+    // from GetDevicePeriod(
+    REFERENCE_TIME DefaultDevicePeriod;
+    REFERENCE_TIME MinimumDevicePeriod;
+
+	// Default format (setup through Control Panel by user)
+	WAVEFORMATEXTENSIBLE DefaultFormat;
+
+    // Fields filled from IMMEndpoint'sGetDataFlow
+    EDataFlow flow;
+
+	// Formfactor
+	EndpointFormFactor formFactor;
+}
+PaWasapiDeviceInfo;
+
+// ------------------------------------------------------------------------------------------
+/* PaWasapiHostApiRepresentation - host api datastructure specific to this implementation */
+typedef struct
+{
+    PaUtilHostApiRepresentation inheritedHostApiRep;
+    PaUtilStreamInterface       callbackStreamInterface;
+    PaUtilStreamInterface       blockingStreamInterface;
+
+    PaUtilAllocationGroup      *allocations;
+
+    /* implementation specific data goes here */
+
+    PaWinUtilComInitializationResult comInitializationResult;
+
+    //in case we later need the synch
+#ifndef PA_WINRT
+    IMMDeviceEnumerator *enumerator;
+#endif
+
+    //this is the REAL number of devices, whether they are usefull to PA or not!
+    UINT32 deviceCount;
+
+    WCHAR defaultRenderer [MAX_STR_LEN];
+    WCHAR defaultCapturer [MAX_STR_LEN];
+
+    PaWasapiDeviceInfo *devInfo;
+
+	// Is true when WOW64 Vista/7 Workaround is needed
+	BOOL useWOW64Workaround;
+}
+PaWasapiHostApiRepresentation;
+
+// ------------------------------------------------------------------------------------------
+/* PaWasapiAudioClientParams - audio client parameters */
+typedef struct PaWasapiAudioClientParams
+{
+	PaWasapiDeviceInfo *device_info;
+	PaStreamParameters  stream_params;
+	PaWasapiStreamInfo  wasapi_params;
+	UINT32              frames_per_buffer;
+	double              sample_rate;
+	BOOL                blocking;
+	BOOL                full_duplex;
+	BOOL                wow64_workaround;
+}
+PaWasapiAudioClientParams;
+
+// ------------------------------------------------------------------------------------------
+/* PaWasapiStream - a stream data structure specifically for this implementation */
+typedef struct PaWasapiSubStream
+{
+    IAudioClient        *clientParent;
+#ifndef PA_WINRT
+	IStream				*clientStream;
+#endif
+	IAudioClient		*clientProc;
+
+    WAVEFORMATEXTENSIBLE wavex;
+    UINT32               bufferSize;
+    REFERENCE_TIME       deviceLatency;
+    REFERENCE_TIME       period;
+	double				 latencySeconds;
+    UINT32				 framesPerHostCallback;
+	AUDCLNT_SHAREMODE    shareMode;
+	UINT32               streamFlags; // AUDCLNT_STREAMFLAGS_EVENTCALLBACK, ...
+	UINT32               flags;
+	PaWasapiAudioClientParams params; //!< parameters
+
+	// Buffers
+	UINT32               buffers;			//!< number of buffers used (from host side)
+	UINT32               framesPerBuffer;	//!< number of frames per 1 buffer
+	BOOL                 userBufferAndHostMatch;
+
+	// Used for Mono >> Stereo workaround, if driver does not support it
+	// (in Exclusive mode WASAPI usually refuses to operate with Mono (1-ch)
+	void                *monoBuffer;	 //!< pointer to buffer
+	UINT32               monoBufferSize; //!< buffer size in bytes
+	MixMonoToStereoF     monoMixer;		 //!< pointer to mixer function
+
+	PaUtilRingBuffer    *tailBuffer;       //!< buffer with trailing sample for blocking mode operations (only for Input)
+	void                *tailBufferMemory; //!< tail buffer memory region
+}
+PaWasapiSubStream;
+
+// ------------------------------------------------------------------------------------------
+/* PaWasapiHostProcessor - redirects processing data */
+typedef struct PaWasapiHostProcessor
+{
+    PaWasapiHostProcessorCallback processor;
+    void *userData;
+}
+PaWasapiHostProcessor;
+
+// ------------------------------------------------------------------------------------------
+typedef struct PaWasapiStream
+{
+	/* IMPLEMENT ME: rename this */
+    PaUtilStreamRepresentation streamRepresentation;
+    PaUtilCpuLoadMeasurer      cpuLoadMeasurer;
+    PaUtilBufferProcessor      bufferProcessor;
+
+    // input
+	PaWasapiSubStream          in;
+    IAudioCaptureClient       *captureClientParent;
+#ifndef PA_WINRT
+	IStream                   *captureClientStream;
+#endif
+	IAudioCaptureClient       *captureClient;
+    IAudioEndpointVolume      *inVol;
+
+	// output
+	PaWasapiSubStream          out;
+    IAudioRenderClient        *renderClientParent;
+#ifndef PA_WINRT
+	IStream                   *renderClientStream;
+#endif
+	IAudioRenderClient        *renderClient;
+	IAudioEndpointVolume      *outVol;
+
+	// event handles for event-driven processing mode
+	HANDLE event[S_COUNT];
+
+	// buffer mode
+	PaUtilHostBufferSizeMode bufferMode;
+
+	// must be volatile to avoid race condition on user query while
+	// thread is being started
+    volatile BOOL running;
+
+    PA_THREAD_ID dwThreadId;
+    HANDLE hThread;
+	HANDLE hCloseRequest;
+	HANDLE hThreadStart;        //!< signalled by thread on start
+	HANDLE hThreadExit;         //!< signalled by thread on exit
+	HANDLE hBlockingOpStreamRD;
+	HANDLE hBlockingOpStreamWR;
+
+    // Host callback Output overrider
+	PaWasapiHostProcessor hostProcessOverrideOutput;
+
+    // Host callback Input overrider
+	PaWasapiHostProcessor hostProcessOverrideInput;
+
+	// Defines blocking/callback interface used
+	BOOL bBlocking;
+
+	// Av Task (MM thread management)
+	HANDLE hAvTask;
+
+	// Thread priority level
+	PaWasapiThreadPriority nThreadPriority;
+}
+PaWasapiStream;
+
+// COM marshaling
+static HRESULT MarshalSubStreamComPointers(PaWasapiSubStream *substream);
+static HRESULT MarshalStreamComPointers(PaWasapiStream *stream);
+static HRESULT UnmarshalSubStreamComPointers(PaWasapiSubStream *substream);
+static HRESULT UnmarshalStreamComPointers(PaWasapiStream *stream);
+static void ReleaseUnmarshaledSubComPointers(PaWasapiSubStream *substream);
+static void ReleaseUnmarshaledComPointers(PaWasapiStream *stream);
+
+// Local stream methods
+static void _StreamOnStop(PaWasapiStream *stream);
+static void _StreamFinish(PaWasapiStream *stream);
+static void _StreamCleanup(PaWasapiStream *stream);
+static HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
+static HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available);
+static void *PaWasapi_ReallocateMemory(void *ptr, size_t size);
+static void PaWasapi_FreeMemory(void *ptr);
+
+// Local statics
+
+// ------------------------------------------------------------------------------------------
+#define LogHostError(HRES) __LogHostError(HRES, __FUNCTION__, __FILE__, __LINE__)
+static HRESULT __LogHostError(HRESULT res, const char *func, const char *file, int line)
+{
+    const char *text = NULL;
+    switch (res)
+	{
+	case S_OK: return res;
+	case E_POINTER                              :text ="E_POINTER"; break;
+	case E_INVALIDARG                           :text ="E_INVALIDARG"; break;
+
+	case AUDCLNT_E_NOT_INITIALIZED              :text ="AUDCLNT_E_NOT_INITIALIZED"; break;
+	case AUDCLNT_E_ALREADY_INITIALIZED          :text ="AUDCLNT_E_ALREADY_INITIALIZED"; break;
+	case AUDCLNT_E_WRONG_ENDPOINT_TYPE          :text ="AUDCLNT_E_WRONG_ENDPOINT_TYPE"; break;
+	case AUDCLNT_E_DEVICE_INVALIDATED           :text ="AUDCLNT_E_DEVICE_INVALIDATED"; break;
+	case AUDCLNT_E_NOT_STOPPED                  :text ="AUDCLNT_E_NOT_STOPPED"; break;
+	case AUDCLNT_E_BUFFER_TOO_LARGE             :text ="AUDCLNT_E_BUFFER_TOO_LARGE"; break;
+	case AUDCLNT_E_OUT_OF_ORDER                 :text ="AUDCLNT_E_OUT_OF_ORDER"; break;
+	case AUDCLNT_E_UNSUPPORTED_FORMAT           :text ="AUDCLNT_E_UNSUPPORTED_FORMAT"; break;
+	case AUDCLNT_E_INVALID_SIZE                 :text ="AUDCLNT_E_INVALID_SIZE"; break;
+	case AUDCLNT_E_DEVICE_IN_USE                :text ="AUDCLNT_E_DEVICE_IN_USE"; break;
+	case AUDCLNT_E_BUFFER_OPERATION_PENDING     :text ="AUDCLNT_E_BUFFER_OPERATION_PENDING"; break;
+	case AUDCLNT_E_THREAD_NOT_REGISTERED        :text ="AUDCLNT_E_THREAD_NOT_REGISTERED"; break;
+	case AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED   :text ="AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED"; break;
+	case AUDCLNT_E_ENDPOINT_CREATE_FAILED       :text ="AUDCLNT_E_ENDPOINT_CREATE_FAILED"; break;
+	case AUDCLNT_E_SERVICE_NOT_RUNNING          :text ="AUDCLNT_E_SERVICE_NOT_RUNNING"; break;
+	case AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED     :text ="AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED"; break;
+	case AUDCLNT_E_EXCLUSIVE_MODE_ONLY          :text ="AUDCLNT_E_EXCLUSIVE_MODE_ONLY"; break;
+	case AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL :text ="AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL"; break;
+	case AUDCLNT_E_EVENTHANDLE_NOT_SET          :text ="AUDCLNT_E_EVENTHANDLE_NOT_SET"; break;
+	case AUDCLNT_E_INCORRECT_BUFFER_SIZE        :text ="AUDCLNT_E_INCORRECT_BUFFER_SIZE"; break;
+	case AUDCLNT_E_BUFFER_SIZE_ERROR            :text ="AUDCLNT_E_BUFFER_SIZE_ERROR"; break;
+	case AUDCLNT_E_CPUUSAGE_EXCEEDED            :text ="AUDCLNT_E_CPUUSAGE_EXCEEDED"; break;
+	case AUDCLNT_E_BUFFER_ERROR					:text ="AUDCLNT_E_BUFFER_ERROR"; break;
+	case AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED		:text ="AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED"; break;
+	case AUDCLNT_E_INVALID_DEVICE_PERIOD		:text ="AUDCLNT_E_INVALID_DEVICE_PERIOD"; break;
+
+	case AUDCLNT_S_BUFFER_EMPTY                 :text ="AUDCLNT_S_BUFFER_EMPTY"; break;
+	case AUDCLNT_S_THREAD_ALREADY_REGISTERED    :text ="AUDCLNT_S_THREAD_ALREADY_REGISTERED"; break;
+	case AUDCLNT_S_POSITION_STALLED				:text ="AUDCLNT_S_POSITION_STALLED"; break;
+
+	// other windows common errors:
+	case CO_E_NOTINITIALIZED                    :text ="CO_E_NOTINITIALIZED: you must call CoInitialize() before Pa_OpenStream()"; break;
+
+	default:
+		text = "UNKNOWN ERROR";
+    }
+	PRINT(("WASAPI ERROR HRESULT: 0x%X : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", res, text, func, file, line));
+	PA_SKELETON_SET_LAST_HOST_ERROR(res, text);
+	return res;
+}
+
+// ------------------------------------------------------------------------------------------
+#define LogPaError(PAERR) __LogPaError(PAERR, __FUNCTION__, __FILE__, __LINE__)
+static PaError __LogPaError(PaError err, const char *func, const char *file, int line)
+{
+	if (err == paNoError)
+		return err;
+	PRINT(("WASAPI ERROR PAERROR: %i : %s\n [FUNCTION: %s FILE: %s {LINE: %d}]\n", err, Pa_GetErrorText(err), func, file, line));
+	return err;
+}
+
+// ------------------------------------------------------------------------------------------
+/*! \class ThreadSleepScheduler
+           Allows to emulate thread sleep of less than 1 millisecond under Windows. Scheduler
+		   calculates number of times the thread must run untill next sleep of 1 millisecond.
+		   It does not make thread sleeping for real number of microseconds but rather controls
+		   how many of imaginary microseconds the thread task can allow thread to sleep.
+*/
+typedef struct ThreadIdleScheduler
+{
+	UINT32 m_idle_microseconds; //!< number of microseconds to sleep
+	UINT32 m_next_sleep;        //!< next sleep round
+	UINT32 m_i;					//!< current round iterator position
+	UINT32 m_resolution;		//!< resolution in number of milliseconds
+}
+ThreadIdleScheduler;
+//! Setup scheduler.
+static void ThreadIdleScheduler_Setup(ThreadIdleScheduler *sched, UINT32 resolution, UINT32 microseconds)
+{
+	assert(microseconds != 0);
+	assert(resolution != 0);
+	assert((resolution * 1000) >= microseconds);
+
+	memset(sched, 0, sizeof(*sched));
+
+	sched->m_idle_microseconds = microseconds;
+	sched->m_resolution        = resolution;
+	sched->m_next_sleep        = (resolution * 1000) / microseconds;
+}
+//! Iterate and check if can sleep.
+static UINT32 ThreadIdleScheduler_NextSleep(ThreadIdleScheduler *sched)
+{
+	// advance and check if thread can sleep
+	if (++ sched->m_i == sched->m_next_sleep)
+	{
+		sched->m_i = 0;
+		return sched->m_resolution;
+	}
+	return 0;
+}
+
+// ------------------------------------------------------------------------------------------
+/*static double nano100ToMillis(REFERENCE_TIME ref)
+{
+    //  1 nano = 0.000000001 seconds
+    //100 nano = 0.0000001   seconds
+    //100 nano = 0.0001   milliseconds
+    return ((double)ref)*0.0001;
+}*/
+
+// ------------------------------------------------------------------------------------------
+static double nano100ToSeconds(REFERENCE_TIME ref)
+{
+    //  1 nano = 0.000000001 seconds
+    //100 nano = 0.0000001   seconds
+    //100 nano = 0.0001   milliseconds
+    return ((double)ref)*0.0000001;
+}
+
+// ------------------------------------------------------------------------------------------
+/*static REFERENCE_TIME MillisTonano100(double ref)
+{
+    //  1 nano = 0.000000001 seconds
+    //100 nano = 0.0000001   seconds
+    //100 nano = 0.0001   milliseconds
+    return (REFERENCE_TIME)(ref/0.0001);
+}*/
+
+// ------------------------------------------------------------------------------------------
+static REFERENCE_TIME SecondsTonano100(double ref)
+{
+    //  1 nano = 0.000000001 seconds
+    //100 nano = 0.0000001   seconds
+    //100 nano = 0.0001   milliseconds
+    return (REFERENCE_TIME)(ref/0.0000001);
+}
+
+// ------------------------------------------------------------------------------------------
+// Makes Hns period from frames and sample rate
+static REFERENCE_TIME MakeHnsPeriod(UINT32 nFrames, DWORD nSamplesPerSec)
+{
+	return (REFERENCE_TIME)((10000.0 * 1000 / nSamplesPerSec * nFrames) + 0.5);
+}
+
+// ------------------------------------------------------------------------------------------
+// Converts PaSampleFormat to bits per sample value
+static WORD PaSampleFormatToBitsPerSample(PaSampleFormat format_id)
+{
+	switch (format_id & ~paNonInterleaved)
+	{
+		case paFloat32:
+		case paInt32: return 32;
+		case paInt24: return 24;
+		case paInt16: return 16;
+		case paInt8:
+		case paUInt8: return 8;
+	}
+	return 0;
+}
+
+// ------------------------------------------------------------------------------------------
+// Converts PaSampleFormat to bits per sample value
+/*static WORD PaSampleFormatToBytesPerSample(PaSampleFormat format_id)
+{
+	return PaSampleFormatToBitsPerSample(format_id) >> 3; // 'bits/8'
+}*/
+
+// ------------------------------------------------------------------------------------------
+// Converts Hns period into number of frames
+static UINT32 MakeFramesFromHns(REFERENCE_TIME hnsPeriod, UINT32 nSamplesPerSec)
+{
+    UINT32 nFrames = (UINT32)(	// frames =
+        1.0 * hnsPeriod *		// hns *
+        nSamplesPerSec /		// (frames / s) /
+        1000 /					// (ms / s) /
+        10000					// (hns / s) /
+        + 0.5					// rounding
+    );
+	return nFrames;
+}
+
+// Aligning function type
+typedef UINT32 (*ALIGN_FUNC) (UINT32 v, UINT32 align);
+
+// ------------------------------------------------------------------------------------------
+// Aligns 'v' backwards
+static UINT32 ALIGN_BWD(UINT32 v, UINT32 align)
+{
+	return ((v - (align ? v % align : 0)));
+}
+
+// ------------------------------------------------------------------------------------------
+// Aligns 'v' forward
+static UINT32 ALIGN_FWD(UINT32 v, UINT32 align)
+{
+	UINT32 remainder = (align ? (v % align) : 0);
+	if (remainder == 0)
+		return v;
+	return v + (align - remainder);
+}
+
+// ------------------------------------------------------------------------------------------
+// Get next value power of 2
+UINT32 ALIGN_NEXT_POW2(UINT32 v)
+{
+	UINT32 v2 = 1;
+	while (v > (v2 <<= 1)) { }
+	v = v2;
+	return v;
+}
+
+// ------------------------------------------------------------------------------------------
+// Aligns WASAPI buffer to 128 byte packet boundary. HD Audio will fail to play if buffer
+// is misaligned. This problem was solved in Windows 7 were AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED
+// is thrown although we must align for Vista anyway.
+static UINT32 AlignFramesPerBuffer(UINT32 nFrames, UINT32 nSamplesPerSec, UINT32 nBlockAlign,
+								   ALIGN_FUNC pAlignFunc)
+{
+#define HDA_PACKET_SIZE (128)
+
+	long frame_bytes = nFrames * nBlockAlign;
+	long packets;
+	(void)nSamplesPerSec;
+
+	// align to packet size
+	frame_bytes  = pAlignFunc(frame_bytes, HDA_PACKET_SIZE); // use ALIGN_FWD if bigger but safer period is more desired
+
+	// atlest 1 frame must be available
+	if (frame_bytes < HDA_PACKET_SIZE)
+		frame_bytes = HDA_PACKET_SIZE;
+
+	nFrames      = frame_bytes / nBlockAlign;
+	packets      = frame_bytes / HDA_PACKET_SIZE;
+
+	frame_bytes = packets * HDA_PACKET_SIZE;
+	nFrames     = frame_bytes / nBlockAlign;
+
+	return nFrames;
+
+#undef HDA_PACKET_SIZE
+}
+
+// ------------------------------------------------------------------------------------------
+static UINT32 GetFramesSleepTime(UINT32 nFrames, UINT32 nSamplesPerSec)
+{
+	REFERENCE_TIME nDuration;
+	if (nSamplesPerSec == 0)
+		return 0;
+#define REFTIMES_PER_SEC  10000000
+#define REFTIMES_PER_MILLISEC  10000
+	// Calculate the actual duration of the allocated buffer.
+	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
+	return (UINT32)(nDuration/REFTIMES_PER_MILLISEC/2);
+}
+
+// ------------------------------------------------------------------------------------------
+static UINT32 GetFramesSleepTimeMicroseconds(UINT32 nFrames, UINT32 nSamplesPerSec)
+{
+	REFERENCE_TIME nDuration;
+	if (nSamplesPerSec == 0)
+		return 0;
+#define REFTIMES_PER_SEC  10000000
+#define REFTIMES_PER_MILLISEC  10000
+	// Calculate the actual duration of the allocated buffer.
+	nDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC * nFrames / nSamplesPerSec);
+	return (UINT32)(nDuration/10/2);
+}
+
+// ------------------------------------------------------------------------------------------
+#ifndef PA_WINRT
+static BOOL SetupAVRT()
+{
+    hDInputDLL = LoadLibraryA("avrt.dll");
+    if (hDInputDLL == NULL)
+        return FALSE;
+
+    _GetProc(pAvRtCreateThreadOrderingGroup,  FAvRtCreateThreadOrderingGroup,  "AvRtCreateThreadOrderingGroup");
+    _GetProc(pAvRtDeleteThreadOrderingGroup,  FAvRtDeleteThreadOrderingGroup,  "AvRtDeleteThreadOrderingGroup");
+    _GetProc(pAvRtWaitOnThreadOrderingGroup,  FAvRtWaitOnThreadOrderingGroup,  "AvRtWaitOnThreadOrderingGroup");
+    _GetProc(pAvSetMmThreadCharacteristics,   FAvSetMmThreadCharacteristics,   "AvSetMmThreadCharacteristicsA");
+	_GetProc(pAvRevertMmThreadCharacteristics,FAvRevertMmThreadCharacteristics,"AvRevertMmThreadCharacteristics");
+    _GetProc(pAvSetMmThreadPriority,          FAvSetMmThreadPriority,          "AvSetMmThreadPriority");
+
+	return pAvRtCreateThreadOrderingGroup &&
+		pAvRtDeleteThreadOrderingGroup &&
+		pAvRtWaitOnThreadOrderingGroup &&
+		pAvSetMmThreadCharacteristics &&
+		pAvRevertMmThreadCharacteristics &&
+		pAvSetMmThreadPriority;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+static void CloseAVRT()
+{
+#ifndef PA_WINRT
+	if (hDInputDLL != NULL)
+		FreeLibrary(hDInputDLL);
+	hDInputDLL = NULL;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+static BOOL IsWow64()
+{
+#ifndef PA_WINRT
+
+	// http://msdn.microsoft.com/en-us/library/ms684139(VS.85).aspx
+
+	typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
+	LPFN_ISWOW64PROCESS fnIsWow64Process;
+
+    BOOL bIsWow64 = FALSE;
+
+    // IsWow64Process is not available on all supported versions of Windows.
+    // Use GetModuleHandle to get a handle to the DLL that contains the function
+    // and GetProcAddress to get a pointer to the function if available.
+
+    fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress(
+        GetModuleHandleA("kernel32"), "IsWow64Process");
+
+    if (fnIsWow64Process == NULL)
+		return FALSE;
+
+    if (!fnIsWow64Process(GetCurrentProcess(), &bIsWow64))
+		return FALSE;
+
+    return bIsWow64;
+
+#else
+
+	return FALSE;
+
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+typedef enum EWindowsVersion
+{
+	WINDOWS_UNKNOWN = 0,
+	WINDOWS_VISTA_SERVER2008,
+	WINDOWS_7_SERVER2008R2,
+	WINDOWS_8_SERVER2012,
+	WINDOWS_8_1_SERVER2012R2,
+	WINDOWS_10_SERVER2016,
+	WINDOWS_FUTURE
+}
+EWindowsVersion;
+// Alternative way for checking Windows version (allows to check version on Windows 8.1 and up)
+#ifndef PA_WINRT
+static BOOL IsWindowsVersionOrGreater(WORD wMajorVersion, WORD wMinorVersion, WORD wServicePackMajor)
+{
+	typedef ULONGLONG (NTAPI *LPFN_VERSETCONDITIONMASK)(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
+	typedef BOOL (WINAPI *LPFN_VERIFYVERSIONINFO)(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
+
+	LPFN_VERSETCONDITIONMASK fnVerSetConditionMask;
+	LPFN_VERIFYVERSIONINFO fnVerifyVersionInfo;
+	OSVERSIONINFOEXA osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };
+	DWORDLONG dwlConditionMask;
+
+	fnVerSetConditionMask = (LPFN_VERSETCONDITIONMASK)GetProcAddress(GetModuleHandleA("kernel32"), "VerSetConditionMask");
+	fnVerifyVersionInfo = (LPFN_VERIFYVERSIONINFO)GetProcAddress(GetModuleHandleA("kernel32"), "VerifyVersionInfoA");
+
+	if ((fnVerSetConditionMask == NULL) || (fnVerifyVersionInfo == NULL))
+		return FALSE;
+
+	dwlConditionMask = fnVerSetConditionMask(
+		fnVerSetConditionMask(
+			fnVerSetConditionMask(
+				0, VER_MAJORVERSION,     VER_GREATER_EQUAL),
+				   VER_MINORVERSION,     VER_GREATER_EQUAL),
+				   VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);
+
+	osvi.dwMajorVersion    = wMajorVersion;
+	osvi.dwMinorVersion    = wMinorVersion;
+	osvi.wServicePackMajor = wServicePackMajor;
+
+	return (fnVerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, dwlConditionMask) != FALSE);
+}
+#endif
+// Get Windows version
+static EWindowsVersion GetWindowsVersion()
+{
+#ifndef PA_WINRT
+	static EWindowsVersion version = WINDOWS_UNKNOWN;
+
+	if (version == WINDOWS_UNKNOWN)
+	{
+		DWORD dwVersion = 0;
+		DWORD dwMajorVersion = 0;
+		DWORD dwMinorVersion = 0;
+		DWORD dwBuild = 0;
+
+		typedef DWORD (WINAPI *LPFN_GETVERSION)(VOID);
+		LPFN_GETVERSION fnGetVersion;
+
+		fnGetVersion = (LPFN_GETVERSION)GetProcAddress(GetModuleHandleA("kernel32"), "GetVersion");
+		if (fnGetVersion != NULL)
+		{
+			PRINT(("WASAPI: getting Windows version with GetVersion()\n"));
+
+			dwVersion = fnGetVersion();
+
+			// Get the Windows version
+			dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
+			dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));
+
+			// Get the build number
+			if (dwVersion < 0x80000000)
+				dwBuild = (DWORD)(HIWORD(dwVersion));
+
+			switch (dwMajorVersion)
+			{
+			case 0:
+			case 1:
+			case 2:
+			case 3:
+			case 4:
+			case 5:
+				break; // skip lower
+			case 6:
+				switch (dwMinorVersion)
+				{
+				case 0:  version = WINDOWS_VISTA_SERVER2008;	break;
+				case 1:	 version = WINDOWS_7_SERVER2008R2;		break;
+				case 2:	 version = WINDOWS_8_SERVER2012;  		break;
+				case 3:	 version = WINDOWS_8_1_SERVER2012R2;	break;
+				default: version = WINDOWS_FUTURE;				break;
+				}
+				break;
+			case 10:
+				switch (dwMinorVersion)
+				{
+				case 0:	 version = WINDOWS_10_SERVER2016;		break;
+				default: version = WINDOWS_FUTURE;				break;
+				}
+				break;
+			default:
+				version = WINDOWS_FUTURE;
+				break;
+			}
+		}
+		else
+		{
+			PRINT(("WASAPI: getting Windows version with VerifyVersionInfo()\n"));
+
+			if (IsWindowsVersionOrGreater(10, 0, 0))
+				version = WINDOWS_10_SERVER2016;
+			else
+			if (IsWindowsVersionOrGreater(6, 3, 0))
+				version = WINDOWS_8_1_SERVER2012R2;
+			else
+			if (IsWindowsVersionOrGreater(6, 2, 0))
+				version = WINDOWS_8_SERVER2012;
+			else
+			if (IsWindowsVersionOrGreater(6, 1, 0))
+				version = WINDOWS_7_SERVER2008R2;
+			else
+			if (IsWindowsVersionOrGreater(6, 0, 0))
+				version = WINDOWS_VISTA_SERVER2008;
+			else
+				version = WINDOWS_FUTURE;
+		}
+
+		PRINT(("WASAPI: Windows version = %d\n", version));
+	}
+
+	return version;
+#else
+	return WINDOWS_8_SERVER2012;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+static BOOL UseWOW64Workaround()
+{
+	// note: WOW64 bug is common to Windows Vista x64, thus we fall back to safe Poll-driven
+	//       method. Windows 7 x64 seems has WOW64 bug fixed.
+
+	return (IsWow64() && (GetWindowsVersion() == WINDOWS_VISTA_SERVER2008));
+}
+
+// ------------------------------------------------------------------------------------------
+static UINT32 GetAudioClientVersion()
+{
+	if (GetWindowsVersion() >= WINDOWS_10_SERVER2016)
+		return 3;
+	else
+	if (GetWindowsVersion() >= WINDOWS_8_SERVER2012)
+		return 2;
+
+	return 1;
+}
+
+// ------------------------------------------------------------------------------------------
+static const IID *GetAudioClientIID()
+{
+	static const IID *cli_iid = NULL;
+	if (cli_iid == NULL)
+	{
+		UINT32 cli_version = GetAudioClientVersion();
+		if (cli_version <= 1)
+		{
+			cli_iid = &pa_IID_IAudioClient;
+		}
+		else
+		{
+			switch (cli_version)
+			{
+			case 3:  cli_iid = &pa_IID_IAudioClient2; cli_version = 2; break; // use IAudioClient2 for Windows 10+ until IAudioClient3 functions are required
+			default: cli_iid = &pa_IID_IAudioClient2; cli_version = 2; break;
+			}
+		}
+
+		PRINT(("WASAPI: IAudioClient version = %d\n", cli_version));
+	}
+
+	return cli_iid;
+}
+
+// ------------------------------------------------------------------------------------------
+typedef enum EMixerDir { MIX_DIR__1TO2, MIX_DIR__2TO1, MIX_DIR__2TO1_L } EMixerDir;
+
+// ------------------------------------------------------------------------------------------
+#define _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(TYPE)\
+	TYPE * __restrict to   = __to;\
+	TYPE * __restrict from = __from;\
+	TYPE * __restrict end  = from + count;\
+	while (from != end)\
+	{\
+		*to ++ = *from;\
+		*to ++ = *from;\
+		++ from;\
+	}
+
+// ------------------------------------------------------------------------------------------
+#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(TYPE)\
+	TYPE * __restrict to   = (TYPE *)__to;\
+	TYPE * __restrict from = (TYPE *)__from;\
+	TYPE * __restrict end  = to + count;\
+	while (to != end)\
+	{\
+		*to ++ = (TYPE)((float)(from[0] + from[1]) * 0.5f);\
+		from += 2;\
+	}
+
+// ------------------------------------------------------------------------------------------
+#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(TYPE)\
+	TYPE * __restrict to   = (TYPE *)__to;\
+	TYPE * __restrict from = (TYPE *)__from;\
+	TYPE * __restrict end  = to + count;\
+	while (to != end)\
+	{\
+		*to ++ = (TYPE)(((INT32)from[0] + (INT32)from[1]) >> 1);\
+		from += 2;\
+	}
+
+// ------------------------------------------------------------------------------------------
+#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(TYPE)\
+	TYPE * __restrict to   = (TYPE *)__to;\
+	TYPE * __restrict from = (TYPE *)__from;\
+	TYPE * __restrict end  = to + count;\
+	while (to != end)\
+	{\
+		*to ++ = (TYPE)(((INT64)from[0] + (INT64)from[1]) >> 1);\
+		from += 2;\
+	}
+
+// ------------------------------------------------------------------------------------------
+#define _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(TYPE)\
+	TYPE * __restrict to   = (TYPE *)__to;\
+	TYPE * __restrict from = (TYPE *)__from;\
+	TYPE * __restrict end  = to + count;\
+	while (to != end)\
+	{\
+		*to ++ = from[0];\
+		from += 2;\
+	}
+
+// ------------------------------------------------------------------------------------------
+static void _MixMonoToStereo_1TO2_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(BYTE); }
+static void _MixMonoToStereo_1TO2_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(short); }
+static void _MixMonoToStereo_1TO2_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); /* !!! int24 data is contained in 32-bit containers*/ }
+static void _MixMonoToStereo_1TO2_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(int); }
+static void _MixMonoToStereo_1TO2_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_1_TO_2(float); }
+
+// ------------------------------------------------------------------------------------------
+static void _MixMonoToStereo_2TO1_8(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(BYTE); }
+static void _MixMonoToStereo_2TO1_16(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(short); }
+static void _MixMonoToStereo_2TO1_24(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT32(int); /* !!! int24 data is contained in 32-bit containers*/ }
+static void _MixMonoToStereo_2TO1_32(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_INT64(int); }
+static void _MixMonoToStereo_2TO1_32f(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_FLT32(float); }
+
+// ------------------------------------------------------------------------------------------
+static void _MixMonoToStereo_2TO1_8_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(BYTE); }
+static void _MixMonoToStereo_2TO1_16_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(short); }
+static void _MixMonoToStereo_2TO1_24_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); /* !!! int24 data is contained in 32-bit containers*/ }
+static void _MixMonoToStereo_2TO1_32_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(int); }
+static void _MixMonoToStereo_2TO1_32f_L(void *__to, void *__from, UINT32 count) { _WASAPI_MONO_TO_STEREO_MIXER_2_TO_1_L(float); }
+
+// ------------------------------------------------------------------------------------------
+static MixMonoToStereoF _GetMonoToStereoMixer(PaSampleFormat format, EMixerDir dir)
+{
+	switch (dir)
+	{
+	case MIX_DIR__1TO2:
+		switch (format & ~paNonInterleaved)
+		{
+		case paUInt8:	return _MixMonoToStereo_1TO2_8;
+		case paInt16:	return _MixMonoToStereo_1TO2_16;
+		case paInt24:	return _MixMonoToStereo_1TO2_24;
+		case paInt32:	return _MixMonoToStereo_1TO2_32;
+		case paFloat32: return _MixMonoToStereo_1TO2_32f;
+		}
+		break;
+
+	case MIX_DIR__2TO1:
+		switch (format & ~paNonInterleaved)
+		{
+		case paUInt8:	return _MixMonoToStereo_2TO1_8;
+		case paInt16:	return _MixMonoToStereo_2TO1_16;
+		case paInt24:	return _MixMonoToStereo_2TO1_24;
+		case paInt32:	return _MixMonoToStereo_2TO1_32;
+		case paFloat32: return _MixMonoToStereo_2TO1_32f;
+		}
+		break;
+
+	case MIX_DIR__2TO1_L:
+		switch (format & ~paNonInterleaved)
+		{
+		case paUInt8:	return _MixMonoToStereo_2TO1_8_L;
+		case paInt16:	return _MixMonoToStereo_2TO1_16_L;
+		case paInt24:	return _MixMonoToStereo_2TO1_24_L;
+		case paInt32:	return _MixMonoToStereo_2TO1_32_L;
+		case paFloat32: return _MixMonoToStereo_2TO1_32f_L;
+		}
+		break;
+	}
+
+	return NULL;
+}
+
+// ------------------------------------------------------------------------------------------
+#ifdef PA_WINRT
+typedef struct PaActivateAudioInterfaceCompletionHandler
+{
+	IActivateAudioInterfaceCompletionHandler parent;
+	volatile LONG refs;
+	volatile LONG done;
+	struct
+	{
+		const IID *iid;
+		void **obj;
+	}
+	in;
+	struct
+	{
+		HRESULT hr;
+	}
+	out;
+}
+PaActivateAudioInterfaceCompletionHandler;
+
+static HRESULT (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_QueryInterface)( 
+    IActivateAudioInterfaceCompletionHandler *This, REFIID riid, void **ppvObject)
+{
+	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;
+
+	// From MSDN:
+	// "The IAgileObject interface is a marker interface that indicates that an object 
+	//  is free threaded and can be called from any apartment."
+	if (IsEqualIID(riid, &IID_IUnknown) || 
+		IsEqualIID(riid, &IID_IAgileObject))
+	{
+		IActivateAudioInterfaceCompletionHandler_AddRef((IActivateAudioInterfaceCompletionHandler *)handler);
+		(*ppvObject) = handler;
+		return S_OK;
+	}
+
+	return E_NOINTERFACE;
+}
+        
+static ULONG (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_AddRef)( 
+    IActivateAudioInterfaceCompletionHandler *This)
+{
+	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;
+
+	return InterlockedIncrement(&handler->refs);
+}
+        
+static ULONG (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_Release)( 
+    IActivateAudioInterfaceCompletionHandler *This)
+{
+	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;
+	ULONG refs;
+
+	if ((refs = InterlockedDecrement(&handler->refs)) == 0)
+	{
+		PaUtil_FreeMemory(handler->parent.lpVtbl);
+		PaUtil_FreeMemory(handler);
+	}
+
+	return refs;
+}
+        
+static HRESULT (STDMETHODCALLTYPE PaActivateAudioInterfaceCompletionHandler_ActivateCompleted)( 
+    IActivateAudioInterfaceCompletionHandler *This, IActivateAudioInterfaceAsyncOperation *activateOperation)
+{
+	PaActivateAudioInterfaceCompletionHandler *handler = (PaActivateAudioInterfaceCompletionHandler *)This;
+
+    HRESULT hr = S_OK;
+    HRESULT hrActivateResult = S_OK;
+    IUnknown *punkAudioInterface = NULL;
+ 
+    // Check for a successful activation result
+    hr = IActivateAudioInterfaceAsyncOperation_GetActivateResult(activateOperation, &hrActivateResult, &punkAudioInterface);
+    if (SUCCEEDED(hr) && SUCCEEDED(hrActivateResult))
+    {
+        // Get pointer to the requested audio interface
+        IUnknown_QueryInterface(punkAudioInterface, handler->in.iid, handler->in.obj);
+        if ((*handler->in.obj) == NULL)
+            hrActivateResult = E_FAIL;
+	}
+	SAFE_RELEASE(punkAudioInterface);
+
+	if (SUCCEEDED(hr))
+		handler->out.hr = hrActivateResult;
+	else
+		handler->out.hr = hr;
+	
+	// Got client object, stop busy waiting in ActivateAudioInterface
+	InterlockedExchange(&handler->done, TRUE);
+
+	return hr;
+}
+
+static IActivateAudioInterfaceCompletionHandler *CreateActivateAudioInterfaceCompletionHandler(const IID *iid, void **obj)
+{
+	PaActivateAudioInterfaceCompletionHandler *handler = PaUtil_AllocateMemory(sizeof(PaActivateAudioInterfaceCompletionHandler));
+	ZeroMemory(handler, sizeof(*handler));
+	handler->parent.lpVtbl = PaUtil_AllocateMemory(sizeof(*handler->parent.lpVtbl));
+	handler->parent.lpVtbl->QueryInterface    = &PaActivateAudioInterfaceCompletionHandler_QueryInterface;
+	handler->parent.lpVtbl->AddRef            = &PaActivateAudioInterfaceCompletionHandler_AddRef;
+	handler->parent.lpVtbl->Release           = &PaActivateAudioInterfaceCompletionHandler_Release;
+	handler->parent.lpVtbl->ActivateCompleted = &PaActivateAudioInterfaceCompletionHandler_ActivateCompleted;
+	handler->refs = 1;
+	handler->in.iid = iid;
+	handler->in.obj = obj;
+	return (IActivateAudioInterfaceCompletionHandler *)handler;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+#ifdef PA_WINRT
+static HRESULT ActivateAudioInterface_WINRT(const PaWasapiDeviceInfo *deviceInfo, const IID *iid, void **obj)
+{
+#define PA_WASAPI_DEVICE_PATH_LEN 64
+	
+	PaError result = paNoError;
+	HRESULT hr = S_OK;
+	IActivateAudioInterfaceAsyncOperation *asyncOp = NULL;
+	IActivateAudioInterfaceCompletionHandler *handler = CreateActivateAudioInterfaceCompletionHandler(iid, obj);
+	PaActivateAudioInterfaceCompletionHandler *handlerImpl = (PaActivateAudioInterfaceCompletionHandler *)handler;
+	OLECHAR devicePath[PA_WASAPI_DEVICE_PATH_LEN] = { 0 };
+
+    const GUID guid1 = { 0xe6327cad, 0xdcec, 0x4949, 0xae, 0x8a, 0x99, 0x1e, 0x97, 0x6a, 0x79, 0xd2 };
+    const GUID guid2 = { 0x2eef81be, 0x33fa, 0x4800, 0x96, 0x70, 0x1c, 0xd4, 0x74, 0x97, 0x2c, 0x3f };
+	// Get device path in form L"{DEVICE_GUID}"
+	switch (deviceInfo->flow)
+	{
+	case eRender:
+		//StringFromGUID2(&DEVINTERFACE_AUDIO_RENDER, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
+        StringFromGUID2(&guid1, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
+		break;
+	case eCapture:
+		//StringFromGUID2(&DEVINTERFACE_AUDIO_CAPTURE, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
+        StringFromGUID2(&guid2, devicePath, PA_WASAPI_DEVICE_PATH_LEN - 1);
+		break;
+	default:
+		return S_FALSE;
+	}	
+
+	// Async operation will call back to IActivateAudioInterfaceCompletionHandler::ActivateCompleted 
+	// which must be an agile interface implementation
+    hr = ActivateAudioInterfaceAsync(devicePath, iid, NULL, handler, &asyncOp);
+    IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+	// Wait in busy loop for async operation to complete
+	// Use Interlocked API here to ensure that ->done variable is read every time through the loop
+	while (SUCCEEDED(hr) && !InterlockedOr(&handlerImpl->done, 0))
+	{
+		Sleep(1);
+	}
+
+	hr = handlerImpl->out.hr;
+
+error:
+
+	SAFE_RELEASE(asyncOp);
+	SAFE_RELEASE(handler);
+
+    return hr;
+	
+#undef PA_WASAPI_DEVICE_PATH_LEN
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+static HRESULT ActivateAudioInterface(const PaWasapiDeviceInfo *deviceInfo, IAudioClient **client)
+{
+#ifndef PA_WINRT
+	return IMMDevice_Activate(deviceInfo->device, GetAudioClientIID(), CLSCTX_ALL, NULL, (void **)client);
+#else
+	return ActivateAudioInterface_WINRT(deviceInfo, GetAudioClientIID(), (void **)client);
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+#ifdef PA_WINRT
+static DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
+{
+	SetEvent(hObjectToSignal);
+	return WaitForSingleObjectEx(hObjectToWaitOn, dwMilliseconds, bAlertable);
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiIndex hostApiIndex )
+{
+    PaError result = paNoError;
+    PaWasapiHostApiRepresentation *paWasapi;
+    PaDeviceInfo *deviceInfoArray;
+    HRESULT hr = S_OK;
+	UINT i;
+#ifndef PA_WINRT
+    IMMDeviceCollection* pEndPoints = NULL;
+#else
+	WAVEFORMATEX *mixFormat;
+#endif
+
+#ifndef PA_WINRT
+    if (!SetupAVRT())
+	{
+        PRINT(("WASAPI: No AVRT! (not VISTA?)"));
+        return paNoError;
+    }
+#endif
+
+    paWasapi = (PaWasapiHostApiRepresentation *)PaUtil_AllocateMemory( sizeof(PaWasapiHostApiRepresentation) );
+    if (paWasapi == NULL)
+	{
+        result = paInsufficientMemory;
+        goto error;
+    }
+	
+    memset( paWasapi, 0, sizeof(PaWasapiHostApiRepresentation) ); /* ensure all fields are zeroed. especially paWasapi->allocations */
+
+    result = PaWinUtil_CoInitialize( paWASAPI, &paWasapi->comInitializationResult );
+    if( result != paNoError )
+    {
+        goto error;
+    }
+
+    paWasapi->allocations = PaUtil_CreateAllocationGroup();
+    if (paWasapi->allocations == NULL)
+	{
+        result = paInsufficientMemory;
+        goto error;
+    }
+
+    *hostApi                             = &paWasapi->inheritedHostApiRep;
+    (*hostApi)->info.structVersion		 = 1;
+    (*hostApi)->info.type				 = paWASAPI;
+    (*hostApi)->info.name				 = "Windows WASAPI";
+    (*hostApi)->info.deviceCount		 = 0;
+    (*hostApi)->info.defaultInputDevice	 = paNoDevice;
+    (*hostApi)->info.defaultOutputDevice = paNoDevice;
+
+#ifndef PA_WINRT
+    paWasapi->enumerator = NULL;
+    hr = CoCreateInstance(&pa_CLSID_IMMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER,
+             &pa_IID_IMMDeviceEnumerator, (void **)&paWasapi->enumerator);
+    
+	// We need to set the result to a value otherwise we will return paNoError
+	// [IF_FAILED_JUMP(hResult, error);]
+	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+    // getting default device ids in the eMultimedia "role"
+    {
+        {
+            IMMDevice *defaultRenderer = NULL;
+            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eRender, eMultimedia, &defaultRenderer);
+            if (hr != S_OK)
+			{
+				if (hr != E_NOTFOUND) {
+					// We need to set the result to a value otherwise we will return paNoError
+					// [IF_FAILED_JUMP(hResult, error);]
+					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+				}
+			}
+			else
+			{
+				WCHAR *pszDeviceId = NULL;
+				hr = IMMDevice_GetId(defaultRenderer, &pszDeviceId);
+				// We need to set the result to a value otherwise we will return paNoError
+				// [IF_FAILED_JUMP(hResult, error);]
+				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+				wcsncpy(paWasapi->defaultRenderer, pszDeviceId, MAX_STR_LEN-1);
+				CoTaskMemFree(pszDeviceId);
+				IMMDevice_Release(defaultRenderer);
+			}
+        }
+
+        {
+            IMMDevice *defaultCapturer = NULL;
+            hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(paWasapi->enumerator, eCapture, eMultimedia, &defaultCapturer);
+            if (hr != S_OK)
+			{
+				if (hr != E_NOTFOUND) {
+					// We need to set the result to a value otherwise we will return paNoError
+					// [IF_FAILED_JUMP(hResult, error);]
+					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+				}
+			}
+			else
+			{
+				WCHAR *pszDeviceId = NULL;
+				hr = IMMDevice_GetId(defaultCapturer, &pszDeviceId);
+				// We need to set the result to a value otherwise we will return paNoError
+				// [IF_FAILED_JUMP(hResult, error);]
+				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+				wcsncpy(paWasapi->defaultCapturer, pszDeviceId, MAX_STR_LEN-1);
+				CoTaskMemFree(pszDeviceId);
+				IMMDevice_Release(defaultCapturer);
+			}
+        }
+    }
+
+    hr = IMMDeviceEnumerator_EnumAudioEndpoints(paWasapi->enumerator, eAll, DEVICE_STATE_ACTIVE, &pEndPoints);
+	// We need to set the result to a value otherwise we will return paNoError
+	// [IF_FAILED_JUMP(hResult, error);]
+	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+    hr = IMMDeviceCollection_GetCount(pEndPoints, &paWasapi->deviceCount);
+	// We need to set the result to a value otherwise we will return paNoError
+	// [IF_FAILED_JUMP(hResult, error);]
+	IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+#else
+	paWasapi->deviceCount = 2;
+#endif
+
+    paWasapi->devInfo = (PaWasapiDeviceInfo *)PaUtil_AllocateMemory(sizeof(PaWasapiDeviceInfo) * paWasapi->deviceCount);
+    if (paWasapi->devInfo == NULL)
+	{
+        result = paInsufficientMemory;
+        goto error;
+    }
+	for (i = 0; i < paWasapi->deviceCount; ++i)
+		memset(&paWasapi->devInfo[i], 0, sizeof(PaWasapiDeviceInfo));
+
+    if (paWasapi->deviceCount > 0)
+    {
+        (*hostApi)->deviceInfos = (PaDeviceInfo **)PaUtil_GroupAllocateMemory(
+                paWasapi->allocations, sizeof(PaDeviceInfo *) * paWasapi->deviceCount);
+        if ((*hostApi)->deviceInfos == NULL)
+		{
+            result = paInsufficientMemory;
+            goto error;
+        }
+
+        /* allocate all device info structs in a contiguous block */
+        deviceInfoArray = (PaDeviceInfo *)PaUtil_GroupAllocateMemory(
+                paWasapi->allocations, sizeof(PaDeviceInfo) * paWasapi->deviceCount);
+        if (deviceInfoArray == NULL)
+		{
+            result = paInsufficientMemory;
+            goto error;
+        }
+
+        for (i = 0; i < paWasapi->deviceCount; ++i)
+		{
+            PaDeviceInfo *deviceInfo  = &deviceInfoArray[i];
+            deviceInfo->structVersion = 2;
+            deviceInfo->hostApi       = hostApiIndex;
+
+			PA_DEBUG(("WASAPI: device idx: %02d\n", i));
+			PA_DEBUG(("WASAPI: ---------------\n"));
+
+		#ifndef PA_WINRT
+            hr = IMMDeviceCollection_Item(pEndPoints, i, &paWasapi->devInfo[i].device);
+			// We need to set the result to a value otherwise we will return paNoError
+			// [IF_FAILED_JUMP(hResult, error);]
+			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+            // getting ID
+            {
+                WCHAR *pszDeviceId = NULL;
+                hr = IMMDevice_GetId(paWasapi->devInfo[i].device, &pszDeviceId);
+				// We need to set the result to a value otherwise we will return paNoError
+				// [IF_FAILED_JUMP(hr, error);]
+				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+                wcsncpy(paWasapi->devInfo[i].szDeviceID, pszDeviceId, MAX_STR_LEN-1);
+                CoTaskMemFree(pszDeviceId);
+
+                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultCapturer) == 0)
+				{// we found the default input!
+                    (*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
+                }
+                if (lstrcmpW(paWasapi->devInfo[i].szDeviceID, paWasapi->defaultRenderer) == 0)
+				{// we found the default output!
+                    (*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
+                }
+            }
+
+            hr = IMMDevice_GetState(paWasapi->devInfo[i].device, &paWasapi->devInfo[i].state);
+			// We need to set the result to a value otherwise we will return paNoError
+			// [IF_FAILED_JUMP(hResult, error);]
+			IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+            if (paWasapi->devInfo[i].state != DEVICE_STATE_ACTIVE)
+			{
+                PRINT(("WASAPI device: %d is not currently available (state:%d)\n", i, paWasapi->devInfo[i].state));
+            }
+
+            {
+                IPropertyStore *pProperty;
+                hr = IMMDevice_OpenPropertyStore(paWasapi->devInfo[i].device, STGM_READ, &pProperty);
+				// We need to set the result to a value otherwise we will return paNoError
+				// [IF_FAILED_JUMP(hResult, error);]
+				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+                // "Friendly" Name
+                {
+					char *deviceName;
+                    PROPVARIANT value;
+                    PropVariantInit(&value);
+                    hr = IPropertyStore_GetValue(pProperty, &PKEY_Device_FriendlyName, &value);
+					// We need to set the result to a value otherwise we will return paNoError
+					// [IF_FAILED_JUMP(hResult, error);]
+					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+                    deviceInfo->name = NULL;
+                    deviceName = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
+                    if (deviceName == NULL)
+					{
+                        result = paInsufficientMemory;
+                        goto error;
+                    }
+					if (value.pwszVal)
+						WideCharToMultiByte(CP_UTF8, 0, value.pwszVal, (int)wcslen(value.pwszVal), deviceName, MAX_STR_LEN - 1, 0, 0);
+					else
+						_snprintf(deviceName, MAX_STR_LEN - 1, "baddev%d", i);
+                    deviceInfo->name = deviceName;
+                    PropVariantClear(&value);
+					PA_DEBUG(("WASAPI:%d| name[%s]\n", i, deviceInfo->name));
+                }
+
+                // Default format
+                {
+                    PROPVARIANT value;
+                    PropVariantInit(&value);
+                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEngine_DeviceFormat, &value);
+					// We need to set the result to a value otherwise we will return paNoError
+					// [IF_FAILED_JUMP(hResult, error);]
+					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+					memcpy(&paWasapi->devInfo[i].DefaultFormat, value.blob.pBlobData, min(sizeof(paWasapi->devInfo[i].DefaultFormat), value.blob.cbSize));
+                    // cleanup
+                    PropVariantClear(&value);
+                }
+
+                // Formfactor
+                {
+                    PROPVARIANT value;
+                    PropVariantInit(&value);
+                    hr = IPropertyStore_GetValue(pProperty, &PKEY_AudioEndpoint_FormFactor, &value);
+					// We need to set the result to a value otherwise we will return paNoError
+					// [IF_FAILED_JUMP(hResult, error);]
+					IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+					// set
+					#if defined(DUMMYUNIONNAME) && defined(NONAMELESSUNION)
+						// avoid breaking strict-aliasing rules in such line: (EndpointFormFactor)(*((UINT *)(((WORD *)&value.wReserved3)+1)));
+						UINT v;
+						memcpy(&v, (((WORD *)&value.wReserved3)+1), sizeof(v));
+						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)v;
+					#else
+						paWasapi->devInfo[i].formFactor = (EndpointFormFactor)value.uintVal;
+					#endif
+					PA_DEBUG(("WASAPI:%d| form-factor[%d]\n", i, paWasapi->devInfo[i].formFactor));
+                    // cleanup
+                    PropVariantClear(&value);
+                }
+
+				SAFE_RELEASE(pProperty);
+            }
+			
+            // Endpoint data
+            {
+                IMMEndpoint *endpoint = NULL;
+                hr = IMMDevice_QueryInterface(paWasapi->devInfo[i].device, &pa_IID_IMMEndpoint, (void **)&endpoint);
+                if (SUCCEEDED(hr))
+				{
+                    hr = IMMEndpoint_GetDataFlow(endpoint, &paWasapi->devInfo[i].flow);
+                    SAFE_RELEASE(endpoint);
+                }
+            }
+		#endif
+
+            // Getting a temporary IAudioClient for more fields
+            // we make sure NOT to call Initialize yet!
+            {
+			#ifdef PA_WINRT
+				// Set flow as ActivateAudioInterface depends on it and selects corresponding 
+				// direction for the Audio Client
+				paWasapi->devInfo[i].flow = (i == 0 ? eRender : eCapture);
+			#endif
+
+				// Create temp Audio Client instance to query additional details
+                IAudioClient *tmpClient = NULL;
+                hr = ActivateAudioInterface(&paWasapi->devInfo[i], &tmpClient);
+				// We need to set the result to a value otherwise we will return paNoError
+				// [IF_FAILED_JUMP(hResult, error);]
+				IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+				// Get latency
+                hr = IAudioClient_GetDevicePeriod(tmpClient,
+                    &paWasapi->devInfo[i].DefaultDevicePeriod,
+                    &paWasapi->devInfo[i].MinimumDevicePeriod);
+				if (FAILED(hr))
+				{
+					PA_DEBUG(("WASAPI:%d| failed getting min/default periods by IAudioClient::GetDevicePeriod() with error[%08X], will use 30000/100000 hns\n", i, (UINT32)hr));
+
+					// assign WASAPI common values
+					paWasapi->devInfo[i].DefaultDevicePeriod = 100000;
+					paWasapi->devInfo[i].MinimumDevicePeriod = 30000;
+
+					// ignore error, let continue further without failing with paInternalError
+					hr = S_OK;
+				}
+				
+			#ifdef PA_WINRT
+				// Get mix format which will treat as default device format
+				hr = IAudioClient_GetMixFormat(tmpClient, &mixFormat);
+				if (SUCCEEDED(hr))
+				{
+					// Default device
+					if (i == 0)
+						(*hostApi)->info.defaultOutputDevice = (*hostApi)->info.deviceCount;
+					else
+						(*hostApi)->info.defaultInputDevice = (*hostApi)->info.deviceCount;
+
+					// State
+					paWasapi->devInfo[i].state = DEVICE_STATE_ACTIVE;
+
+					// Default format
+					memcpy(&paWasapi->devInfo[i].DefaultFormat, mixFormat, min(sizeof(paWasapi->devInfo[i].DefaultFormat), sizeof(*mixFormat)));
+					CoTaskMemFree(mixFormat);
+
+					// Form-factor
+					paWasapi->devInfo[i].formFactor = UnknownFormFactor;
+
+					// Name
+                    deviceInfo->name = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
+                    if (deviceInfo->name == NULL)
+					{
+						SAFE_RELEASE(tmpClient);
+                        result = paInsufficientMemory;
+                        goto error;
+                    }
+					_snprintf((char *)deviceInfo->name, MAX_STR_LEN - 1, "WASAPI_%s:%d", (i == 0 ? "Output" : "Input"), i);
+					PA_DEBUG(("WASAPI:%d| name[%s]\n", i, deviceInfo->name));
+				}
+			#endif
+
+				// Release tmp client
+				SAFE_RELEASE(tmpClient);
+
+				if (hr != S_OK)
+				{
+					//davidv: this happened with my hardware, previously for that same device in DirectSound:
+					//Digital Output (Realtek AC'97 Audio)'s GUID: {0x38f2cf50,0x7b4c,0x4740,0x86,0xeb,0xd4,0x38,0x66,0xd8,0xc8, 0x9f}
+					//so something must be _really_ wrong with this device, TODO handle this better. We kind of need GetMixFormat
+					LogHostError(hr);
+					// We need to set the result to a value otherwise we will return paNoError
+					result = paInternalError;
+					goto error;
+				}
+            }
+			
+            // we can now fill in portaudio device data
+            deviceInfo->maxInputChannels  = 0;
+            deviceInfo->maxOutputChannels = 0;
+			deviceInfo->defaultSampleRate = paWasapi->devInfo[i].DefaultFormat.Format.nSamplesPerSec;
+            switch (paWasapi->devInfo[i].flow)
+			{
+			case eRender: {
+                deviceInfo->maxOutputChannels		 = paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
+                deviceInfo->defaultHighOutputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
+                deviceInfo->defaultLowOutputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
+				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
+					deviceInfo->maxOutputChannels, (float)deviceInfo->defaultHighOutputLatency, (float)deviceInfo->defaultLowOutputLatency));
+				break;}
+			case eCapture: {
+                deviceInfo->maxInputChannels		= paWasapi->devInfo[i].DefaultFormat.Format.nChannels;
+                deviceInfo->defaultHighInputLatency = nano100ToSeconds(paWasapi->devInfo[i].DefaultDevicePeriod);
+                deviceInfo->defaultLowInputLatency  = nano100ToSeconds(paWasapi->devInfo[i].MinimumDevicePeriod);
+				PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
+					deviceInfo->maxInputChannels, (float)deviceInfo->defaultHighInputLatency, (float)deviceInfo->defaultLowInputLatency));
+				break; }
+            default:
+                PRINT(("WASAPI:%d| bad Data Flow!\n", i));
+				// We need to set the result to a value otherwise we will return paNoError
+				result = paInternalError;
+                //continue; // do not skip from list, allow to initialize
+				 break;
+            }
+
+            (*hostApi)->deviceInfos[i] = deviceInfo;
+            ++(*hostApi)->info.deviceCount;
+        }
+    }
+
+    (*hostApi)->Terminate = Terminate;
+    (*hostApi)->OpenStream = OpenStream;
+    (*hostApi)->IsFormatSupported = IsFormatSupported;
+
+    PaUtil_InitializeStreamInterface( &paWasapi->callbackStreamInterface, CloseStream, StartStream,
+                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
+                                      GetStreamTime, GetStreamCpuLoad,
+                                      PaUtil_DummyRead, PaUtil_DummyWrite,
+                                      PaUtil_DummyGetReadAvailable, PaUtil_DummyGetWriteAvailable );
+
+    PaUtil_InitializeStreamInterface( &paWasapi->blockingStreamInterface, CloseStream, StartStream,
+                                      StopStream, AbortStream, IsStreamStopped, IsStreamActive,
+                                      GetStreamTime, PaUtil_DummyGetCpuLoad,
+                                      ReadStream, WriteStream, GetStreamReadAvailable, GetStreamWriteAvailable );
+
+
+	// findout if platform workaround is required
+	paWasapi->useWOW64Workaround = UseWOW64Workaround();
+
+#ifndef PA_WINRT
+    SAFE_RELEASE(pEndPoints);
+#endif
+
+	PRINT(("WASAPI: initialized ok\n"));
+
+    return paNoError;
+
+error:
+
+	PRINT(("WASAPI: failed %s error[%d|%s]\n", __FUNCTION__, result, Pa_GetErrorText(result)));
+
+#ifndef PA_WINRT
+    SAFE_RELEASE(pEndPoints);
+#endif
+
+	Terminate((PaUtilHostApiRepresentation *)paWasapi);
+
+	// Safety if error was not set so that we do not think initialize was a success
+	if (result == paNoError) {
+		result = paInternalError;
+	}
+
+    return result;
+}
+
+// ------------------------------------------------------------------------------------------
+static void Terminate( PaUtilHostApiRepresentation *hostApi )
+{
+	UINT i;
+    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
+	if (paWasapi == NULL)
+		return;
+
+	// Release IMMDeviceEnumerator
+#ifndef PA_WINRT
+    SAFE_RELEASE(paWasapi->enumerator);
+#endif
+
+	// Release device info bound objects and device info itself
+    for (i = 0; i < paWasapi->deviceCount; ++i)
+	{
+        PaWasapiDeviceInfo *info = &paWasapi->devInfo[i];
+	#ifndef PA_WINRT
+        SAFE_RELEASE(info->device);
+	#else
+		(void)info;
+	#endif
+    }
+    PaUtil_FreeMemory(paWasapi->devInfo);
+
+    if (paWasapi->allocations)
+	{
+        PaUtil_FreeAllAllocations(paWasapi->allocations);
+        PaUtil_DestroyAllocationGroup(paWasapi->allocations);
+    }
+
+    PaWinUtil_CoUninitialize( paWASAPI, &paWasapi->comInitializationResult );
+
+    PaUtil_FreeMemory(paWasapi);
+
+	// Close AVRT
+	CloseAVRT();
+}
+
+// ------------------------------------------------------------------------------------------
+static PaWasapiHostApiRepresentation *_GetHostApi(PaError *_error)
+{
+	PaError error;
+
+	PaUtilHostApiRepresentation *pApi;
+	if ((error = PaUtil_GetHostApiRepresentation(&pApi, paWASAPI)) != paNoError)
+	{
+		if (_error != NULL)
+			(*_error) = error;
+
+		return NULL;
+	}
+	return (PaWasapiHostApiRepresentation *)pApi;
+}
+
+// ------------------------------------------------------------------------------------------
+int PaWasapi_GetDeviceDefaultFormat( void *pFormat, unsigned int nFormatSize, PaDeviceIndex nDevice )
+{
+	PaError ret;
+	PaWasapiHostApiRepresentation *paWasapi;
+	UINT32 size;
+	PaDeviceIndex index;
+
+	if (pFormat == NULL)
+		return paBadBufferPtr;
+	if (nFormatSize <= 0)
+		return paBufferTooSmall;
+
+	// Get API
+	paWasapi = _GetHostApi(&ret);
+	if (paWasapi == NULL)
+		return ret;
+
+	// Get device index
+	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
+    if (ret != paNoError)
+        return ret;
+
+	// Validate index
+	if ((UINT32)index >= paWasapi->deviceCount)
+		return paInvalidDevice;
+
+	size = min(nFormatSize, (UINT32)sizeof(paWasapi->devInfo[ index ].DefaultFormat));
+	memcpy(pFormat, &paWasapi->devInfo[ index ].DefaultFormat, size);
+
+	return size;
+}
+
+// ------------------------------------------------------------------------------------------
+int PaWasapi_GetDeviceRole( PaDeviceIndex nDevice )
+{
+	PaError ret;
+	PaDeviceIndex index;
+
+	// Get API
+	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
+	if (paWasapi == NULL)
+		return paNotInitialized;
+
+	// Get device index
+	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
+    if (ret != paNoError)
+        return ret;
+
+	// Validate index
+	if ((UINT32)index >= paWasapi->deviceCount)
+		return paInvalidDevice;
+
+	return paWasapi->devInfo[ index ].formFactor;
+}
+
+// ------------------------------------------------------------------------------------------
+PaError PaWasapi_GetFramesPerHostBuffer( PaStream *pStream, unsigned int *nInput, unsigned int *nOutput )
+{
+    PaWasapiStream *stream = (PaWasapiStream *)pStream;
+	if (stream == NULL)
+		return paBadStreamPtr;
+
+	if (nInput != NULL)
+		(*nInput) = stream->in.framesPerHostCallback;
+
+	if (nOutput != NULL)
+		(*nOutput) = stream->out.framesPerHostCallback;
+
+	return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+static void LogWAVEFORMATEXTENSIBLE(const WAVEFORMATEXTENSIBLE *in)
+{
+    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;
+	switch (old->wFormatTag)
+	{
+	case WAVE_FORMAT_EXTENSIBLE: {
+
+		PRINT(("wFormatTag     =WAVE_FORMAT_EXTENSIBLE\n"));
+
+		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+		{
+			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\n"));
+		}
+		else
+		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
+		{
+			PRINT(("SubFormat      =KSDATAFORMAT_SUBTYPE_PCM\n"));
+		}
+		else
+		{
+			PRINT(("SubFormat      =CUSTOM GUID{%d:%d:%d:%d%d%d%d%d%d%d%d}\n",
+										in->SubFormat.Data1,
+										in->SubFormat.Data2,
+										in->SubFormat.Data3,
+										(int)in->SubFormat.Data4[0],
+										(int)in->SubFormat.Data4[1],
+										(int)in->SubFormat.Data4[2],
+										(int)in->SubFormat.Data4[3],
+										(int)in->SubFormat.Data4[4],
+										(int)in->SubFormat.Data4[5],
+										(int)in->SubFormat.Data4[6],
+										(int)in->SubFormat.Data4[7]));
+		}
+		PRINT(("Samples.wValidBitsPerSample =%d\n",  in->Samples.wValidBitsPerSample));
+		PRINT(("dwChannelMask  =0x%X\n",in->dwChannelMask));
+
+		break; }
+
+	case WAVE_FORMAT_PCM:        PRINT(("wFormatTag     =WAVE_FORMAT_PCM\n")); break;
+	case WAVE_FORMAT_IEEE_FLOAT: PRINT(("wFormatTag     =WAVE_FORMAT_IEEE_FLOAT\n")); break;
+	default: 
+		PRINT(("wFormatTag     =UNKNOWN(%d)\n",old->wFormatTag)); break;
+	}
+
+	PRINT(("nChannels      =%d\n",old->nChannels));
+	PRINT(("nSamplesPerSec =%d\n",old->nSamplesPerSec));
+	PRINT(("nAvgBytesPerSec=%d\n",old->nAvgBytesPerSec));
+	PRINT(("nBlockAlign    =%d\n",old->nBlockAlign));
+	PRINT(("wBitsPerSample =%d\n",old->wBitsPerSample));
+	PRINT(("cbSize         =%d\n",old->cbSize));
+}
+
+// ------------------------------------------------------------------------------------------
+static PaSampleFormat WaveToPaFormat(const WAVEFORMATEXTENSIBLE *in)
+{
+    const WAVEFORMATEX *old = (WAVEFORMATEX *)in;
+
+    switch (old->wFormatTag)
+	{
+    case WAVE_FORMAT_EXTENSIBLE: {
+        if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+		{
+            if (in->Samples.wValidBitsPerSample == 32)
+                return paFloat32;
+        }
+        else
+		if (IsEqualGUID(&in->SubFormat, &pa_KSDATAFORMAT_SUBTYPE_PCM))
+		{
+            switch (old->wBitsPerSample)
+			{
+                case 32: return paInt32;
+                case 24: return paInt24;
+                case  8: return paUInt8;
+                case 16: return paInt16;
+            }
+        }
+		break; }
+
+    case WAVE_FORMAT_IEEE_FLOAT:
+		return paFloat32;
+
+    case WAVE_FORMAT_PCM: {
+        switch (old->wBitsPerSample)
+		{
+            case 32: return paInt32;
+            case 24: return paInt24;
+            case  8: return paUInt8;
+            case 16: return paInt16;
+        }
+		break; }
+    }
+
+    return paCustomFormat;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError MakeWaveFormatFromParams(WAVEFORMATEXTENSIBLE *wavex, const PaStreamParameters *params,
+									double sampleRate)
+{
+	WORD bitsPerSample;
+	WAVEFORMATEX *old;
+	DWORD channelMask = 0;
+	PaWasapiStreamInfo *streamInfo = (PaWasapiStreamInfo *)params->hostApiSpecificStreamInfo;
+
+	// Get user assigned channel mask
+	if ((streamInfo != NULL) && (streamInfo->flags & paWinWasapiUseChannelMask))
+		channelMask = streamInfo->channelMask;
+
+	// Convert PaSampleFormat to bits per sample
+	if ((bitsPerSample = PaSampleFormatToBitsPerSample(params->sampleFormat)) == 0)
+		return paSampleFormatNotSupported;
+
+    memset(wavex, 0, sizeof(*wavex));
+
+    old					 = (WAVEFORMATEX *)wavex;
+    old->nChannels       = (WORD)params->channelCount;
+    old->nSamplesPerSec  = (DWORD)sampleRate;
+	if ((old->wBitsPerSample = bitsPerSample) > 16)
+	{
+		old->wBitsPerSample = 32; // 20 or 24 bits must go in 32 bit containers (ints)
+	}
+    old->nBlockAlign     = (old->nChannels * (old->wBitsPerSample/8));
+    old->nAvgBytesPerSec = (old->nSamplesPerSec * old->nBlockAlign);
+
+    // WAVEFORMATEX
+    if ((params->channelCount <= 2) && ((bitsPerSample == 16) || (bitsPerSample == 8)))
+	{
+        old->cbSize		= 0;
+        old->wFormatTag	= WAVE_FORMAT_PCM;
+    }
+    // WAVEFORMATEXTENSIBLE
+    else
+	{
+        old->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+        old->cbSize		= sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+
+        if ((params->sampleFormat & ~paNonInterleaved) == paFloat32)
+            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+        else
+            wavex->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
+
+        wavex->Samples.wValidBitsPerSample = bitsPerSample; //no extra padding!
+
+		// Set channel mask
+		if (channelMask != 0)
+		{
+			wavex->dwChannelMask = channelMask;
+		}
+		else
+		{
+			switch (params->channelCount)
+			{
+			case 1:  wavex->dwChannelMask = PAWIN_SPEAKER_MONO; break;
+			case 2:  wavex->dwChannelMask = PAWIN_SPEAKER_STEREO; break;
+			case 3:  wavex->dwChannelMask = PAWIN_SPEAKER_STEREO|SPEAKER_LOW_FREQUENCY; break;
+			case 4:  wavex->dwChannelMask = PAWIN_SPEAKER_QUAD; break;
+			case 5:  wavex->dwChannelMask = PAWIN_SPEAKER_QUAD|SPEAKER_LOW_FREQUENCY; break;
+#ifdef PAWIN_SPEAKER_5POINT1_SURROUND
+			case 6:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1_SURROUND; break;
+#else
+			case 6:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1; break;
+#endif
+#ifdef PAWIN_SPEAKER_5POINT1_SURROUND
+			case 7:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1_SURROUND|SPEAKER_BACK_CENTER; break;
+#else
+			case 7:  wavex->dwChannelMask = PAWIN_SPEAKER_5POINT1|SPEAKER_BACK_CENTER; break;
+#endif	
+#ifdef PAWIN_SPEAKER_7POINT1_SURROUND
+			case 8:  wavex->dwChannelMask = PAWIN_SPEAKER_7POINT1_SURROUND; break;
+#else
+			case 8:  wavex->dwChannelMask = PAWIN_SPEAKER_7POINT1; break;
+#endif
+
+			default: wavex->dwChannelMask = 0;
+			}
+		}
+	}
+    return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+/*static void wasapiFillWFEXT( WAVEFORMATEXTENSIBLE* pwfext, PaSampleFormat sampleFormat, double sampleRate, int channelCount)
+{
+    PA_DEBUG(( "sampleFormat = %lx\n" , sampleFormat ));
+    PA_DEBUG(( "sampleRate = %f\n" , sampleRate ));
+    PA_DEBUG(( "chanelCount = %d\n", channelCount ));
+
+    pwfext->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    pwfext->Format.nChannels = (WORD)channelCount;
+    pwfext->Format.nSamplesPerSec = (DWORD)sampleRate;
+    if(channelCount == 1)
+        pwfext->dwChannelMask = PAWIN_SPEAKER_DIRECTOUT;
+    else
+        pwfext->dwChannelMask = PAWIN_SPEAKER_STEREO;
+    if(sampleFormat == paFloat32)
+    {
+        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
+        pwfext->Format.wBitsPerSample = 32;
+        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+        pwfext->Samples.wValidBitsPerSample = 32;
+        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+    }
+    else if(sampleFormat == paInt32)
+    {
+        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
+        pwfext->Format.wBitsPerSample = 32;
+        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+        pwfext->Samples.wValidBitsPerSample = 32;
+        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
+    }
+    else if(sampleFormat == paInt24)
+    {
+        pwfext->Format.nBlockAlign = (WORD)(channelCount * 4);
+        pwfext->Format.wBitsPerSample = 32; // 24-bit in 32-bit int container
+        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+        pwfext->Samples.wValidBitsPerSample = 24;
+        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
+    }
+    else if(sampleFormat == paInt16)
+    {
+        pwfext->Format.nBlockAlign = (WORD)(channelCount * 2);
+        pwfext->Format.wBitsPerSample = 16;
+        pwfext->Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE)-sizeof(WAVEFORMATEX);
+        pwfext->Samples.wValidBitsPerSample = 16;
+        pwfext->SubFormat = pa_KSDATAFORMAT_SUBTYPE_PCM;
+    }
+    pwfext->Format.nAvgBytesPerSec = pwfext->Format.nSamplesPerSec * pwfext->Format.nBlockAlign;
+}*/
+
+// ------------------------------------------------------------------------------------------
+static PaError GetClosestFormat(IAudioClient *myClient, double sampleRate,
+	const PaStreamParameters *_params, AUDCLNT_SHAREMODE shareMode, WAVEFORMATEXTENSIBLE *outWavex,
+	BOOL output)
+{
+	PaError answer                   = paInvalidSampleRate;
+	WAVEFORMATEX *sharedClosestMatch = NULL;
+	HRESULT hr                       = !S_OK;
+	PaStreamParameters params       = (*_params);
+	(void)output;
+
+	/* It was not noticed that 24-bit Input producing no output while device accepts this format.
+	   To fix this issue let's ask for 32-bits and let PA converters convert host 32-bit data
+	   to 24-bit for user-space. The bug concerns Vista, if Windows 7 supports 24-bits for Input
+	   please report to PortAudio developers to exclude Windows 7.
+	*/
+	/*if ((params.sampleFormat == paInt24) && (output == FALSE))
+		params.sampleFormat = paFloat32;*/ // <<< The silence was due to missing Int32_To_Int24_Dither implementation
+
+    MakeWaveFormatFromParams(outWavex, &params, sampleRate);
+
+	hr = IAudioClient_IsFormatSupported(myClient, shareMode, &outWavex->Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
+	if (hr == S_OK)
+		answer = paFormatIsSupported;
+    else
+	if (sharedClosestMatch)
+	{
+		WORD bitsPerSample;
+        WAVEFORMATEXTENSIBLE *ext = (WAVEFORMATEXTENSIBLE*)sharedClosestMatch;
+
+		GUID subf_guid = GUID_NULL;
+		if (sharedClosestMatch->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+		{
+			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEXTENSIBLE));
+			subf_guid = ext->SubFormat;
+		}
+		else
+			memcpy(outWavex, sharedClosestMatch, sizeof(WAVEFORMATEX));
+
+        CoTaskMemFree(sharedClosestMatch);
+
+		// Make supported by default
+		answer = paFormatIsSupported;
+
+		// Validate SampleRate
+		if ((DWORD)sampleRate != outWavex->Format.nSamplesPerSec)
+			return paInvalidSampleRate;
+
+		// Validate Channel count
+		if ((WORD)params.channelCount != outWavex->Format.nChannels)
+		{
+			// If mono, then driver does not support 1 channel, we use internal workaround
+			// of tiny software mixing functionality, e.g. we provide to user buffer 1 channel
+			// but then mix into 2 for device buffer
+			if ((params.channelCount == 1) && (outWavex->Format.nChannels == 2))
+				return paFormatIsSupported;
+			else
+				return paInvalidChannelCount;
+		}
+
+		// Validate Sample format
+		if ((bitsPerSample = PaSampleFormatToBitsPerSample(params.sampleFormat)) == 0)
+			return paSampleFormatNotSupported;
+
+		// Validate Sample format: bit size (WASAPI does not limit 'bit size')
+		//if (bitsPerSample != outWavex->Format.wBitsPerSample)
+		//	return paSampleFormatNotSupported;
+
+		// Validate Sample format: paFloat32 (WASAPI does not limit 'bit type')
+		//if ((params->sampleFormat == paFloat32) && (subf_guid != KSDATAFORMAT_SUBTYPE_IEEE_FLOAT))
+		//	return paSampleFormatNotSupported;
+
+		// Validate Sample format: paInt32 (WASAPI does not limit 'bit type')
+		//if ((params->sampleFormat == paInt32) && (subf_guid != KSDATAFORMAT_SUBTYPE_PCM))
+		//	return paSampleFormatNotSupported;
+	}
+	else
+	{
+		static const int BestToWorst[] = { paFloat32, paInt24, paInt16 };
+		int i;
+
+		// Try combination stereo and we will use built-in mono-stereo mixer then
+		if (params.channelCount == 1)
+		{
+			WAVEFORMATEXTENSIBLE stereo = { 0 };
+
+			PaStreamParameters stereo_params = params;
+			stereo_params.channelCount = 2;
+
+			MakeWaveFormatFromParams(&stereo, &stereo_params, sampleRate);
+
+			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &stereo.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
+			if (hr == S_OK)
+			{
+				memcpy(outWavex, &stereo, sizeof(WAVEFORMATEXTENSIBLE));
+				CoTaskMemFree(sharedClosestMatch);
+				return (answer = paFormatIsSupported);
+			}
+
+			// Try selecting suitable sample type
+			for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
+			{
+				WAVEFORMATEXTENSIBLE sample = { 0 };
+
+				PaStreamParameters sample_params = stereo_params;
+				sample_params.sampleFormat = BestToWorst[i];
+
+				MakeWaveFormatFromParams(&sample, &sample_params, sampleRate);
+
+				hr = IAudioClient_IsFormatSupported(myClient, shareMode, &sample.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
+				if (hr == S_OK)
+				{
+					memcpy(outWavex, &sample, sizeof(WAVEFORMATEXTENSIBLE));
+					CoTaskMemFree(sharedClosestMatch);
+					return (answer = paFormatIsSupported);
+				}
+			}
+		}
+
+		// Try selecting suitable sample type
+		for (i = 0; i < STATIC_ARRAY_SIZE(BestToWorst); ++i)
+		{
+			WAVEFORMATEXTENSIBLE spfmt = { 0 };
+
+			PaStreamParameters spfmt_params = params;
+			spfmt_params.sampleFormat = BestToWorst[i];
+
+			MakeWaveFormatFromParams(&spfmt, &spfmt_params, sampleRate);
+
+			hr = IAudioClient_IsFormatSupported(myClient, shareMode, &spfmt.Format, (shareMode == AUDCLNT_SHAREMODE_SHARED ? &sharedClosestMatch : NULL));
+			if (hr == S_OK)
+			{
+				memcpy(outWavex, &spfmt, sizeof(WAVEFORMATEXTENSIBLE));
+				CoTaskMemFree(sharedClosestMatch);
+				answer = paFormatIsSupported;
+				break;
+			}
+		}
+
+		// Nothing helped
+		LogHostError(hr);
+	}
+
+	return answer;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError IsStreamParamsValid(struct PaUtilHostApiRepresentation *hostApi,
+                                   const  PaStreamParameters *inputParameters,
+                                   const  PaStreamParameters *outputParameters,
+                                   double sampleRate)
+{
+	if (hostApi == NULL)
+		return paHostApiNotFound;
+	if ((UINT32)sampleRate == 0)
+		return paInvalidSampleRate;
+
+	if (inputParameters != NULL)
+    {
+        /* all standard sample formats are supported by the buffer adapter,
+            this implementation doesn't support any custom sample formats */
+		if (inputParameters->sampleFormat & paCustomFormat)
+            return paSampleFormatNotSupported;
+
+        /* unless alternate device specification is supported, reject the use of
+            paUseHostApiSpecificDeviceSpecification */
+        if (inputParameters->device == paUseHostApiSpecificDeviceSpecification)
+            return paInvalidDevice;
+
+        /* check that input device can support inputChannelCount */
+        if (inputParameters->channelCount > hostApi->deviceInfos[ inputParameters->device ]->maxInputChannels)
+            return paInvalidChannelCount;
+
+        /* validate inputStreamInfo */
+        if (inputParameters->hostApiSpecificStreamInfo)
+		{
+			PaWasapiStreamInfo *inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
+	        if ((inputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
+	            (inputStreamInfo->version != 1) ||
+                (inputStreamInfo->hostApiType != paWASAPI))
+	        {
+	            return paIncompatibleHostApiSpecificStreamInfo;
+	        }
+		}
+
+        return paNoError;
+    }
+
+    if (outputParameters != NULL)
+    {
+        /* all standard sample formats are supported by the buffer adapter,
+            this implementation doesn't support any custom sample formats */
+        if (outputParameters->sampleFormat & paCustomFormat)
+            return paSampleFormatNotSupported;
+
+        /* unless alternate device specification is supported, reject the use of
+            paUseHostApiSpecificDeviceSpecification */
+        if (outputParameters->device == paUseHostApiSpecificDeviceSpecification)
+            return paInvalidDevice;
+
+        /* check that output device can support outputChannelCount */
+        if (outputParameters->channelCount > hostApi->deviceInfos[ outputParameters->device ]->maxOutputChannels)
+            return paInvalidChannelCount;
+
+        /* validate outputStreamInfo */
+        if(outputParameters->hostApiSpecificStreamInfo)
+        {
+			PaWasapiStreamInfo *outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
+	        if ((outputStreamInfo->size != sizeof(PaWasapiStreamInfo)) ||
+	            (outputStreamInfo->version != 1) ||
+                (outputStreamInfo->hostApiType != paWASAPI))
+	        {
+	            return paIncompatibleHostApiSpecificStreamInfo;
+	        }
+        }
+
+		return paNoError;
+    }
+
+	return (inputParameters || outputParameters ? paNoError : paInternalError);
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
+                                  const  PaStreamParameters *inputParameters,
+                                  const  PaStreamParameters *outputParameters,
+                                  double sampleRate )
+{
+	IAudioClient *tmpClient = NULL;
+	PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
+	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;
+
+	// Validate PaStreamParameters
+	PaError error;
+	if ((error = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
+		return error;
+
+    if (inputParameters != NULL)
+    {
+		WAVEFORMATEXTENSIBLE wavex;
+		HRESULT hr;
+		PaError answer;
+		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
+		inputStreamInfo = (PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo;
+
+		if (inputStreamInfo && (inputStreamInfo->flags & paWinWasapiExclusive))
+			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;
+
+		hr = ActivateAudioInterface(&paWasapi->devInfo[inputParameters->device], &tmpClient);
+		if (hr != S_OK)
+		{
+			LogHostError(hr);
+			return paInvalidDevice;
+		}
+
+		answer = GetClosestFormat(tmpClient, sampleRate, inputParameters, shareMode, &wavex, FALSE);
+		SAFE_RELEASE(tmpClient);
+
+		if (answer != paFormatIsSupported)
+			return answer;
+    }
+
+    if (outputParameters != NULL)
+    {
+		HRESULT hr;
+		WAVEFORMATEXTENSIBLE wavex;
+		PaError answer;
+		AUDCLNT_SHAREMODE shareMode = AUDCLNT_SHAREMODE_SHARED;
+        outputStreamInfo = (PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo;
+
+		if (outputStreamInfo && (outputStreamInfo->flags & paWinWasapiExclusive))
+			shareMode  = AUDCLNT_SHAREMODE_EXCLUSIVE;
+
+		hr = ActivateAudioInterface(&paWasapi->devInfo[outputParameters->device], &tmpClient);
+		if (hr != S_OK)
+		{
+			LogHostError(hr);
+			return paInvalidDevice;
+		}
+
+		answer = GetClosestFormat(tmpClient, sampleRate, outputParameters, shareMode, &wavex, TRUE);
+		SAFE_RELEASE(tmpClient);
+
+		if (answer != paFormatIsSupported)
+			return answer;
+    }
+
+    return paFormatIsSupported;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaUint32 PaUtil_GetFramesPerHostBuffer(PaUint32 userFramesPerBuffer, PaTime suggestedLatency, double sampleRate, PaUint32 TimerJitterMs)
+{
+	PaUint32 frames = userFramesPerBuffer + max( userFramesPerBuffer, (PaUint32)(suggestedLatency * sampleRate) );
+    frames += (PaUint32)((sampleRate * 0.001) * TimerJitterMs);
+	return frames;
+}
+
+// ------------------------------------------------------------------------------------------
+static void _RecalculateBuffersCount(PaWasapiSubStream *sub, UINT32 userFramesPerBuffer, UINT32 framesPerLatency, BOOL fullDuplex)
+{
+	// Count buffers (must be at least 1)
+	sub->buffers = (userFramesPerBuffer ? framesPerLatency / userFramesPerBuffer : 0);
+	if (sub->buffers == 0)
+		sub->buffers = 1;
+
+	// Determine amount of buffers used:
+	// - Full-duplex mode will lead to period difference, thus only 1.
+	// - Input mode, only 1, as WASAPI allows extraction of only 1 packet.
+	// - For Shared mode we use double buffering.
+	if ((sub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) || fullDuplex)
+	{
+		// Exclusive mode does not allow >1 buffers be used for Event interface, e.g. GetBuffer
+		// call must acquire max buffer size and it all must be processed.
+		if (sub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)
+			sub->userBufferAndHostMatch = 1;
+
+		// Use paUtilBoundedHostBufferSize because exclusive mode will starve and produce
+		// bad quality of audio
+		sub->buffers = 1;
+	}
+}
+
+// ------------------------------------------------------------------------------------------
+static void _CalculateAlignedPeriod(PaWasapiSubStream *pSub, UINT32 *nFramesPerLatency,
+									ALIGN_FUNC pAlignFunc)
+{
+	// Align frames to HD Audio packet size of 128 bytes for Exclusive mode only.
+	// Not aligning on Windows Vista will cause Event timeout, although Windows 7 will
+	// return AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED error to realign buffer. Aligning is necessary
+	// for Exclusive mode only! when audio data is feeded directly to hardware.
+	if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+	{
+		(*nFramesPerLatency) = AlignFramesPerBuffer((*nFramesPerLatency),
+			pSub->wavex.Format.nSamplesPerSec, pSub->wavex.Format.nBlockAlign, pAlignFunc);
+	}
+
+	// Calculate period
+	pSub->period = MakeHnsPeriod((*nFramesPerLatency), pSub->wavex.Format.nSamplesPerSec);
+}
+
+// ------------------------------------------------------------------------------------------
+static HRESULT CreateAudioClient(PaWasapiStream *pStream, PaWasapiSubStream *pSub, BOOL output, PaError *pa_error)
+{
+	PaError error;
+    HRESULT hr;
+
+	const PaWasapiDeviceInfo *pInfo  = pSub->params.device_info;
+	const PaStreamParameters *params = &pSub->params.stream_params;
+	UINT32 framesPerLatency          = pSub->params.frames_per_buffer;
+	double sampleRate                = pSub->params.sample_rate;
+	//BOOL blocking                    = pSub->params.blocking;
+	BOOL fullDuplex                  = pSub->params.full_duplex;
+
+	const UINT32 userFramesPerBuffer = framesPerLatency;
+    IAudioClient *audioClient	     = NULL;
+
+	// Assume default failure due to some reason
+	(*pa_error) = paInvalidDevice;
+
+	// Validate parameters
+    if (!pSub || !pInfo || !params)
+	{
+		(*pa_error) = paBadStreamPtr;
+        return E_POINTER;
+	}
+	if ((UINT32)sampleRate == 0)
+	{
+		(*pa_error) = paInvalidSampleRate;
+        return E_INVALIDARG;
+	}
+
+    // Get the audio client
+    hr = ActivateAudioInterface(pInfo, &audioClient);
+	if (hr != S_OK)
+	{
+		(*pa_error) = paInsufficientMemory;
+		LogHostError(hr);
+		goto done;
+	}
+
+	// Get closest format
+	if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
+	{
+		(*pa_error) = error;
+		LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
+		goto done; // fail, format not supported
+	}
+
+	// Check for Mono <<>> Stereo workaround
+	if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
+	{
+		/*if (blocking)
+		{
+			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
+			goto done; // fail, blocking mode not supported
+		}*/
+
+		// select mixer
+		pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
+		if (pSub->monoMixer == NULL)
+		{
+			(*pa_error) = paInvalidChannelCount;
+			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
+			goto done; // fail, no mixer for format
+		}
+	}
+
+#if 0
+	// Add suggestd latency
+	framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);
+#else
+	// Calculate host buffer size
+	if ((pSub->shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE) &&
+		(!pSub->streamFlags || ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
+	{
+		framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
+			params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
+			(pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);
+	}
+	else
+	{
+		REFERENCE_TIME overall;
+
+		// Work 1:1 with user buffer (only polling allows to use >1)
+		framesPerLatency += MakeFramesFromHns(SecondsTonano100(params->suggestedLatency), pSub->wavex.Format.nSamplesPerSec);
+
+		// Use Polling if overall latency is > 5ms as it allows to use 100% CPU in a callback,
+		// or user specified latency parameter
+		overall = MakeHnsPeriod(framesPerLatency, pSub->wavex.Format.nSamplesPerSec);
+		if ((overall >= (106667*2)/*21.33ms*/) || ((INT32)(params->suggestedLatency*100000.0) != 0/*0.01 msec granularity*/))
+		{
+			framesPerLatency = PaUtil_GetFramesPerHostBuffer(userFramesPerBuffer,
+				params->suggestedLatency, pSub->wavex.Format.nSamplesPerSec, 0/*,
+				(streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? 0 : 1)*/);
+
+			// Use Polling interface
+			pSub->streamFlags &= ~AUDCLNT_STREAMFLAGS_EVENTCALLBACK;
+			PRINT(("WASAPI: CreateAudioClient: forcing POLL mode\n"));
+		}
+	}
+#endif
+
+	// For full-duplex output resize buffer to be the same as for input
+	if (output && fullDuplex)
+		framesPerLatency = pStream->in.framesPerHostCallback;
+
+	// Avoid 0 frames
+	if (framesPerLatency == 0)
+		framesPerLatency = MakeFramesFromHns(pInfo->DefaultDevicePeriod, pSub->wavex.Format.nSamplesPerSec);
+
+	// Exclusive Input stream renders data in 6 packets, we must set then the size of
+	// single packet, total buffer size, e.g. required latency will be PacketSize * 6
+	if (!output && (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE))
+	{
+		// Do it only for Polling mode
+		if ((pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)
+		{
+			framesPerLatency /= WASAPI_PACKETS_PER_INPUT_BUFFER;
+		}
+	}
+
+	// Calculate aligned period
+	_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
+
+	/*! Enforce min/max period for device in Shared mode to avoid bad audio quality.
+        Avoid doing so for Exclusive mode as alignment will suffer.
+	*/
+	if (pSub->shareMode == AUDCLNT_SHAREMODE_SHARED)
+	{
+		if (pSub->period < pInfo->DefaultDevicePeriod)
+		{
+			pSub->period = pInfo->DefaultDevicePeriod;
+			// Recalculate aligned period
+			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
+			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
+		}
+	}
+	else
+	{
+		if (pSub->period < pInfo->MinimumDevicePeriod)
+		{
+			pSub->period = pInfo->MinimumDevicePeriod;
+			// Recalculate aligned period
+			framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
+			_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_FWD);
+		}
+	}
+
+	/*! Windows 7 does not allow to set latency lower than minimal device period and will
+	    return error: AUDCLNT_E_INVALID_DEVICE_PERIOD. Under Vista we enforce the same behavior
+	    manually for unified behavior on all platforms.
+	*/
+	{
+		/*!	AUDCLNT_E_BUFFER_SIZE_ERROR: Applies to Windows 7 and later.
+			Indicates that the buffer duration value requested by an exclusive-mode client is
+			out of range. The requested duration value for pull mode must not be greater than
+			500 milliseconds; for push mode the duration value must not be greater than 2 seconds.
+		*/
+		if (pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE)
+		{
+			static const REFERENCE_TIME MAX_BUFFER_EVENT_DURATION = 500  * 10000;
+			static const REFERENCE_TIME MAX_BUFFER_POLL_DURATION  = 2000 * 10000;
+
+			if (pSub->streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)	// pull mode, max 500ms
+			{
+				if (pSub->period > MAX_BUFFER_EVENT_DURATION)
+				{
+					pSub->period = MAX_BUFFER_EVENT_DURATION;
+					// Recalculate aligned period
+					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
+					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
+				}
+			}
+			else														// push mode, max 2000ms
+			{
+				if (pSub->period > MAX_BUFFER_POLL_DURATION)
+				{
+					pSub->period = MAX_BUFFER_POLL_DURATION;
+					// Recalculate aligned period
+					framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
+					_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
+				}
+			}
+		}
+	}
+
+	// Set Raw mode (applicable only to IAudioClient2)
+#ifdef __IAudioClient2_INTERFACE_DEFINED__
+	if (GetAudioClientVersion() >= 2)
+	{
+		pa_AudioClientProperties audioProps = { 0 };
+		audioProps.cbSize     = sizeof(pa_AudioClientProperties);
+		audioProps.bIsOffload = FALSE;
+		audioProps.eCategory  = (AUDIO_STREAM_CATEGORY)pSub->params.wasapi_params.streamCategory;
+		switch (pSub->params.wasapi_params.streamOption)
+		{
+		case eStreamOptionRaw:
+			if (GetWindowsVersion() >= WINDOWS_8_1_SERVER2012R2)
+				audioProps.Options = pa_AUDCLNT_STREAMOPTIONS_RAW;
+			break;
+		case eStreamOptionMatchFormat:
+			if (GetWindowsVersion() >= WINDOWS_10_SERVER2016)
+				audioProps.Options = pa_AUDCLNT_STREAMOPTIONS_MATCH_FORMAT;
+			break;
+		}
+
+		hr = IAudioClient2_SetClientProperties((IAudioClient2 *)audioClient, (AudioClientProperties *)&audioProps);
+		if (hr != S_OK)
+		{
+			PRINT(("WASAPI: IAudioClient2_SetClientProperties(Category = %d, Options = %d) failed with error = %08X\n", audioProps.eCategory, audioProps.Options, (UINT32)hr));
+		}
+		else
+		{
+			PRINT(("WASAPI: IAudioClient2 set properties: IsOffload = %d, Category = %d, Options = %d\n", audioProps.bIsOffload, audioProps.eCategory, audioProps.Options));
+		}
+	}
+#endif
+
+	// Open the stream and associate it with an audio session
+    hr = IAudioClient_Initialize(audioClient,
+        pSub->shareMode,
+        pSub->streamFlags,
+		pSub->period,
+		(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
+		&pSub->wavex.Format,
+        NULL);
+
+	/*! WASAPI is tricky on large device buffer, sometimes 2000ms can be allocated sometimes
+	    less. There is no known guaranteed level thus we make subsequent tries by decreasing
+		buffer by 100ms per try.
+	*/
+	while ((hr == E_OUTOFMEMORY) && (pSub->period > (100 * 10000)))
+	{
+		PRINT(("WASAPI: CreateAudioClient: decreasing buffer size to %d milliseconds\n", (pSub->period / 10000)));
+
+		// Decrease by 100ms and try again
+		pSub->period -= (100 * 10000);
+
+		// Recalculate aligned period
+		framesPerLatency = MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec);
+		_CalculateAlignedPeriod(pSub, &framesPerLatency, ALIGN_BWD);
+
+        // Release the previous allocations
+        SAFE_RELEASE(audioClient);
+
+        // Create a new audio client
+        hr = ActivateAudioInterface(pInfo, &audioClient);
+    	if (hr != S_OK)
+		{
+			(*pa_error) = paInsufficientMemory;
+			LogHostError(hr);
+			goto done;
+		}
+
+		// Open the stream and associate it with an audio session
+		hr = IAudioClient_Initialize(audioClient,
+			pSub->shareMode,
+			pSub->streamFlags,
+			pSub->period,
+			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
+			&pSub->wavex.Format,
+			NULL);
+	}
+
+	/*! WASAPI buffer size failure. Fallback to using default size.
+	*/
+	if (hr == AUDCLNT_E_BUFFER_SIZE_ERROR)
+	{
+		// Use default
+		pSub->period = pInfo->DefaultDevicePeriod;
+
+		PRINT(("WASAPI: CreateAudioClient: correcting buffer size to device default\n"));
+
+        // Release the previous allocations
+        SAFE_RELEASE(audioClient);
+
+        // Create a new audio client
+        hr = ActivateAudioInterface(pInfo, &audioClient);
+    	if (hr != S_OK)
+		{
+			(*pa_error) = paInsufficientMemory;
+			LogHostError(hr);
+			goto done;
+		}
+
+		// Open the stream and associate it with an audio session
+		hr = IAudioClient_Initialize(audioClient,
+			pSub->shareMode,
+			pSub->streamFlags,
+			pSub->period,
+			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
+			&pSub->wavex.Format,
+			NULL);
+	}
+
+    /*! If the requested buffer size is not aligned. Can be triggered by Windows 7 and up.
+	    Should not be be triggered ever as we do align buffers always with _CalculateAlignedPeriod.
+	*/
+    if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED)
+    {
+		UINT32 frames = 0;
+
+        // Get the next aligned frame
+        hr = IAudioClient_GetBufferSize(audioClient, &frames);
+		if (hr != S_OK)
+		{
+			(*pa_error) = paInvalidDevice;
+			LogHostError(hr);
+			goto done;
+		}
+
+		PRINT(("WASAPI: CreateAudioClient: aligning buffer size to % frames\n", frames));
+
+        // Release the previous allocations
+        SAFE_RELEASE(audioClient);
+
+        // Create a new audio client
+        hr = ActivateAudioInterface(pInfo, &audioClient);
+    	if (hr != S_OK)
+		{
+			(*pa_error) = paInsufficientMemory;
+			LogHostError(hr);
+			goto done;
+		}
+
+		// Get closest format
+		if ((error = GetClosestFormat(audioClient, sampleRate, params, pSub->shareMode, &pSub->wavex, output)) != paFormatIsSupported)
+		{
+			(*pa_error) = error;
+			LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT); // fail, format not supported
+			goto done;
+		}
+
+		// Check for Mono >> Stereo workaround
+		if ((params->channelCount == 1) && (pSub->wavex.Format.nChannels == 2))
+		{
+			/*if (blocking)
+			{
+				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
+				goto done; // fail, blocking mode not supported
+			}*/
+
+			// Select mixer
+			pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
+			if (pSub->monoMixer == NULL)
+			{
+				(*pa_error) = paInvalidChannelCount;
+				LogHostError(hr = AUDCLNT_E_UNSUPPORTED_FORMAT);
+				goto done; // fail, no mixer for format
+			}
+		}
+
+		// Calculate period
+		pSub->period = MakeHnsPeriod(frames, pSub->wavex.Format.nSamplesPerSec);
+
+        // Open the stream and associate it with an audio session
+        hr = IAudioClient_Initialize(audioClient,
+            pSub->shareMode,
+            pSub->streamFlags,
+			pSub->period,
+			(pSub->shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? pSub->period : 0),
+            &pSub->wavex.Format,
+            NULL);
+    	if (hr != S_OK)
+		{
+			(*pa_error) = paInvalidDevice;
+			LogHostError(hr);
+			goto done;
+		}
+    }
+    else
+	if (hr != S_OK)
+    {
+		(*pa_error) = paInvalidDevice;
+		LogHostError(hr);
+		goto done;
+    }
+
+    // Set client
+	pSub->clientParent = audioClient;
+    IAudioClient_AddRef(pSub->clientParent);
+
+	// Recalculate buffers count
+	_RecalculateBuffersCount(pSub,
+		userFramesPerBuffer,
+		MakeFramesFromHns(pSub->period, pSub->wavex.Format.nSamplesPerSec),
+		fullDuplex);
+
+	// No error, client is succesfully created
+	(*pa_error) = paNoError;
+
+done:
+
+    // Clean up
+    SAFE_RELEASE(audioClient);
+    return hr;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError ActivateAudioClientOutput(PaWasapiStream *stream)
+{
+	HRESULT hr;
+	PaError result;
+
+	UINT32 maxBufferSize   = 0;
+	PaTime buffer_latency  = 0;
+	UINT32 framesPerBuffer = stream->out.params.frames_per_buffer;
+
+	// Create Audio client
+	hr = CreateAudioClient(stream, &stream->out, TRUE, &result);
+    if (hr != S_OK)
+	{
+		LogPaError(result);
+		goto error;
+    }
+	LogWAVEFORMATEXTENSIBLE(&stream->out.wavex);
+
+	// Activate volume
+	stream->outVol = NULL;
+    /*hr = info->device->Activate(
+        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
+        (void**)&stream->outVol);
+    if (hr != S_OK)
+        return paInvalidDevice;*/
+
+    // Get max possible buffer size to check if it is not less than that we request
+    hr = IAudioClient_GetBufferSize(stream->out.clientParent, &maxBufferSize);
+    if (hr != S_OK)
+	{
+		LogHostError(hr);
+		LogPaError(result = paInvalidDevice);
+		goto error;
+	}
+
+    // Correct buffer to max size if it maxed out result of GetBufferSize
+	stream->out.bufferSize = maxBufferSize;
+
+	// Get interface latency (actually uneeded as we calculate latency from the size
+	// of maxBufferSize).
+    hr = IAudioClient_GetStreamLatency(stream->out.clientParent, &stream->out.deviceLatency);
+    if (hr != S_OK)
+	{
+		LogHostError(hr);
+		LogPaError(result = paInvalidDevice);
+		goto error;
+	}
+	//stream->out.latencySeconds = nano100ToSeconds(stream->out.deviceLatency);
+
+    // Number of frames that are required at each period
+	stream->out.framesPerHostCallback = maxBufferSize;
+
+	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
+	stream->out.framesPerBuffer =
+		(stream->out.userBufferAndHostMatch ? stream->out.framesPerHostCallback : framesPerBuffer);
+
+	// Calculate buffer latency
+	buffer_latency = (PaTime)maxBufferSize / stream->out.wavex.Format.nSamplesPerSec;
+
+	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
+	stream->out.latencySeconds = buffer_latency;
+
+	PRINT(("WASAPI::OpenStream(output): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->out.framesPerHostCallback, (float)(stream->out.latencySeconds*1000.0f), (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->out.params.wow64_workaround ? "YES" : "NO"), (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));
+
+	return paNoError;
+
+error:
+
+	return result;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError ActivateAudioClientInput(PaWasapiStream *stream)
+{
+	HRESULT hr;
+	PaError result;
+
+	UINT32 maxBufferSize   = 0;
+	PaTime buffer_latency  = 0;
+	UINT32 framesPerBuffer = stream->in.params.frames_per_buffer;
+
+	// Create Audio client
+	hr = CreateAudioClient(stream, &stream->in, FALSE, &result);
+    if (hr != S_OK)
+	{
+		LogPaError(result);
+		goto error;
+    }
+	LogWAVEFORMATEXTENSIBLE(&stream->in.wavex);
+
+	// Create volume mgr
+	stream->inVol = NULL;
+    /*hr = info->device->Activate(
+        __uuidof(IAudioEndpointVolume), CLSCTX_INPROC_SERVER, NULL,
+        (void**)&stream->inVol);
+    if (hr != S_OK)
+        return paInvalidDevice;*/
+
+    // Get max possible buffer size to check if it is not less than that we request
+    hr = IAudioClient_GetBufferSize(stream->in.clientParent, &maxBufferSize);
+    if (hr != S_OK)
+	{
+		LogHostError(hr);
+		LogPaError(result = paInvalidDevice);
+		goto error;
+	}
+
+    // Correct buffer to max size if it maxed out result of GetBufferSize
+	stream->in.bufferSize = maxBufferSize;
+
+	// Get interface latency (actually uneeded as we calculate latency from the size
+	// of maxBufferSize).
+    hr = IAudioClient_GetStreamLatency(stream->in.clientParent, &stream->in.deviceLatency);
+    if (hr != S_OK)
+	{
+		LogHostError(hr);
+		LogPaError(result = paInvalidDevice);
+		goto error;
+	}
+	//stream->in.latencySeconds = nano100ToSeconds(stream->in.deviceLatency);
+
+    // Number of frames that are required at each period
+	stream->in.framesPerHostCallback = maxBufferSize;
+
+	// Calculate frames per single buffer, if buffers > 1 then always framesPerBuffer
+	stream->in.framesPerBuffer =
+		(stream->in.userBufferAndHostMatch ? stream->in.framesPerHostCallback : framesPerBuffer);
+
+	// Calculate buffer latency
+	buffer_latency = (PaTime)maxBufferSize / stream->in.wavex.Format.nSamplesPerSec;
+
+	// Append buffer latency to interface latency in shared mode (see GetStreamLatency notes)
+	stream->in.latencySeconds = buffer_latency;
+
+	PRINT(("WASAPI::OpenStream(input): framesPerUser[ %d ] framesPerHost[ %d ] latency[ %.02fms ] exclusive[ %s ] wow64_fix[ %s ] mode[ %s ]\n", (UINT32)framesPerBuffer, (UINT32)stream->in.framesPerHostCallback, (float)(stream->in.latencySeconds*1000.0f), (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? "YES" : "NO"), (stream->in.params.wow64_workaround ? "YES" : "NO"), (stream->in.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK ? "EVENT" : "POLL")));
+
+	return paNoError;
+
+error:
+
+	return result;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
+                           PaStream** s,
+                           const PaStreamParameters *inputParameters,
+                           const PaStreamParameters *outputParameters,
+                           double sampleRate,
+                           unsigned long framesPerBuffer,
+                           PaStreamFlags streamFlags,
+                           PaStreamCallback *streamCallback,
+                           void *userData )
+{
+    PaError result = paNoError;
+	HRESULT hr;
+    PaWasapiHostApiRepresentation *paWasapi = (PaWasapiHostApiRepresentation*)hostApi;
+    PaWasapiStream *stream = NULL;
+    int inputChannelCount, outputChannelCount;
+    PaSampleFormat inputSampleFormat, outputSampleFormat;
+    PaSampleFormat hostInputSampleFormat, hostOutputSampleFormat;
+	PaWasapiStreamInfo *inputStreamInfo = NULL, *outputStreamInfo = NULL;
+	PaWasapiDeviceInfo *info = NULL;
+	ULONG framesPerHostCallback;
+	PaUtilHostBufferSizeMode bufferMode;
+	const BOOL fullDuplex = ((inputParameters != NULL) && (outputParameters != NULL));
+
+	// validate PaStreamParameters
+	if ((result = IsStreamParamsValid(hostApi, inputParameters, outputParameters, sampleRate)) != paNoError)
+		return LogPaError(result);
+
+    // Validate platform specific flags
+    if ((streamFlags & paPlatformSpecificFlags) != 0)
+	{
+		LogPaError(result = paInvalidFlag); /* unexpected platform specific flag */
+		goto error;
+	}
+
+	// Allocate memory for PaWasapiStream
+    if ((stream = (PaWasapiStream *)PaUtil_AllocateMemory(sizeof(PaWasapiStream))) == NULL)
+	{
+        LogPaError(result = paInsufficientMemory);
+        goto error;
+    }
+
+	// Default thread priority is Audio: for exclusive mode we will use Pro Audio.
+	stream->nThreadPriority = eThreadPriorityAudio;
+
+	// Set default number of frames: paFramesPerBufferUnspecified
+	if (framesPerBuffer == paFramesPerBufferUnspecified)
+	{
+		UINT32 framesPerBufferIn  = 0, framesPerBufferOut = 0;
+		if (inputParameters != NULL)
+		{
+			info = &paWasapi->devInfo[inputParameters->device];
+			framesPerBufferIn = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
+		}
+		if (outputParameters != NULL)
+		{
+			info = &paWasapi->devInfo[outputParameters->device];
+			framesPerBufferOut = MakeFramesFromHns(info->DefaultDevicePeriod, (UINT32)sampleRate);
+		}
+		// choosing maximum default size
+		framesPerBuffer = max(framesPerBufferIn, framesPerBufferOut);
+	}
+	if (framesPerBuffer == 0)
+		framesPerBuffer = ((UINT32)sampleRate / 100) * 2;
+
+	// Try create device: Input
+	if (inputParameters != NULL)
+    {
+        inputChannelCount = inputParameters->channelCount;
+        inputSampleFormat = inputParameters->sampleFormat;
+        info              = &paWasapi->devInfo[inputParameters->device];
+
+		// default Shared Mode
+		stream->in.shareMode = AUDCLNT_SHAREMODE_SHARED;
+
+		// PaWasapiStreamInfo
+		if (inputParameters->hostApiSpecificStreamInfo != NULL)
+		{
+			memcpy(&stream->in.params.wasapi_params, inputParameters->hostApiSpecificStreamInfo, min(sizeof(stream->in.params.wasapi_params), ((PaWasapiStreamInfo *)inputParameters->hostApiSpecificStreamInfo)->size));
+			stream->in.params.wasapi_params.size = sizeof(stream->in.params.wasapi_params);
+
+			stream->in.params.stream_params.hostApiSpecificStreamInfo = &stream->in.params.wasapi_params;
+			inputStreamInfo = &stream->in.params.wasapi_params;
+
+			stream->in.flags = inputStreamInfo->flags;
+
+			// Exclusive Mode
+			if (inputStreamInfo->flags & paWinWasapiExclusive)
+			{
+				// Boost thread priority
+				stream->nThreadPriority = eThreadPriorityProAudio;
+				// Make Exclusive
+				stream->in.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
+			}
+
+			// explicit thread priority level
+			if (inputStreamInfo->flags & paWinWasapiThreadPriority)
+			{
+				if ((inputStreamInfo->threadPriority > eThreadPriorityNone) &&
+					(inputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
+					stream->nThreadPriority = inputStreamInfo->threadPriority;
+			}
+		}
+
+		// Choose processing mode
+		stream->in.streamFlags = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
+		if (paWasapi->useWOW64Workaround)
+			stream->in.streamFlags = 0; // polling interface
+		else
+		if (streamCallback == NULL)
+			stream->in.streamFlags = 0; // polling interface
+		else
+		if ((inputStreamInfo != NULL) && (inputStreamInfo->flags & paWinWasapiPolling))
+			stream->in.streamFlags = 0; // polling interface
+		else
+		if (fullDuplex)
+			stream->in.streamFlags = 0; // polling interface is implemented for full-duplex mode also
+
+		// Fill parameters for Audio Client creation
+		stream->in.params.device_info       = info;
+		stream->in.params.stream_params     = (*inputParameters);
+		stream->in.params.frames_per_buffer = framesPerBuffer;
+		stream->in.params.sample_rate       = sampleRate;
+		stream->in.params.blocking          = (streamCallback == NULL);
+		stream->in.params.full_duplex       = fullDuplex;
+		stream->in.params.wow64_workaround  = paWasapi->useWOW64Workaround;
+
+		// Create and activate audio client
+		hr = ActivateAudioClientInput(stream);
+        if (hr != S_OK)
+		{
+			LogPaError(result = paInvalidDevice);
+			goto error;
+        }
+
+		// Get closest format
+        hostInputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->in.wavex), inputSampleFormat );
+
+        // Set user-side custom host processor
+        if ((inputStreamInfo != NULL) &&
+            (inputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
+        {
+            stream->hostProcessOverrideInput.processor = inputStreamInfo->hostProcessorInput;
+            stream->hostProcessOverrideInput.userData = userData;
+        }
+
+		// Only get IAudioCaptureClient input once here instead of getting it at multiple places based on the use
+		hr = IAudioClient_GetService(stream->in.clientParent, &pa_IID_IAudioCaptureClient, (void **)&stream->captureClientParent);
+		if (hr != S_OK)
+		{
+			LogHostError(hr);
+			LogPaError(result = paUnanticipatedHostError);
+			goto error;
+		}
+
+		// Create ring buffer for blocking mode (It is needed because we fetch Input packets, not frames,
+		// and thus we have to save partial packet if such remains unread)
+		if (stream->in.params.blocking == TRUE)
+		{
+			UINT32 bufferFrames = ALIGN_NEXT_POW2((stream->in.framesPerHostCallback / WASAPI_PACKETS_PER_INPUT_BUFFER) * 2);
+			UINT32 frameSize    = stream->in.wavex.Format.nBlockAlign;
+
+			// buffer
+			if ((stream->in.tailBuffer = PaUtil_AllocateMemory(sizeof(PaUtilRingBuffer))) == NULL)
+			{
+				LogPaError(result = paInsufficientMemory);
+				goto error;
+			}
+			memset(stream->in.tailBuffer, 0, sizeof(PaUtilRingBuffer));
+
+			// buffer memory region
+			stream->in.tailBufferMemory = PaUtil_AllocateMemory(frameSize * bufferFrames);
+			if (stream->in.tailBufferMemory == NULL)
+			{
+				LogPaError(result = paInsufficientMemory);
+				goto error;
+			}
+
+			// initialize
+			if (PaUtil_InitializeRingBuffer(stream->in.tailBuffer, frameSize, bufferFrames,	stream->in.tailBufferMemory) != 0)
+			{
+				LogPaError(result = paInternalError);
+				goto error;
+			}
+		}
+	}
+    else
+    {
+        inputChannelCount = 0;
+        inputSampleFormat = hostInputSampleFormat = paInt16; /* Surpress 'uninitialised var' warnings. */
+    }
+
+	// Try create device: Output
+    if (outputParameters != NULL)
+    {
+        outputChannelCount = outputParameters->channelCount;
+        outputSampleFormat = outputParameters->sampleFormat;
+		info               = &paWasapi->devInfo[outputParameters->device];
+
+		// default Shared Mode
+		stream->out.shareMode = AUDCLNT_SHAREMODE_SHARED;
+
+		// set PaWasapiStreamInfo
+		if (outputParameters->hostApiSpecificStreamInfo != NULL)
+		{
+			memcpy(&stream->out.params.wasapi_params, outputParameters->hostApiSpecificStreamInfo, min(sizeof(stream->out.params.wasapi_params), ((PaWasapiStreamInfo *)outputParameters->hostApiSpecificStreamInfo)->size));
+			stream->out.params.wasapi_params.size = sizeof(stream->out.params.wasapi_params);
+
+			stream->out.params.stream_params.hostApiSpecificStreamInfo = &stream->out.params.wasapi_params;
+			outputStreamInfo = &stream->out.params.wasapi_params;
+
+			stream->out.flags = outputStreamInfo->flags;
+
+			// Exclusive Mode
+			if (outputStreamInfo->flags & paWinWasapiExclusive)
+			{
+				// Boost thread priority
+				stream->nThreadPriority = eThreadPriorityProAudio;
+				// Make Exclusive
+				stream->out.shareMode = AUDCLNT_SHAREMODE_EXCLUSIVE;
+			}
+
+			// explicit thread priority level
+			if (outputStreamInfo->flags & paWinWasapiThreadPriority)
+			{
+				if ((outputStreamInfo->threadPriority > eThreadPriorityNone) &&
+					(outputStreamInfo->threadPriority <= eThreadPriorityWindowManager))
+					stream->nThreadPriority = outputStreamInfo->threadPriority;
+			}
+		}
+
+		// Choose processing mode
+		stream->out.streamFlags = (stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE ? AUDCLNT_STREAMFLAGS_EVENTCALLBACK : 0);
+		if (paWasapi->useWOW64Workaround)
+			stream->out.streamFlags = 0; // polling interface
+		else
+		if (streamCallback == NULL)
+			stream->out.streamFlags = 0; // polling interface
+		else
+		if ((outputStreamInfo != NULL) && (outputStreamInfo->flags & paWinWasapiPolling))
+			stream->out.streamFlags = 0; // polling interface
+		else
+		if (fullDuplex)
+			stream->out.streamFlags = 0; // polling interface is implemented for full-duplex mode also
+
+		// Fill parameters for Audio Client creation
+		stream->out.params.device_info       = info;
+		stream->out.params.stream_params     = (*outputParameters);
+		stream->out.params.frames_per_buffer = framesPerBuffer;
+		stream->out.params.sample_rate       = sampleRate;
+		stream->out.params.blocking          = (streamCallback == NULL);
+		stream->out.params.full_duplex       = fullDuplex;
+		stream->out.params.wow64_workaround  = paWasapi->useWOW64Workaround;
+
+		// Create and activate audio client
+		hr = ActivateAudioClientOutput(stream);
+        if (hr != S_OK)
+		{
+			LogPaError(result = paInvalidDevice);
+			goto error;
+        }
+
+		// Get closest format
+        hostOutputSampleFormat = PaUtil_SelectClosestAvailableFormat( WaveToPaFormat(&stream->out.wavex), outputSampleFormat );
+
+        // Set user-side custom host processor
+        if ((outputStreamInfo != NULL) &&
+            (outputStreamInfo->flags & paWinWasapiRedirectHostProcessor))
+        {
+            stream->hostProcessOverrideOutput.processor = outputStreamInfo->hostProcessorOutput;
+            stream->hostProcessOverrideOutput.userData = userData;
+        }
+
+		// Only get IAudioCaptureClient output once here instead of getting it at multiple places based on the use
+		hr = IAudioClient_GetService(stream->out.clientParent, &pa_IID_IAudioRenderClient, (void **)&stream->renderClientParent);
+		if (hr != S_OK)
+		{
+			LogHostError(hr);
+			LogPaError(result = paUnanticipatedHostError);
+			goto error;
+		}
+	}
+    else
+    {
+        outputChannelCount = 0;
+        outputSampleFormat = hostOutputSampleFormat = paInt16; /* Surpress 'uninitialized var' warnings. */
+    }
+
+	// log full-duplex
+	if (fullDuplex)
+		PRINT(("WASAPI::OpenStream: full-duplex mode\n"));
+
+	// paWinWasapiPolling must be on/or not on both streams
+	if ((inputParameters != NULL) && (outputParameters != NULL))
+	{
+		if ((inputStreamInfo != NULL) && (outputStreamInfo != NULL))
+		{
+			if (((inputStreamInfo->flags & paWinWasapiPolling) &&
+				!(outputStreamInfo->flags & paWinWasapiPolling))
+				||
+				(!(inputStreamInfo->flags & paWinWasapiPolling) &&
+				 (outputStreamInfo->flags & paWinWasapiPolling)))
+			{
+				LogPaError(result = paInvalidFlag);
+				goto error;
+			}
+		}
+	}
+
+	// Initialize stream representation
+    if (streamCallback)
+    {
+		stream->bBlocking = FALSE;
+        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
+                                              &paWasapi->callbackStreamInterface,
+											  streamCallback, userData);
+    }
+    else
+    {
+		stream->bBlocking = TRUE;
+        PaUtil_InitializeStreamRepresentation(&stream->streamRepresentation,
+                                              &paWasapi->blockingStreamInterface,
+											  streamCallback, userData);
+    }
+
+	// Initialize CPU measurer
+    PaUtil_InitializeCpuLoadMeasurer(&stream->cpuLoadMeasurer, sampleRate);
+
+	if (outputParameters && inputParameters)
+	{
+		// serious problem #1 - No, Not a problem, especially concerning Exclusive mode.
+		// Input device in exclusive mode somehow is getting large buffer always, thus we
+		// adjust Output latency to reflect it, thus period will differ but playback will be
+		// normal.
+		/*if (stream->in.period != stream->out.period)
+		{
+			PRINT(("WASAPI: OpenStream: period discrepancy\n"));
+			LogPaError(result = paBadIODeviceCombination);
+			goto error;
+		}*/
+
+		// serious problem #2 - No, Not a problem, as framesPerHostCallback take into account
+		// sample size while it is not a problem for PA full-duplex, we must care of
+		// preriod only!
+		/*if (stream->out.framesPerHostCallback != stream->in.framesPerHostCallback)
+		{
+			PRINT(("WASAPI: OpenStream: framesPerHostCallback discrepancy\n"));
+			goto error;
+		}*/
+	}
+
+	// Calculate frames per host for processor
+	framesPerHostCallback = (outputParameters ? stream->out.framesPerBuffer : stream->in.framesPerBuffer);
+
+	// Choose correct mode of buffer processing:
+	// Exclusive/Shared non paWinWasapiPolling mode: paUtilFixedHostBufferSize - always fixed
+	// Exclusive/Shared paWinWasapiPolling mode: paUtilBoundedHostBufferSize - may vary for Exclusive or Full-duplex
+	bufferMode = paUtilFixedHostBufferSize;
+	if (inputParameters) // !!! WASAPI IAudioCaptureClient::GetBuffer extracts not number of frames but 1 packet, thus we always must adapt
+		bufferMode = paUtilBoundedHostBufferSize;
+	else
+	if (outputParameters)
+	{
+		if ((stream->out.buffers == 1) &&
+			(!stream->out.streamFlags || ((stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) == 0)))
+			bufferMode = paUtilBoundedHostBufferSize;
+	}
+	stream->bufferMode = bufferMode;
+
+    // Initialize buffer processor
+    result =  PaUtil_InitializeBufferProcessor(
+		&stream->bufferProcessor,
+        inputChannelCount,
+		inputSampleFormat,
+		hostInputSampleFormat,
+        outputChannelCount,
+		outputSampleFormat,
+		hostOutputSampleFormat,
+        sampleRate,
+		streamFlags,
+		framesPerBuffer,
+        framesPerHostCallback,
+		bufferMode,
+        streamCallback,
+		userData);
+    if (result != paNoError)
+	{
+		LogPaError(result);
+        goto error;
+	}
+
+	// Set Input latency
+    stream->streamRepresentation.streamInfo.inputLatency =
+            ((double)PaUtil_GetBufferProcessorInputLatencyFrames(&stream->bufferProcessor) / sampleRate)
+			+ ((inputParameters)?stream->in.latencySeconds : 0);
+
+	// Set Output latency
+    stream->streamRepresentation.streamInfo.outputLatency =
+            ((double)PaUtil_GetBufferProcessorOutputLatencyFrames(&stream->bufferProcessor) / sampleRate)
+			+ ((outputParameters)?stream->out.latencySeconds : 0);
+
+	// Set SR
+    stream->streamRepresentation.streamInfo.sampleRate = sampleRate;
+
+    (*s) = (PaStream *)stream;
+    return result;
+
+error:
+
+    if (stream != NULL)
+		CloseStream(stream);
+
+    return result;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError CloseStream( PaStream* s )
+{
+    PaError result = paNoError;
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+
+	// abort active stream
+	if (IsStreamActive(s))
+	{
+		result = AbortStream(s);
+	}
+
+    SAFE_RELEASE(stream->captureClientParent);
+    SAFE_RELEASE(stream->renderClientParent);
+    SAFE_RELEASE(stream->out.clientParent);
+    SAFE_RELEASE(stream->in.clientParent);
+	SAFE_RELEASE(stream->inVol);
+	SAFE_RELEASE(stream->outVol);
+
+	CloseHandle(stream->event[S_INPUT]);
+	CloseHandle(stream->event[S_OUTPUT]);
+
+	_StreamCleanup(stream);
+
+	PaWasapi_FreeMemory(stream->in.monoBuffer);
+	PaWasapi_FreeMemory(stream->out.monoBuffer);
+
+	PaUtil_FreeMemory(stream->in.tailBuffer);
+	PaUtil_FreeMemory(stream->in.tailBufferMemory);
+
+	PaUtil_FreeMemory(stream->out.tailBuffer);
+	PaUtil_FreeMemory(stream->out.tailBufferMemory);
+
+    PaUtil_TerminateBufferProcessor(&stream->bufferProcessor);
+    PaUtil_TerminateStreamRepresentation(&stream->streamRepresentation);
+    PaUtil_FreeMemory(stream);
+
+    return result;
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT UnmarshalSubStreamComPointers(PaWasapiSubStream *substream) 
+{
+#ifndef PA_WINRT
+	HRESULT hResult = S_OK;
+	HRESULT hFirstBadResult = S_OK;
+	substream->clientProc = NULL;
+
+	// IAudioClient
+	hResult = CoGetInterfaceAndReleaseStream(substream->clientStream, GetAudioClientIID(), (LPVOID*)&substream->clientProc);
+	substream->clientStream = NULL;
+	if (hResult != S_OK) 
+	{
+		hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
+	}
+
+	return hFirstBadResult;
+
+#else
+	(void)substream;
+	return S_OK;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT UnmarshalStreamComPointers(PaWasapiStream *stream) 
+{
+#ifndef PA_WINRT
+	HRESULT hResult = S_OK;
+	HRESULT hFirstBadResult = S_OK;
+	stream->captureClient = NULL;
+	stream->renderClient = NULL;
+	stream->in.clientProc = NULL;
+	stream->out.clientProc = NULL;
+
+	if (NULL != stream->in.clientParent) 
+	{
+		// SubStream pointers
+		hResult = UnmarshalSubStreamComPointers(&stream->in);
+		if (hResult != S_OK) 
+		{
+			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
+		}
+
+		// IAudioCaptureClient
+		hResult = CoGetInterfaceAndReleaseStream(stream->captureClientStream, &pa_IID_IAudioCaptureClient, (LPVOID*)&stream->captureClient);
+		stream->captureClientStream = NULL;
+		if (hResult != S_OK) 
+		{
+			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
+		}
+	}
+
+	if (NULL != stream->out.clientParent) 
+	{
+		// SubStream pointers
+		hResult = UnmarshalSubStreamComPointers(&stream->out);
+		if (hResult != S_OK) 
+		{
+			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
+		}
+
+		// IAudioRenderClient
+		hResult = CoGetInterfaceAndReleaseStream(stream->renderClientStream, &pa_IID_IAudioRenderClient, (LPVOID*)&stream->renderClient);
+		stream->renderClientStream = NULL;
+		if (hResult != S_OK) 
+		{
+			hFirstBadResult = (hFirstBadResult == S_OK) ? hResult : hFirstBadResult;
+		}
+	}
+
+	return hFirstBadResult;
+#else
+	if (stream->in.clientParent != NULL)
+	{
+		stream->in.clientProc = stream->in.clientParent;
+		IAudioClient_AddRef(stream->in.clientParent);
+	}
+
+	if (stream->out.clientParent != NULL)
+	{
+		stream->out.clientProc = stream->out.clientParent;
+		IAudioClient_AddRef(stream->out.clientParent);
+	}
+
+	if (stream->renderClientParent != NULL)
+	{
+		stream->renderClient = stream->renderClientParent;
+		IAudioRenderClient_AddRef(stream->renderClientParent);
+	}
+
+	if (stream->captureClientParent != NULL)
+	{
+		stream->captureClient = stream->captureClientParent;
+		IAudioCaptureClient_AddRef(stream->captureClientParent);
+	}
+
+	return S_OK;
+#endif
+}
+
+// -----------------------------------------------------------------------------------------
+void ReleaseUnmarshaledSubComPointers(PaWasapiSubStream *substream) 
+{
+	SAFE_RELEASE(substream->clientProc);
+}
+
+// -----------------------------------------------------------------------------------------
+void ReleaseUnmarshaledComPointers(PaWasapiStream *stream) 
+{
+	// Release AudioClient services first
+	SAFE_RELEASE(stream->captureClient);
+	SAFE_RELEASE(stream->renderClient);
+
+	// Release AudioClients
+	ReleaseUnmarshaledSubComPointers(&stream->in);
+	ReleaseUnmarshaledSubComPointers(&stream->out);
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT MarshalSubStreamComPointers(PaWasapiSubStream *substream) 
+{
+#ifndef PA_WINRT
+	HRESULT hResult;
+	substream->clientStream = NULL;
+
+	// IAudioClient
+	hResult = CoMarshalInterThreadInterfaceInStream(GetAudioClientIID(), (LPUNKNOWN)substream->clientParent, &substream->clientStream);
+	if (hResult != S_OK)
+		goto marshal_sub_error;
+
+	return hResult;
+
+	// If marshaling error occurred, make sure to release everything.
+marshal_sub_error:
+
+	UnmarshalSubStreamComPointers(substream);
+	ReleaseUnmarshaledSubComPointers(substream);
+	return hResult;
+#else
+	(void)substream;
+	return S_OK;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT MarshalStreamComPointers(PaWasapiStream *stream) 
+{
+#ifndef PA_WINRT
+	HRESULT hResult = S_OK;
+	stream->captureClientStream = NULL;
+	stream->in.clientStream = NULL;
+	stream->renderClientStream = NULL;
+	stream->out.clientStream = NULL;
+
+	if (NULL != stream->in.clientParent) 
+	{
+		// SubStream pointers
+		hResult = MarshalSubStreamComPointers(&stream->in);
+		if (hResult != S_OK) 
+			goto marshal_error;
+
+		// IAudioCaptureClient
+		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioCaptureClient, (LPUNKNOWN)stream->captureClientParent, &stream->captureClientStream);
+		if (hResult != S_OK) 
+			goto marshal_error;
+	}
+
+	if (NULL != stream->out.clientParent) 
+	{
+		// SubStream pointers
+		hResult = MarshalSubStreamComPointers(&stream->out);
+		if (hResult != S_OK) 
+			goto marshal_error;
+
+		// IAudioRenderClient
+		hResult = CoMarshalInterThreadInterfaceInStream(&pa_IID_IAudioRenderClient, (LPUNKNOWN)stream->renderClientParent, &stream->renderClientStream);
+		if (hResult != S_OK) 
+			goto marshal_error;
+	}
+
+	return hResult;
+
+	// If marshaling error occurred, make sure to release everything.
+marshal_error:
+
+	UnmarshalStreamComPointers(stream);
+	ReleaseUnmarshaledComPointers(stream);
+	return hResult;
+#else
+	(void)stream;
+	return S_OK;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError StartStream( PaStream *s )
+{
+	HRESULT hr;
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+	PaError result = paNoError;
+
+	// check if stream is active already
+	if (IsStreamActive(s))
+		return paStreamIsNotStopped;
+
+    PaUtil_ResetBufferProcessor(&stream->bufferProcessor);
+
+	// Cleanup handles (may be necessary if stream was stopped by itself due to error)
+	_StreamCleanup(stream);
+
+	// Create close event
+	if ((stream->hCloseRequest = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) 
+	{
+		result = paInsufficientMemory;
+		goto start_error;
+	}
+
+	// Create thread
+	if (!stream->bBlocking)
+	{
+		// Create thread events
+		stream->hThreadStart = CreateEvent(NULL, TRUE, FALSE, NULL);
+		stream->hThreadExit  = CreateEvent(NULL, TRUE, FALSE, NULL);
+		if ((stream->hThreadStart == NULL) || (stream->hThreadExit == NULL))
+		{
+			result = paInsufficientMemory;
+			goto start_error;
+		}
+
+		// Marshal WASAPI interface pointers for safe use in thread created below.
+		if ((hr = MarshalStreamComPointers(stream)) != S_OK) 
+		{
+			PRINT(("Failed marshaling stream COM pointers."));
+			result = paUnanticipatedHostError;
+			goto nonblocking_start_error;
+		}
+
+		if ((stream->in.clientParent  && (stream->in.streamFlags  & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)) ||
+			(stream->out.clientParent && (stream->out.streamFlags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK)))
+		{
+			if ((stream->hThread = CREATE_THREAD(ProcThreadEvent)) == NULL) 
+			{
+				PRINT(("Failed creating thread: ProcThreadEvent."));
+				result = paUnanticipatedHostError;
+				goto nonblocking_start_error;
+			}
+		}
+		else
+		{
+			if ((stream->hThread = CREATE_THREAD(ProcThreadPoll)) == NULL) 
+			{
+				PRINT(("Failed creating thread: ProcThreadPoll."));
+				result = paUnanticipatedHostError;
+				goto nonblocking_start_error;
+			}
+		}
+
+		// Wait for thread to start
+		if (WaitForSingleObject(stream->hThreadStart, 60*1000) == WAIT_TIMEOUT) 
+		{
+			PRINT(("Failed starting thread: timeout."));
+			result = paUnanticipatedHostError;
+			goto nonblocking_start_error;
+		}
+	}
+	else
+	{
+		// Create blocking operation events (non-signaled event means - blocking operation is pending)
+		if (stream->out.clientParent != NULL) 
+		{
+			if ((stream->hBlockingOpStreamWR = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
+			{
+				result = paInsufficientMemory;
+				goto start_error;
+			}
+		}
+		if (stream->in.clientParent != NULL) 
+		{
+			if ((stream->hBlockingOpStreamRD = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) 
+			{
+				result = paInsufficientMemory;
+				goto start_error;
+			}
+		}
+
+		// Initialize event & start INPUT stream
+		if (stream->in.clientParent != NULL)
+		{
+			if ((hr = IAudioClient_Start(stream->in.clientParent)) != S_OK)
+			{
+				LogHostError(hr);
+				result = paUnanticipatedHostError;
+				goto start_error;
+			}
+		}
+
+		// Initialize event & start OUTPUT stream
+		if (stream->out.clientParent != NULL)
+		{
+			// Start
+			if ((hr = IAudioClient_Start(stream->out.clientParent)) != S_OK)
+			{
+				LogHostError(hr);
+				result = paUnanticipatedHostError;
+				goto start_error;
+			}
+		}
+
+		// Set parent to working pointers to use shared functions.
+		stream->captureClient  = stream->captureClientParent;
+		stream->renderClient   = stream->renderClientParent;
+		stream->in.clientProc  = stream->in.clientParent;
+		stream->out.clientProc = stream->out.clientParent;
+
+		// Signal: stream running.
+		stream->running = TRUE;
+	}
+
+    return result;
+
+nonblocking_start_error:
+
+	// Set hThreadExit event to prevent blocking during cleanup
+	SetEvent(stream->hThreadExit);
+	UnmarshalStreamComPointers(stream);
+	ReleaseUnmarshaledComPointers(stream);
+
+start_error:
+
+	StopStream(s);
+	return result;
+}
+
+// ------------------------------------------------------------------------------------------
+void _StreamFinish(PaWasapiStream *stream)
+{
+	// Issue command to thread to stop processing and wait for thread exit
+	if (!stream->bBlocking)
+	{
+		SignalObjectAndWait(stream->hCloseRequest, stream->hThreadExit, INFINITE, FALSE);
+	}
+	else
+	// Blocking mode does not own thread
+	{
+		// Signal close event and wait for each of 2 blocking operations to complete
+		if (stream->out.clientParent)
+			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamWR, INFINITE, TRUE);
+		if (stream->out.clientParent)
+			SignalObjectAndWait(stream->hCloseRequest, stream->hBlockingOpStreamRD, INFINITE, TRUE);
+
+		// Process stop
+		_StreamOnStop(stream);
+	}
+
+	// Cleanup handles
+	_StreamCleanup(stream);
+
+    stream->running = FALSE;
+}
+
+// ------------------------------------------------------------------------------------------
+void _StreamCleanup(PaWasapiStream *stream)
+{
+	// Close thread handles to allow restart
+	SAFE_CLOSE(stream->hThread);
+	SAFE_CLOSE(stream->hThreadStart);
+	SAFE_CLOSE(stream->hThreadExit);
+	SAFE_CLOSE(stream->hCloseRequest);
+	SAFE_CLOSE(stream->hBlockingOpStreamRD);
+	SAFE_CLOSE(stream->hBlockingOpStreamWR);
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError StopStream( PaStream *s )
+{
+	// Finish stream
+	_StreamFinish((PaWasapiStream *)s);
+    return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError AbortStream( PaStream *s )
+{
+	// Finish stream
+	_StreamFinish((PaWasapiStream *)s);
+    return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError IsStreamStopped( PaStream *s )
+{
+	return !((PaWasapiStream *)s)->running;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError IsStreamActive( PaStream *s )
+{
+    return ((PaWasapiStream *)s)->running;
+}
+
+// ------------------------------------------------------------------------------------------
+static PaTime GetStreamTime( PaStream *s )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+
+    /* suppress unused variable warnings */
+    (void) stream;
+
+    return PaUtil_GetTime();
+}
+
+// ------------------------------------------------------------------------------------------
+static double GetStreamCpuLoad( PaStream* s )
+{
+	return PaUtil_GetCpuLoad(&((PaWasapiStream *)s)->cpuLoadMeasurer);
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError ReadStream( PaStream* s, void *_buffer, unsigned long frames )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+
+	HRESULT hr = S_OK;
+	BYTE *user_buffer = (BYTE *)_buffer;
+	BYTE *wasapi_buffer = NULL;
+	DWORD flags = 0;
+	UINT32 i, available, sleep = 0;
+	unsigned long processed;
+	ThreadIdleScheduler sched;
+
+	// validate
+	if (!stream->running)
+		return paStreamIsStopped;
+	if (stream->captureClient == NULL)
+		return paBadStreamPtr;
+
+	// Notify blocking op has begun
+	ResetEvent(stream->hBlockingOpStreamRD);
+
+	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
+	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
+	ThreadIdleScheduler_Setup(&sched, 1, 250/* microseconds */);
+
+    // Make a local copy of the user buffer pointer(s), this is necessary
+	// because PaUtil_CopyOutput() advances these pointers every time it is called
+    if (!stream->bufferProcessor.userInputIsInterleaved)
+    {
+		user_buffer = (BYTE *)alloca(sizeof(BYTE *) * stream->bufferProcessor.inputChannelCount);
+        if (user_buffer == NULL)
+            return paInsufficientMemory;
+
+        for (i = 0; i < stream->bufferProcessor.inputChannelCount; ++i)
+            ((BYTE **)user_buffer)[i] = ((BYTE **)_buffer)[i];
+    }
+
+	// Findout if there are tail frames, flush them all before reading hardware
+	if ((available = PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer)) != 0)
+	{
+		ring_buffer_size_t buf1_size = 0, buf2_size = 0, read, desired;
+		void *buf1 = NULL, *buf2 = NULL;
+
+		// Limit desired to amount of requested frames
+		desired = available;
+		if ((UINT32)desired > frames)
+			desired = frames;
+		
+		// Get pointers to read regions
+		read = PaUtil_GetRingBufferReadRegions(stream->in.tailBuffer, desired, &buf1, &buf1_size, &buf2, &buf2_size);
+
+		if (buf1 != NULL)
+		{
+			// Register available frames to processor
+			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf1_size);
+
+			// Register host buffer pointer to processor
+			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf1, stream->bufferProcessor.inputChannelCount);
+
+			// Copy user data to host buffer (with conversion if applicable)
+			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf1_size);
+			frames -= processed;
+		}
+
+		if (buf2 != NULL)
+		{
+			// Register available frames to processor
+			PaUtil_SetInputFrameCount(&stream->bufferProcessor, buf2_size);
+
+			// Register host buffer pointer to processor
+			PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, buf2, stream->bufferProcessor.inputChannelCount);
+
+			// Copy user data to host buffer (with conversion if applicable)
+			processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, buf2_size);
+			frames -= processed;
+		}
+
+		// Advance
+		PaUtil_AdvanceRingBufferReadIndex(stream->in.tailBuffer, read);
+	}
+
+	// Read hardware
+	while (frames != 0)
+	{
+		// Check if blocking call must be interrupted
+		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
+			break;
+
+		// Get available frames (must be finding out available frames before call to IAudioCaptureClient_GetBuffer
+		// othervise audio glitches will occur inExclusive mode as it seems that WASAPI has some scheduling/
+		// processing problems when such busy polling with IAudioCaptureClient_GetBuffer occurs)
+		if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
+		{
+			LogHostError(hr);
+			return paUnanticipatedHostError;
+		}
+
+		// Wait for more frames to become available
+		if (available == 0)
+		{
+			// Exclusive mode may require latency of 1 millisecond, thus we shall sleep
+			// around 500 microseconds (emulated) to collect packets in time
+			if (stream->in.shareMode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+			{
+				UINT32 sleep_frames = (frames < stream->in.framesPerHostCallback ? frames : stream->in.framesPerHostCallback);
+
+				sleep  = GetFramesSleepTime(sleep_frames, stream->in.wavex.Format.nSamplesPerSec);
+				sleep /= 4; // wait only for 1/4 of the buffer
+
+				// WASAPI input provides packets, thus expiring packet will result in bad audio
+				// limit waiting time to 2 seconds (will always work for smallest buffer in Shared)
+				if (sleep > 2)
+					sleep = 2;
+
+				// Avoid busy waiting, schedule next 1 millesecond wait
+				if (sleep == 0)
+					sleep = ThreadIdleScheduler_NextSleep(&sched);
+			}
+			else
+			{
+				if ((sleep = ThreadIdleScheduler_NextSleep(&sched)) != 0)
+				{
+					Sleep(sleep);
+					sleep = 0;
+				}
+			}
+
+			continue;
+		}
+
+		// Get the available data in the shared buffer.
+		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &wasapi_buffer, &available, &flags, NULL, NULL)) != S_OK)
+		{
+			// Buffer size is too small, waiting
+			if (hr != AUDCLNT_S_BUFFER_EMPTY)
+			{
+				LogHostError(hr);
+				goto end;
+			}
+
+			continue;
+		}
+
+		// Register available frames to processor
+        PaUtil_SetInputFrameCount(&stream->bufferProcessor, available);
+
+		// Register host buffer pointer to processor
+        PaUtil_SetInterleavedInputChannels(&stream->bufferProcessor, 0, wasapi_buffer, stream->bufferProcessor.inputChannelCount);
+
+		// Copy user data to host buffer (with conversion if applicable)
+		processed = PaUtil_CopyInput(&stream->bufferProcessor, (void **)&user_buffer, frames);
+		frames -= processed;
+
+		// Save tail into buffer
+		if ((frames == 0) && (available > processed))
+		{
+			UINT32 bytes_processed = processed * stream->in.wavex.Format.nBlockAlign;
+			UINT32 frames_to_save  = available - processed;
+
+			PaUtil_WriteRingBuffer(stream->in.tailBuffer, wasapi_buffer + bytes_processed, frames_to_save);
+		}
+
+		// Release host buffer
+		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, available)) != S_OK)
+		{
+			LogHostError(hr);
+			goto end;
+		}
+	}
+
+end:
+
+	// Notify blocking op has ended
+	SetEvent(stream->hBlockingOpStreamRD);
+
+	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
+}
+
+// ------------------------------------------------------------------------------------------
+static PaError WriteStream( PaStream* s, const void *_buffer, unsigned long frames )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+
+	//UINT32 frames;
+	const BYTE *user_buffer = (const BYTE *)_buffer;
+	BYTE *wasapi_buffer;
+	HRESULT hr = S_OK;
+	UINT32 i, available, sleep = 0;
+	unsigned long processed;
+	ThreadIdleScheduler sched;
+
+	// validate
+	if (!stream->running)
+		return paStreamIsStopped;
+	if (stream->renderClient == NULL)
+		return paBadStreamPtr;
+
+	// Notify blocking op has begun
+	ResetEvent(stream->hBlockingOpStreamWR);
+
+	// Use thread scheduling for 500 microseconds (emulated) when wait time for frames is less than
+	// 1 milliseconds, emulation helps to normalize CPU consumption and avoids too busy waiting
+	ThreadIdleScheduler_Setup(&sched, 1, 500/* microseconds */);
+
+    // Make a local copy of the user buffer pointer(s), this is necessary
+	// because PaUtil_CopyOutput() advances these pointers every time it is called
+    if (!stream->bufferProcessor.userOutputIsInterleaved)
+    {
+        user_buffer = (const BYTE *)alloca(sizeof(const BYTE *) * stream->bufferProcessor.outputChannelCount);
+        if (user_buffer == NULL)
+            return paInsufficientMemory;
+
+        for (i = 0; i < stream->bufferProcessor.outputChannelCount; ++i)
+            ((const BYTE **)user_buffer)[i] = ((const BYTE **)_buffer)[i];
+    }
+
+	// Blocking (potentially, untill 'frames' are consumed) loop
+	while (frames != 0)
+	{
+		// Check if blocking call must be interrupted
+		if (WaitForSingleObject(stream->hCloseRequest, sleep) != WAIT_TIMEOUT)
+			break;
+
+		// Get frames available
+		if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
+		{
+			LogHostError(hr);
+			goto end;
+		}
+
+		// Wait for more frames to become available
+		if (available == 0)
+		{
+			UINT32 sleep_frames = (frames < stream->out.framesPerHostCallback ? frames : stream->out.framesPerHostCallback);
+
+			sleep  = GetFramesSleepTime(sleep_frames, stream->out.wavex.Format.nSamplesPerSec);
+			sleep /= 2; // wait only for half of the buffer
+
+			// Avoid busy waiting, schedule next 1 millesecond wait
+			if (sleep == 0)
+				sleep = ThreadIdleScheduler_NextSleep(&sched);
+
+			continue;
+		}
+
+		// Keep in 'frmaes' range
+		if (available > frames)
+			available = frames;
+
+		// Get pointer to host buffer
+		if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, available, &wasapi_buffer)) != S_OK)
+		{
+			// Buffer size is too big, waiting
+			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
+				continue;
+
+			LogHostError(hr);
+			goto end;
+		}
+
+		// Keep waiting again (on Vista it was noticed that WASAPI could SOMETIMES return NULL pointer 
+		// to buffer without returning AUDCLNT_E_BUFFER_TOO_LARGE instead)
+		if (wasapi_buffer == NULL)
+			continue;
+
+		// Register available frames to processor
+        PaUtil_SetOutputFrameCount(&stream->bufferProcessor, available);
+
+		// Register host buffer pointer to processor
+        PaUtil_SetInterleavedOutputChannels(&stream->bufferProcessor, 0, wasapi_buffer,	stream->bufferProcessor.outputChannelCount);
+
+		// Copy user data to host buffer (with conversion if applicable), this call will advance
+		// pointer 'user_buffer' to consumed portion of data
+		processed = PaUtil_CopyOutput(&stream->bufferProcessor, (const void **)&user_buffer, frames);
+		frames -= processed;
+
+		// Release host buffer
+		if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, available, 0)) != S_OK)
+		{
+			LogHostError(hr);
+			goto end;
+		}
+	}
+
+end:
+
+	// Notify blocking op has ended
+	SetEvent(stream->hBlockingOpStreamWR);
+
+	return (hr != S_OK ? paUnanticipatedHostError : paNoError);
+}
+
+unsigned long PaUtil_GetOutputFrameCount( PaUtilBufferProcessor* bp )
+{
+	return bp->hostOutputFrameCount[0];
+}
+
+// ------------------------------------------------------------------------------------------
+static signed long GetStreamReadAvailable( PaStream* s )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+
+	HRESULT hr;
+	UINT32  available = 0;
+
+	// validate
+	if (!stream->running)
+		return paStreamIsStopped;
+	if (stream->captureClient == NULL)
+		return paBadStreamPtr;
+
+	// available in hardware buffer
+	if ((hr = _PollGetInputFramesAvailable(stream, &available)) != S_OK)
+	{
+		LogHostError(hr);
+		return paUnanticipatedHostError;
+	}
+
+	// available in software tail buffer
+	available += PaUtil_GetRingBufferReadAvailable(stream->in.tailBuffer);
+
+    return available;
+}
+
+// ------------------------------------------------------------------------------------------
+static signed long GetStreamWriteAvailable( PaStream* s )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)s;
+	HRESULT hr;
+	UINT32  available = 0;
+
+	// validate
+	if (!stream->running)
+		return paStreamIsStopped;
+	if (stream->renderClient == NULL)
+		return paBadStreamPtr;
+
+	if ((hr = _PollGetOutputFramesAvailable(stream, &available)) != S_OK)
+	{
+		LogHostError(hr);
+		return paUnanticipatedHostError;
+	}
+
+	return (signed long)available;
+}
+
+
+// ------------------------------------------------------------------------------------------
+static void WaspiHostProcessingLoop( void *inputBuffer,  long inputFrames,
+                                     void *outputBuffer, long outputFrames,
+                                     void *userData )
+{
+    PaWasapiStream *stream = (PaWasapiStream*)userData;
+    PaStreamCallbackTimeInfo timeInfo = {0,0,0};
+	PaStreamCallbackFlags flags = 0;
+    int callbackResult;
+    unsigned long framesProcessed;
+	HRESULT hr;
+	UINT32 pending;
+
+    PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );
+
+    /*
+		Pa_GetStreamTime:
+            - generate timing information
+            - handle buffer slips
+    */
+	timeInfo.currentTime = PaUtil_GetTime();
+	// Query input latency
+	if (stream->in.clientProc != NULL)
+	{
+		PaTime pending_time;
+		if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, &pending)) == S_OK)
+			pending_time = (PaTime)pending / (PaTime)stream->in.wavex.Format.nSamplesPerSec;
+		else
+			pending_time = (PaTime)stream->in.latencySeconds;
+
+		timeInfo.inputBufferAdcTime = timeInfo.currentTime + pending_time;
+	}
+	// Query output current latency
+	if (stream->out.clientProc != NULL)
+	{
+		PaTime pending_time;
+		if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &pending)) == S_OK)
+			pending_time = (PaTime)pending / (PaTime)stream->out.wavex.Format.nSamplesPerSec;
+		else
+			pending_time = (PaTime)stream->out.latencySeconds;
+
+		timeInfo.outputBufferDacTime = timeInfo.currentTime + pending_time;
+	}
+
+    /*
+        If you need to byte swap or shift inputBuffer to convert it into a
+        portaudio format, do it here.
+    */
+
+    PaUtil_BeginBufferProcessing( &stream->bufferProcessor, &timeInfo, flags );
+
+    /*
+        depending on whether the host buffers are interleaved, non-interleaved
+        or a mixture, you will want to call PaUtil_SetInterleaved*Channels(),
+        PaUtil_SetNonInterleaved*Channel() or PaUtil_Set*Channel() here.
+    */
+
+    if (stream->bufferProcessor.inputChannelCount > 0)
+    {
+        PaUtil_SetInputFrameCount( &stream->bufferProcessor, inputFrames );
+        PaUtil_SetInterleavedInputChannels( &stream->bufferProcessor,
+            0, /* first channel of inputBuffer is channel 0 */
+            inputBuffer,
+            0 ); /* 0 - use inputChannelCount passed to init buffer processor */
+    }
+
+    if (stream->bufferProcessor.outputChannelCount > 0)
+    {
+        PaUtil_SetOutputFrameCount( &stream->bufferProcessor, outputFrames);
+        PaUtil_SetInterleavedOutputChannels( &stream->bufferProcessor,
+            0, /* first channel of outputBuffer is channel 0 */
+            outputBuffer,
+            0 ); /* 0 - use outputChannelCount passed to init buffer processor */
+    }
+
+    /* you must pass a valid value of callback result to PaUtil_EndBufferProcessing()
+        in general you would pass paContinue for normal operation, and
+        paComplete to drain the buffer processor's internal output buffer.
+        You can check whether the buffer processor's output buffer is empty
+        using PaUtil_IsBufferProcessorOuputEmpty( bufferProcessor )
+    */
+    callbackResult = paContinue;
+    framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor, &callbackResult );
+
+    /*
+        If you need to byte swap or shift outputBuffer to convert it to
+        host format, do it here.
+    */
+
+	PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );
+
+    if (callbackResult == paContinue)
+    {
+        /* nothing special to do */
+    }
+    else
+	if (callbackResult == paAbort)
+    {
+		// stop stream
+        SetEvent(stream->hCloseRequest);
+    }
+    else
+    {
+		// stop stream
+        SetEvent(stream->hCloseRequest);
+    }
+}
+
+// ------------------------------------------------------------------------------------------
+HANDLE MMCSS_activate(const char *name)
+{
+#ifndef PA_WINRT
+    DWORD task_idx = 0;
+    HANDLE hTask = pAvSetMmThreadCharacteristics(name, &task_idx);
+    if (hTask == NULL)
+	{
+        PRINT(("WASAPI: AvSetMmThreadCharacteristics failed!\n"));
+    }
+
+    /*BOOL priority_ok = pAvSetMmThreadPriority(hTask, AVRT_PRIORITY_NORMAL);
+    if (priority_ok == FALSE)
+	{
+        PRINT(("WASAPI: AvSetMmThreadPriority failed!\n"));
+    }*/
+
+	// debug
+    {
+        int    cur_priority		  = GetThreadPriority(GetCurrentThread());
+        DWORD  cur_priority_class = GetPriorityClass(GetCurrentProcess());
+		PRINT(("WASAPI: thread[ priority-0x%X class-0x%X ]\n", cur_priority, cur_priority_class));
+    }
+
+	return hTask;
+#else
+	(void)name;
+	return NULL;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+void MMCSS_deactivate(HANDLE hTask)
+{
+	if (!hTask)
+		return;
+
+#ifndef PA_WINRT
+	if (pAvRevertMmThreadCharacteristics(hTask) == FALSE)
+	{
+        PRINT(("WASAPI: AvRevertMmThreadCharacteristics failed!\n"));
+    }
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+PaError PaWasapi_ThreadPriorityBoost(void **hTask, PaWasapiThreadPriority nPriorityClass)
+{
+	static const char *mmcs_name[] =
+	{
+		NULL,
+		"Audio",
+		"Capture",
+		"Distribution",
+		"Games",
+		"Playback",
+		"Pro Audio",
+		"Window Manager"
+	};
+	HANDLE task;
+
+	if (hTask == NULL)
+		return paUnanticipatedHostError;
+
+	if ((UINT32)nPriorityClass >= STATIC_ARRAY_SIZE(mmcs_name))
+		return paUnanticipatedHostError;
+
+	task = MMCSS_activate(mmcs_name[nPriorityClass]);
+	if (task == NULL)
+		return paUnanticipatedHostError;
+
+	(*hTask) = task;
+	return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+PaError PaWasapi_ThreadPriorityRevert(void *hTask)
+{
+	if (hTask == NULL)
+		return paUnanticipatedHostError;
+
+	MMCSS_deactivate((HANDLE)hTask);
+
+	return paNoError;
+}
+
+// ------------------------------------------------------------------------------------------
+// Described at:
+// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx
+
+PaError PaWasapi_GetJackCount(PaDeviceIndex nDevice, int *jcount)
+{
+#ifndef PA_WINRT
+	PaError ret;
+	HRESULT hr = S_OK;
+	PaDeviceIndex index;
+    IDeviceTopology *pDeviceTopology = NULL;
+    IConnector *pConnFrom = NULL;
+    IConnector *pConnTo = NULL;
+    IPart *pPart = NULL;
+    IKsJackDescription *pJackDesc = NULL;
+	UINT jackCount = 0;
+
+	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
+	if (paWasapi == NULL)
+		return paNotInitialized;
+
+	// Get device index.
+	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
+    if (ret != paNoError)
+        return ret;
+
+	// Validate index.
+	if ((UINT32)index >= paWasapi->deviceCount)
+		return paInvalidDevice;
+
+	// Get the endpoint device's IDeviceTopology interface.
+	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
+		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
+	IF_FAILED_JUMP(hr, error);
+
+    // The device topology for an endpoint device always contains just one connector (connector number 0).
+	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
+	IF_FAILED_JUMP(hr, error);
+
+    // Step across the connection to the jack on the adapter.
+	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
+    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
+    {
+        // The adapter device is not currently active.
+        hr = E_NOINTERFACE;
+    }
+	IF_FAILED_JUMP(hr, error);
+
+	// Get the connector's IPart interface.
+	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
+	IF_FAILED_JUMP(hr, error);
+
+	// Activate the connector's IKsJackDescription interface.
+	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
+	IF_FAILED_JUMP(hr, error);
+
+	// Return jack count for this device.
+	hr = IKsJackDescription_GetJackCount(pJackDesc, &jackCount);
+	IF_FAILED_JUMP(hr, error);
+
+	// Set.
+	(*jcount) = jackCount;
+
+	// Ok.
+	ret = paNoError;
+
+error:
+
+	SAFE_RELEASE(pDeviceTopology);
+	SAFE_RELEASE(pConnFrom);
+	SAFE_RELEASE(pConnTo);
+	SAFE_RELEASE(pPart);
+	SAFE_RELEASE(pJackDesc);
+
+	LogHostError(hr);
+	return paNoError;
+#else
+	(void)nDevice;
+	(void)jcount;
+	return paUnanticipatedHostError;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+#ifndef PA_WINRT
+static PaWasapiJackConnectionType ConvertJackConnectionTypeWASAPIToPA(int connType)
+{
+	switch (connType)
+	{
+		case eConnTypeUnknown:			return eJackConnTypeUnknown;
+#ifdef _KS_
+		case eConnType3Point5mm:		return eJackConnType3Point5mm;
+#else
+		case eConnTypeEighth:		    return eJackConnType3Point5mm;
+#endif
+		case eConnTypeQuarter:			return eJackConnTypeQuarter;
+		case eConnTypeAtapiInternal:	return eJackConnTypeAtapiInternal;
+		case eConnTypeRCA:				return eJackConnTypeRCA;
+		case eConnTypeOptical:			return eJackConnTypeOptical;
+		case eConnTypeOtherDigital:		return eJackConnTypeOtherDigital;
+		case eConnTypeOtherAnalog:		return eJackConnTypeOtherAnalog;
+		case eConnTypeMultichannelAnalogDIN: return eJackConnTypeMultichannelAnalogDIN;
+		case eConnTypeXlrProfessional:	return eJackConnTypeXlrProfessional;
+		case eConnTypeRJ11Modem:		return eJackConnTypeRJ11Modem;
+		case eConnTypeCombination:		return eJackConnTypeCombination;
+	}
+	return eJackConnTypeUnknown;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+#ifndef PA_WINRT
+static PaWasapiJackGeoLocation ConvertJackGeoLocationWASAPIToPA(int geoLoc)
+{
+	switch (geoLoc)
+	{
+	case eGeoLocRear:				return eJackGeoLocRear;
+	case eGeoLocFront:				return eJackGeoLocFront;
+	case eGeoLocLeft:				return eJackGeoLocLeft;
+	case eGeoLocRight:				return eJackGeoLocRight;
+	case eGeoLocTop:				return eJackGeoLocTop;
+	case eGeoLocBottom:				return eJackGeoLocBottom;
+#ifdef _KS_
+	case eGeoLocRearPanel:			return eJackGeoLocRearPanel;
+#else
+	case eGeoLocRearOPanel:         return eJackGeoLocRearPanel;
+#endif
+	case eGeoLocRiser:				return eJackGeoLocRiser;
+	case eGeoLocInsideMobileLid:	return eJackGeoLocInsideMobileLid;
+	case eGeoLocDrivebay:			return eJackGeoLocDrivebay;
+	case eGeoLocHDMI:				return eJackGeoLocHDMI;
+	case eGeoLocOutsideMobileLid:	return eJackGeoLocOutsideMobileLid;
+	case eGeoLocATAPI:				return eJackGeoLocATAPI;
+	}
+	return eJackGeoLocUnk;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+#ifndef PA_WINRT
+static PaWasapiJackGenLocation ConvertJackGenLocationWASAPIToPA(int genLoc)
+{
+	switch (genLoc)
+	{
+	case eGenLocPrimaryBox:	return eJackGenLocPrimaryBox;
+	case eGenLocInternal:	return eJackGenLocInternal;
+#ifdef _KS_
+	case eGenLocSeparate:	return eJackGenLocSeparate;
+#else
+	case eGenLocSeperate:	return eJackGenLocSeparate;
+#endif
+	case eGenLocOther:		return eJackGenLocOther;
+	}
+	return eJackGenLocPrimaryBox;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+#ifndef PA_WINRT
+static PaWasapiJackPortConnection ConvertJackPortConnectionWASAPIToPA(int portConn)
+{
+	switch (portConn)
+	{
+	case ePortConnJack:					return eJackPortConnJack;
+	case ePortConnIntegratedDevice:		return eJackPortConnIntegratedDevice;
+	case ePortConnBothIntegratedAndJack:return eJackPortConnBothIntegratedAndJack;
+	case ePortConnUnknown:				return eJackPortConnUnknown;
+	}
+	return eJackPortConnJack;
+}
+#endif
+
+// ------------------------------------------------------------------------------------------
+// Described at:
+// http://msdn.microsoft.com/en-us/library/dd371387(v=VS.85).aspx
+
+PaError PaWasapi_GetJackDescription(PaDeviceIndex nDevice, int jindex, PaWasapiJackDescription *pJackDescription)
+{
+#ifndef PA_WINRT
+	PaError ret;
+	HRESULT hr = S_OK;
+	PaDeviceIndex index;
+    IDeviceTopology *pDeviceTopology = NULL;
+    IConnector *pConnFrom = NULL;
+    IConnector *pConnTo = NULL;
+    IPart *pPart = NULL;
+    IKsJackDescription *pJackDesc = NULL;
+	KSJACK_DESCRIPTION jack = { 0 };
+
+	PaWasapiHostApiRepresentation *paWasapi = _GetHostApi(&ret);
+	if (paWasapi == NULL)
+		return paNotInitialized;
+
+	// Get device index.
+	ret = PaUtil_DeviceIndexToHostApiDeviceIndex(&index, nDevice, &paWasapi->inheritedHostApiRep);
+    if (ret != paNoError)
+        return ret;
+
+	// Validate index.
+	if ((UINT32)index >= paWasapi->deviceCount)
+		return paInvalidDevice;
+
+	// Get the endpoint device's IDeviceTopology interface.
+	hr = IMMDevice_Activate(paWasapi->devInfo[index].device, &pa_IID_IDeviceTopology,
+		CLSCTX_INPROC_SERVER, NULL, (void**)&pDeviceTopology);
+	IF_FAILED_JUMP(hr, error);
+
+    // The device topology for an endpoint device always contains just one connector (connector number 0).
+	hr = IDeviceTopology_GetConnector(pDeviceTopology, 0, &pConnFrom);
+	IF_FAILED_JUMP(hr, error);
+
+    // Step across the connection to the jack on the adapter.
+	hr = IConnector_GetConnectedTo(pConnFrom, &pConnTo);
+    if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
+    {
+        // The adapter device is not currently active.
+        hr = E_NOINTERFACE;
+    }
+	IF_FAILED_JUMP(hr, error);
+
+	// Get the connector's IPart interface.
+	hr = IConnector_QueryInterface(pConnTo, &pa_IID_IPart, (void**)&pPart);
+	IF_FAILED_JUMP(hr, error);
+
+	// Activate the connector's IKsJackDescription interface.
+	hr = IPart_Activate(pPart, CLSCTX_INPROC_SERVER, &pa_IID_IKsJackDescription, (void**)&pJackDesc);
+	IF_FAILED_JUMP(hr, error);
+
+	// Test to return jack description struct for index 0.
+	hr = IKsJackDescription_GetJackDescription(pJackDesc, jindex, &jack);
+	IF_FAILED_JUMP(hr, error);
+
+	// Convert WASAPI values to PA format.
+	pJackDescription->channelMapping = jack.ChannelMapping;
+	pJackDescription->color          = jack.Color;
+	pJackDescription->connectionType = ConvertJackConnectionTypeWASAPIToPA(jack.ConnectionType);
+	pJackDescription->genLocation    = ConvertJackGenLocationWASAPIToPA(jack.GenLocation);
+	pJackDescription->geoLocation    = ConvertJackGeoLocationWASAPIToPA(jack.GeoLocation);
+	pJackDescription->isConnected    = jack.IsConnected;
+	pJackDescription->portConnection = ConvertJackPortConnectionWASAPIToPA(jack.PortConnection);
+
+	// Ok.
+	ret = paNoError;
+
+error:
+
+	SAFE_RELEASE(pDeviceTopology);
+	SAFE_RELEASE(pConnFrom);
+	SAFE_RELEASE(pConnTo);
+	SAFE_RELEASE(pPart);
+	SAFE_RELEASE(pJackDesc);
+
+	LogHostError(hr);
+	return ret;
+
+#else
+	(void)nDevice;
+	(void)jindex;
+	(void)pJackDescription;
+	return paUnanticipatedHostError;
+#endif
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT _PollGetOutputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
+{
+	HRESULT hr;
+	UINT32 frames  = stream->out.framesPerHostCallback,
+		   padding = 0;
+
+	(*available) = 0;
+
+	// get read position
+	if ((hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding)) != S_OK)
+		return LogHostError(hr);
+
+	// get available
+	frames -= padding;
+
+	// set
+	(*available) = frames;
+	return hr;
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT _PollGetInputFramesAvailable(PaWasapiStream *stream, UINT32 *available)
+{
+	HRESULT hr;
+
+	(*available) = 0;
+
+	// GetCurrentPadding() has opposite meaning to Output stream 
+	if ((hr = IAudioClient_GetCurrentPadding(stream->in.clientProc, available)) != S_OK)
+		return LogHostError(hr);
+
+	return hr;
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT ProcessOutputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor, UINT32 frames)
+{
+	HRESULT hr;
+	BYTE *data = NULL;
+
+	// Get buffer
+	if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
+	{
+		if (stream->out.shareMode == AUDCLNT_SHAREMODE_SHARED)
+		{
+			// Using GetCurrentPadding to overcome AUDCLNT_E_BUFFER_TOO_LARGE in
+			// shared mode results in no sound in Event-driven mode (MSDN does not
+			// document this, or is it WASAPI bug?), thus we better
+			// try to acquire buffer next time when GetBuffer allows to do so.
+#if 0
+			// Get Read position
+			UINT32 padding = 0;
+			hr = IAudioClient_GetCurrentPadding(stream->out.clientProc, &padding);
+			if (hr != S_OK)
+				return LogHostError(hr);
+
+			// Get frames to write
+			frames -= padding;
+			if (frames == 0)
+				return S_OK;
+
+			if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, frames, &data)) != S_OK)
+				return LogHostError(hr);
+#else
+			if (hr == AUDCLNT_E_BUFFER_TOO_LARGE)
+				return S_OK; // be silent in shared mode, try again next time
+#endif
+		}
+		else
+			return LogHostError(hr);
+	}
+
+	// Process data
+	if (stream->out.monoMixer != NULL)
+	{
+		// expand buffer
+		UINT32 mono_frames_size = frames * (stream->out.wavex.Format.wBitsPerSample / 8);
+		if (mono_frames_size > stream->out.monoBufferSize)
+			stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
+
+		// process
+		processor[S_OUTPUT].processor(NULL, 0, (BYTE *)stream->out.monoBuffer, frames, processor[S_OUTPUT].userData);
+
+		// mix 1 to 2 channels
+		stream->out.monoMixer(data, stream->out.monoBuffer, frames);
+	}
+	else
+	{
+		processor[S_OUTPUT].processor(NULL, 0, data, frames, processor[S_OUTPUT].userData);
+	}
+
+	// Release buffer
+	if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, frames, 0)) != S_OK)
+		LogHostError(hr);
+
+	return hr;
+}
+
+// ------------------------------------------------------------------------------------------
+HRESULT ProcessInputBuffer(PaWasapiStream *stream, PaWasapiHostProcessor *processor)
+{
+	HRESULT hr = S_OK;
+	UINT32 frames;
+	BYTE *data = NULL;
+	DWORD flags = 0;
+
+	for (;;)
+	{
+		// Check if blocking call must be interrupted
+		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
+			break;
+
+		// Findout if any frames available
+		frames = 0;
+		if ((hr = _PollGetInputFramesAvailable(stream, &frames)) != S_OK)
+			return hr;
+
+		// Empty/consumed buffer
+		if (frames == 0)
+			break;
+
+		// Get the available data in the shared buffer.
+		if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &data, &frames, &flags, NULL, NULL)) != S_OK)
+		{
+			if (hr == AUDCLNT_S_BUFFER_EMPTY)
+			{
+				hr = S_OK;
+				break; // Empty/consumed buffer
+			}
+
+			return LogHostError(hr);
+			break;
+		}
+
+		// Detect silence
+		// if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
+		//	data = NULL;
+
+		// Process data
+		if (stream->in.monoMixer != NULL)
+		{
+			// expand buffer
+			UINT32 mono_frames_size = frames * (stream->in.wavex.Format.wBitsPerSample / 8);
+			if (mono_frames_size > stream->in.monoBufferSize)
+				stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
+
+			// mix 1 to 2 channels
+			stream->in.monoMixer(stream->in.monoBuffer, data, frames);
+
+			// process
+			processor[S_INPUT].processor((BYTE *)stream->in.monoBuffer, frames, NULL, 0, processor[S_INPUT].userData);
+		}
+		else
+		{
+			processor[S_INPUT].processor(data, frames, NULL, 0, processor[S_INPUT].userData);
+		}
+
+		// Release buffer
+		if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, frames)) != S_OK)
+			return LogHostError(hr);
+
+		//break;
+	}
+
+	return hr;
+}
+
+// ------------------------------------------------------------------------------------------
+void _StreamOnStop(PaWasapiStream *stream)
+{
+	// Stop INPUT/OUTPUT clients
+	if (!stream->bBlocking) 
+	{
+		if (stream->in.clientProc != NULL)
+			IAudioClient_Stop(stream->in.clientProc);
+		if (stream->out.clientProc != NULL)
+			IAudioClient_Stop(stream->out.clientProc);
+	} 
+	else 
+	{
+		if (stream->in.clientParent != NULL)
+			IAudioClient_Stop(stream->in.clientParent);
+		if (stream->out.clientParent != NULL)
+			IAudioClient_Stop(stream->out.clientParent);
+	}
+
+	// Restore thread priority
+	if (stream->hAvTask != NULL)
+	{
+		PaWasapi_ThreadPriorityRevert(stream->hAvTask);
+		stream->hAvTask = NULL;
+	}
+
+    // Notify
+    if (stream->streamRepresentation.streamFinishedCallback != NULL)
+        stream->streamRepresentation.streamFinishedCallback(stream->streamRepresentation.userData);
+}
+
+// ------------------------------------------------------------------------------------------
+PA_THREAD_FUNC ProcThreadEvent(void *param)
+{
+    PaWasapiHostProcessor processor[S_COUNT];
+	HRESULT hr;
+	DWORD dwResult;
+    PaWasapiStream *stream = (PaWasapiStream *)param;
+	PaWasapiHostProcessor defaultProcessor;
+	BOOL set_event[S_COUNT] = { FALSE, FALSE };
+	BOOL bWaitAllEvents = FALSE;
+	BOOL bThreadComInitialized = FALSE;
+
+	/*
+	If COM is already initialized CoInitialize will either return
+	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
+	threading mode. In either case we shouldn't consider it an error
+	but we need to be careful to not call CoUninitialize() if 
+	RPC_E_CHANGED_MODE was returned.
+	*/
+	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
+	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
+	{
+		PRINT(("WASAPI: failed ProcThreadEvent CoInitialize"));
+		return (UINT32)paUnanticipatedHostError;
+	}
+	if (hr != RPC_E_CHANGED_MODE)
+		bThreadComInitialized = TRUE;
+
+	// Unmarshal stream pointers for safe COM operation
+	hr = UnmarshalStreamComPointers(stream);
+	if (hr != S_OK) {
+		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
+		goto thread_end;
+	}
+
+	// Waiting on all events in case of Full-Duplex/Exclusive mode.
+	if ((stream->in.clientProc != NULL) && (stream->out.clientProc != NULL))
+	{
+		bWaitAllEvents = (stream->in.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE) &&
+			(stream->out.shareMode == AUDCLNT_SHAREMODE_EXCLUSIVE);
+	}
+
+    // Setup data processors
+    defaultProcessor.processor = WaspiHostProcessingLoop;
+    defaultProcessor.userData  = stream;
+    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
+    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);
+
+	// Boost thread priority
+	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);
+
+	// Create events
+	if (stream->event[S_OUTPUT] == NULL)
+	{
+		stream->event[S_OUTPUT] = CreateEvent(NULL, FALSE, FALSE, NULL);
+		set_event[S_OUTPUT] = TRUE;
+	}
+	if (stream->event[S_INPUT] == NULL)
+	{
+		stream->event[S_INPUT]  = CreateEvent(NULL, FALSE, FALSE, NULL);
+		set_event[S_INPUT] = TRUE;
+	}
+	if ((stream->event[S_OUTPUT] == NULL) || (stream->event[S_INPUT] == NULL))
+	{
+		PRINT(("WASAPI Thread: failed creating Input/Output event handle\n"));
+		goto thread_error;
+	}
+
+	// Initialize event & start INPUT stream
+	if (stream->in.clientProc)
+	{
+		// Create & set handle
+		if (set_event[S_INPUT])
+		{
+			if ((hr = IAudioClient_SetEventHandle(stream->in.clientProc, stream->event[S_INPUT])) != S_OK)
+			{
+				LogHostError(hr);
+				goto thread_error;
+			}
+		}
+
+		// Start
+		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
+		{
+			LogHostError(hr);
+			goto thread_error;
+		}
+	}
+
+	// Initialize event & start OUTPUT stream
+	if (stream->out.clientProc)
+	{
+		// Create & set handle
+		if (set_event[S_OUTPUT])
+		{
+			if ((hr = IAudioClient_SetEventHandle(stream->out.clientProc, stream->event[S_OUTPUT])) != S_OK)
+			{
+				LogHostError(hr);
+				goto thread_error;
+			}
+		}
+
+		// Preload buffer before start
+		if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
+		{
+			LogHostError(hr);
+			goto thread_error;
+		}
+
+		// Start
+		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
+		{
+			LogHostError(hr);
+			goto thread_error;
+		}
+
+	}
+
+	// Signal: stream running
+	stream->running = TRUE;
+
+	// Notify: thread started
+	SetEvent(stream->hThreadStart);
+
+	// Processing Loop
+	for (;;)
+    {
+	    // 10 sec timeout (on timeout stream will auto-stop when processed by WAIT_TIMEOUT case)
+        dwResult = WaitForMultipleObjects(S_COUNT, stream->event, bWaitAllEvents, 10*1000);
+
+		// Check for close event (after wait for buffers to avoid any calls to user
+		// callback when hCloseRequest was set)
+		if (WaitForSingleObject(stream->hCloseRequest, 0) != WAIT_TIMEOUT)
+			break;
+
+		// Process S_INPUT/S_OUTPUT
+		switch (dwResult)
+		{
+		case WAIT_TIMEOUT: {
+			PRINT(("WASAPI Thread: WAIT_TIMEOUT - probably bad audio driver or Vista x64 bug: use paWinWasapiPolling instead\n"));
+			goto thread_end;
+			break; }
+
+		// Input stream
+		case WAIT_OBJECT_0 + S_INPUT: {
+
+            if (stream->captureClient == NULL)
+                break;
+
+			if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
+			{
+				LogHostError(hr);
+				goto thread_error;
+			}
+
+			break; }
+
+		// Output stream
+		case WAIT_OBJECT_0 + S_OUTPUT: {
+
+            if (stream->renderClient == NULL)
+                break;
+
+			if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
+			{
+				LogHostError(hr);
+				goto thread_error;
+			}
+
+			break; }
+		}
+	}
+
+thread_end:
+
+	// Process stop
+	_StreamOnStop(stream);
+
+	// Release unmarshaled COM pointers
+	ReleaseUnmarshaledComPointers(stream);
+
+	// Cleanup COM for this thread
+	if (bThreadComInitialized == TRUE)
+		CoUninitialize();
+
+	// Notify: not running
+	stream->running = FALSE;
+
+	// Notify: thread exited
+	SetEvent(stream->hThreadExit);
+
+	return 0;
+
+thread_error:
+
+	// Prevent deadlocking in Pa_StreamStart
+	SetEvent(stream->hThreadStart);
+
+	// Exit
+	goto thread_end;
+}
+
+// ------------------------------------------------------------------------------------------
+PA_THREAD_FUNC ProcThreadPoll(void *param)
+{
+    PaWasapiHostProcessor processor[S_COUNT];
+	HRESULT hr;
+    PaWasapiStream *stream = (PaWasapiStream *)param;
+	PaWasapiHostProcessor defaultProcessor;
+	INT32 i;
+	ThreadIdleScheduler scheduler;
+
+	// Calculate the actual duration of the allocated buffer.
+	DWORD sleep_ms     = 0;
+	DWORD sleep_ms_in;
+	DWORD sleep_ms_out;
+
+	BOOL bThreadComInitialized = FALSE;
+
+	/*
+	If COM is already initialized CoInitialize will either return
+	FALSE, or RPC_E_CHANGED_MODE if it was initialized in a different
+	threading mode. In either case we shouldn't consider it an error
+	but we need to be careful to not call CoUninitialize() if 
+	RPC_E_CHANGED_MODE was returned.
+	*/
+	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
+	if (FAILED(hr) && (hr != RPC_E_CHANGED_MODE))
+	{
+		PRINT(("WASAPI: failed ProcThreadPoll CoInitialize"));
+		return (UINT32)paUnanticipatedHostError;
+	}
+	if (hr != RPC_E_CHANGED_MODE)
+		bThreadComInitialized = TRUE;
+
+	// Unmarshal stream pointers for safe COM operation
+	hr = UnmarshalStreamComPointers(stream);
+	if (hr != S_OK) 
+	{
+		PRINT(("Error unmarshaling stream COM pointers. HRESULT: %i\n", hr));
+		return 0;
+	}
+
+	// Calculate timeout for next polling attempt.
+	sleep_ms_in  = GetFramesSleepTime(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
+	sleep_ms_out = GetFramesSleepTime(stream->out.framesPerBuffer, stream->out.wavex.Format.nSamplesPerSec);
+
+	// WASAPI Input packets tend to expire very easily, let's limit sleep time to 2 milliseconds
+	// for all cases. Please propose better solution if any.
+	if (sleep_ms_in > 2)
+		sleep_ms_in = 2;
+
+	// Adjust polling time for non-paUtilFixedHostBufferSize. Input stream is not adjustable as it is being
+	// polled according its packet length.
+	if (stream->bufferMode != paUtilFixedHostBufferSize)
+	{
+		//sleep_ms_in = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->in.wavex.Format.nSamplesPerSec);
+		sleep_ms_out = GetFramesSleepTime(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);
+	}
+
+	// Choose smallest
+	if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
+		sleep_ms = min(sleep_ms_in, sleep_ms_out);
+	else
+	{
+		sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
+	}
+	// Make sure not 0, othervise use ThreadIdleScheduler
+	if (sleep_ms == 0)
+	{
+		sleep_ms_in  = GetFramesSleepTimeMicroseconds(stream->in.framesPerHostCallback/WASAPI_PACKETS_PER_INPUT_BUFFER, stream->in.wavex.Format.nSamplesPerSec);
+		sleep_ms_out = GetFramesSleepTimeMicroseconds(stream->bufferProcessor.framesPerUserBuffer, stream->out.wavex.Format.nSamplesPerSec);
+
+		// Choose smallest
+		if ((sleep_ms_in != 0) && (sleep_ms_out != 0))
+			sleep_ms = min(sleep_ms_in, sleep_ms_out);
+		else
+		{
+			sleep_ms = (sleep_ms_in ? sleep_ms_in : sleep_ms_out);
+		}
+
+		// Setup thread sleep scheduler
+		ThreadIdleScheduler_Setup(&scheduler, 1, sleep_ms/* microseconds here */);
+		sleep_ms = 0;
+	}
+
+    // Setup data processors
+    defaultProcessor.processor = WaspiHostProcessingLoop;
+    defaultProcessor.userData  = stream;
+    processor[S_INPUT] = (stream->hostProcessOverrideInput.processor != NULL ? stream->hostProcessOverrideInput : defaultProcessor);
+    processor[S_OUTPUT] = (stream->hostProcessOverrideOutput.processor != NULL ? stream->hostProcessOverrideOutput : defaultProcessor);
+
+	// Boost thread priority
+	PaWasapi_ThreadPriorityBoost((void **)&stream->hAvTask, stream->nThreadPriority);
+
+	// Initialize event & start INPUT stream
+	if (stream->in.clientProc)
+	{
+		if ((hr = IAudioClient_Start(stream->in.clientProc)) != S_OK)
+		{
+			LogHostError(hr);
+			goto thread_error;
+		}
+	}
+
+	// Initialize event & start OUTPUT stream
+	if (stream->out.clientProc)
+	{
+		// Preload buffer (obligatory, othervise ->Start() will fail), avoid processing
+		// when in full-duplex mode as it requires input processing as well
+		if (!PA_WASAPI__IS_FULLDUPLEX(stream))
+		{
+			UINT32 frames = 0;
+			if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) == S_OK)
+            {
+				if (stream->bufferMode == paUtilFixedHostBufferSize)
+				{
+					if (frames >= stream->out.framesPerBuffer)
+					{
+						frames = stream->out.framesPerBuffer;
+
+						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
+						{
+							LogHostError(hr); // not fatal, just log
+						}
+					}
+				}
+				else
+				{
+					if (frames != 0)
+					{
+						if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
+						{
+							LogHostError(hr); // not fatal, just log
+						}
+					}
+				}
+            }
+            else
+			{
+				LogHostError(hr); // not fatal, just log
+			}
+		}
+
+		// Start
+		if ((hr = IAudioClient_Start(stream->out.clientProc)) != S_OK)
+		{
+			LogHostError(hr);
+			goto thread_error;
+		}
+	}
+
+	// Signal: stream running
+	stream->running = TRUE;
+
+	// Notify: thread started
+	SetEvent(stream->hThreadStart);
+
+	if (!PA_WASAPI__IS_FULLDUPLEX(stream))
+	{
+		// Processing Loop
+		UINT32 next_sleep = sleep_ms;
+		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
+		{
+			// Get next sleep time
+			if (sleep_ms == 0)
+			{
+				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
+			}
+
+			for (i = 0; i < S_COUNT; ++i)
+			{
+				// Process S_INPUT/S_OUTPUT
+				switch (i)
+				{
+				// Input stream
+				case S_INPUT: {
+
+					if (stream->captureClient == NULL)
+						break;
+
+					if ((hr = ProcessInputBuffer(stream, processor)) != S_OK)
+					{
+						LogHostError(hr);
+						goto thread_error;
+					}
+
+					break; }
+
+				// Output stream
+				case S_OUTPUT: {
+
+					UINT32 frames;
+					if (stream->renderClient == NULL)
+						break;
+
+					// get available frames
+					if ((hr = _PollGetOutputFramesAvailable(stream, &frames)) != S_OK)
+					{
+						LogHostError(hr);
+						goto thread_error;
+					}
+
+					// output
+					if (stream->bufferMode == paUtilFixedHostBufferSize)
+					{
+						while (frames >= stream->out.framesPerBuffer)
+						{
+							if ((hr = ProcessOutputBuffer(stream, processor, stream->out.framesPerBuffer)) != S_OK)
+							{
+								LogHostError(hr);
+								goto thread_error;
+							}
+
+							frames -= stream->out.framesPerBuffer;
+						}
+					}
+					else
+					{
+						if (frames != 0)
+						{
+							if ((hr = ProcessOutputBuffer(stream, processor, frames)) != S_OK)
+							{
+								LogHostError(hr);
+								goto thread_error;
+							}
+						}
+					}
+
+					break; }
+				}
+			}
+		}
+	}
+	else
+	{
+#if 0
+		// Processing Loop
+		while (WaitForSingleObject(stream->hCloseRequest, 1) == WAIT_TIMEOUT)
+		{
+			UINT32 i_frames = 0, i_processed = 0;
+			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
+			DWORD i_flags = 0;
+			UINT32 o_frames = 0;
+
+			// get host input buffer
+			if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
+			{
+				if (hr == AUDCLNT_S_BUFFER_EMPTY)
+					continue; // no data in capture buffer
+
+				LogHostError(hr);
+				break;
+			}
+
+			// get available frames
+			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
+			{
+				// release input buffer
+				IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
+
+				LogHostError(hr);
+				break;
+			}
+
+			// process equal ammount of frames
+			if (o_frames >= i_frames)
+			{
+				// process input ammount of frames
+				UINT32 o_processed = i_frames;
+
+				// get host output buffer
+				if ((hr = IAudioRenderClient_GetBuffer(stream->procRCClient, o_processed, &o_data)) == S_OK)
+				{
+					// processed amount of i_frames
+					i_processed = i_frames;
+					o_data_host = o_data;
+
+					// convert output mono
+					if (stream->out.monoMixer)
+					{
+						UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
+						// expand buffer
+						if (mono_frames_size > stream->out.monoBufferSize)
+						{
+							stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
+							if (stream->out.monoBuffer == NULL)
+							{
+								// release input buffer
+								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
+								// release output buffer
+								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
+
+								LogPaError(paInsufficientMemory);
+								break;
+							}
+						}
+
+						// replace buffer pointer
+						o_data = (BYTE *)stream->out.monoBuffer;
+					}
+
+					// convert input mono
+					if (stream->in.monoMixer)
+					{
+						UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
+						// expand buffer
+						if (mono_frames_size > stream->in.monoBufferSize)
+						{
+							stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
+							if (stream->in.monoBuffer == NULL)
+							{
+								// release input buffer
+								IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
+								// release output buffer
+								IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
+
+								LogPaError(paInsufficientMemory);
+								break;
+							}
+						}
+
+						// mix 2 to 1 input channels
+						stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);
+
+						// replace buffer pointer
+						i_data = (BYTE *)stream->in.monoBuffer;
+					}
+
+					// process
+					processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);
+
+					// mix 1 to 2 output channels
+					if (stream->out.monoBuffer)
+						stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);
+
+					// release host output buffer
+					if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
+						LogHostError(hr);
+				}
+				else
+				{
+					if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
+						LogHostError(hr); // be silent in shared mode, try again next time
+				}
+			}
+
+			// release host input buffer
+			if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
+			{
+				LogHostError(hr);
+				break;
+			}
+		}
+#else
+		// Processing Loop
+		UINT32 next_sleep = sleep_ms;
+		while (WaitForSingleObject(stream->hCloseRequest, next_sleep) == WAIT_TIMEOUT)
+		{
+			UINT32 i_frames = 0, i_processed = 0;
+			BYTE *i_data = NULL, *o_data = NULL, *o_data_host = NULL;
+			DWORD i_flags = 0;
+			UINT32 o_frames = 0;
+
+			// Get next sleep time
+			if (sleep_ms == 0)
+			{
+				next_sleep = ThreadIdleScheduler_NextSleep(&scheduler);
+			}
+
+			// get available frames
+			if ((hr = _PollGetOutputFramesAvailable(stream, &o_frames)) != S_OK)
+			{
+				LogHostError(hr);
+				break;
+			}
+
+			while (o_frames != 0)
+			{
+				// get host input buffer
+				if ((hr = IAudioCaptureClient_GetBuffer(stream->captureClient, &i_data, &i_frames, &i_flags, NULL, NULL)) != S_OK)
+				{
+					if (hr == AUDCLNT_S_BUFFER_EMPTY)
+						break; // no data in capture buffer
+
+					LogHostError(hr);
+					break;
+				}
+
+				// process equal ammount of frames
+				if (o_frames >= i_frames)
+				{
+					// process input ammount of frames
+					UINT32 o_processed = i_frames;
+
+					// get host output buffer
+					if ((hr = IAudioRenderClient_GetBuffer(stream->renderClient, o_processed, &o_data)) == S_OK)
+					{
+						// processed amount of i_frames
+						i_processed = i_frames;
+						o_data_host = o_data;
+
+						// convert output mono
+						if (stream->out.monoMixer)
+						{
+							UINT32 mono_frames_size = o_processed * (stream->out.wavex.Format.wBitsPerSample / 8);
+							// expand buffer
+							if (mono_frames_size > stream->out.monoBufferSize)
+							{
+								stream->out.monoBuffer = PaWasapi_ReallocateMemory(stream->out.monoBuffer, (stream->out.monoBufferSize = mono_frames_size));
+								if (stream->out.monoBuffer == NULL)
+								{
+									// release input buffer
+									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
+									// release output buffer
+									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
+
+									LogPaError(paInsufficientMemory);
+									goto thread_error;
+								}
+							}
+
+							// replace buffer pointer
+							o_data = (BYTE *)stream->out.monoBuffer;
+						}
+
+						// convert input mono
+						if (stream->in.monoMixer)
+						{
+							UINT32 mono_frames_size = i_processed * (stream->in.wavex.Format.wBitsPerSample / 8);
+							// expand buffer
+							if (mono_frames_size > stream->in.monoBufferSize)
+							{
+								stream->in.monoBuffer = PaWasapi_ReallocateMemory(stream->in.monoBuffer, (stream->in.monoBufferSize = mono_frames_size));
+								if (stream->in.monoBuffer == NULL)
+								{
+									// release input buffer
+									IAudioCaptureClient_ReleaseBuffer(stream->captureClient, 0);
+									// release output buffer
+									IAudioRenderClient_ReleaseBuffer(stream->renderClient, 0, 0);
+
+									LogPaError(paInsufficientMemory);
+									goto thread_error;
+								}
+							}
+
+							// mix 2 to 1 input channels
+							stream->in.monoMixer(stream->in.monoBuffer, i_data, i_processed);
+
+							// replace buffer pointer
+							i_data = (BYTE *)stream->in.monoBuffer;
+						}
+
+						// process
+						processor[S_FULLDUPLEX].processor(i_data, i_processed, o_data, o_processed, processor[S_FULLDUPLEX].userData);
+
+						// mix 1 to 2 output channels
+						if (stream->out.monoBuffer)
+							stream->out.monoMixer(o_data_host, stream->out.monoBuffer, o_processed);
+
+						// release host output buffer
+						if ((hr = IAudioRenderClient_ReleaseBuffer(stream->renderClient, o_processed, 0)) != S_OK)
+							LogHostError(hr);
+
+						o_frames -= o_processed;
+					}
+					else
+					{
+						if (stream->out.shareMode != AUDCLNT_SHAREMODE_SHARED)
+							LogHostError(hr); // be silent in shared mode, try again next time
+					}
+				}
+				else
+				{
+					i_processed = 0;
+					goto fd_release_buffer_in;
+				}
+
+fd_release_buffer_in:
+
+				// release host input buffer
+				if ((hr = IAudioCaptureClient_ReleaseBuffer(stream->captureClient, i_processed)) != S_OK)
+				{
+					LogHostError(hr);
+					break;
+				}
+
+				// break processing, input hasn't been accumulated yet
+				if (i_processed == 0)
+					break;
+			}
+		}
+#endif
+	}
+
+thread_end:
+
+	// Process stop
+	_StreamOnStop(stream);
+
+	// Release unmarshaled COM pointers
+	ReleaseUnmarshaledComPointers(stream);
+
+	// Cleanup COM for this thread
+	if (bThreadComInitialized == TRUE)
+		CoUninitialize();
+
+	// Notify: not running
+	stream->running = FALSE;
+
+	// Notify: thread exited
+	SetEvent(stream->hThreadExit);
+
+	return 0;
+
+thread_error:
+
+	// Prevent deadlocking in Pa_StreamStart
+	SetEvent(stream->hThreadStart);
+
+	// Exit
+	goto thread_end;
+}
+
+// ------------------------------------------------------------------------------------------
+void *PaWasapi_ReallocateMemory(void *ptr, size_t size)
+{
+	return realloc(ptr, size);
+}
+
+// ------------------------------------------------------------------------------------------
+void PaWasapi_FreeMemory(void *ptr)
+{
+	free(ptr);
+}
+
+//#endif //VC 2005
+
+
+
+
+#if 0
+			if(bFirst) {
+				float masteur;
+				hr = stream->outVol->GetMasterVolumeLevelScalar(&masteur);
+				if (hr != S_OK)
+					LogHostError(hr);
+				float chan1, chan2;
+				hr = stream->outVol->GetChannelVolumeLevelScalar(0, &chan1);
+				if (hr != S_OK)
+					LogHostError(hr);
+				hr = stream->outVol->GetChannelVolumeLevelScalar(1, &chan2);
+				if (hr != S_OK)
+					LogHostError(hr);
+
+				BOOL bMute;
+				hr = stream->outVol->GetMute(&bMute);
+				if (hr != S_OK)
+					LogHostError(hr);
+
+				stream->outVol->SetMasterVolumeLevelScalar(0.5, NULL);
+				stream->outVol->SetChannelVolumeLevelScalar(0, 0.5, NULL);
+				stream->outVol->SetChannelVolumeLevelScalar(1, 0.5, NULL);
+				stream->outVol->SetMute(FALSE, NULL);
+				bFirst = FALSE;
+			}
+#endif
--- a/src/hostapi/wasapi/readme.txt
+++ b/src/hostapi/wasapi/readme.txt
@@ -1,25 +1,22 @@
-**************
-* WASAPI API *
-**************
-
-----------------------------------------
-Microsoft Visual Studio 2005SP1/2008/10
-----------------------------------------
-No specific actions are needed to compile WASAPI API under Visual Studio.
-You are only required to install min. Windows Vista SDK (v6.0A) prior
-compilation.
-
-----------------------------------------
-MinGW (GCC 32-bit)/ MinGW64 (GCC 64-bit)
-----------------------------------------
-To compile under MinGW you are required to include 'mingw-include' directory
-which contains necessary files with WASAPI API. These files are modified
-in order to be compiled by MinGW compiler. These files are taken from 
-Windows Vista SDK (v6.0A). MinGW compilation is tested and proved to be
-fully working under 32-bit and 64-bit modes.
-MinGW   (32-bit) tested: gcc version 4.4.0 (GCC)
-MinGW64 (64-bit) tested: gcc version 4.4.4 20100226 (prerelease) (GCC)
-
-PortAudio
-/Dmitry Kostjuchenko/
-04.03.2010
\ No newline at end of file
+**************
+* WASAPI API *
+**************
+
+-------------------------------------------
+Microsoft Visual Studio 2005 SP1 and higher
+-------------------------------------------
+No specific action is required to compile WASAPI API under Visual Studio.
+You are only required to install min. Windows Vista SDK (v6.0A) prior
+the compilation. To compile with WASAPI specific functionality for Windows 8
+and higher the min. Windows 8 SDK is required.
+
+----------------------------------------
+MinGW (GCC 32/64-bit)
+----------------------------------------
+To compile with MinGW you are required to include 'mingw-include' directory
+which contains necessary files with WASAPI API. These files are modified
+for the compatibility with MinGW compiler. These files are taken from 
+the Windows Vista SDK (v6.0A). MinGW compilation is tested and proved to be
+fully working.
+MinGW   (32-bit) tested min. version: gcc version 4.4.0 (GCC)
+MinGW64 (64-bit) tested min. version: gcc version 4.4.4 20100226 (prerelease) (GCC)
\ No newline at end of file
--- a/src/os/win/pa_win_coinitialize.c
+++ b/src/os/win/pa_win_coinitialize.c
@@ -1,144 +1,148 @@
-/*
- * Microsoft COM initialization routines
- * Copyright (c) 1999-2011 Ross Bencina, Dmitry Kostjuchenko
- *
- * Based on the Open Source API proposed by Ross Bencina
- * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however,
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also
- * requested that these non-binding requests be included along with the
- * license above.
- */
-
-/** @file
- @ingroup win_src
-
- @brief Microsoft COM initialization routines.
-*/
-
-#include <windows.h>
-#include <objbase.h>
-
-#include "portaudio.h"
-#include "pa_util.h"
-#include "pa_debugprint.h"
-
-#include "pa_win_coinitialize.h"
-
-
-#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) /* MSC version 6 and above */
-#pragma comment( lib, "ole32.lib" )
-#endif
-
-
-/* use some special bit patterns here to try to guard against uninitialized memory errors */
-#define PAWINUTIL_COM_INITIALIZED       (0xb38f)
-#define PAWINUTIL_COM_NOT_INITIALIZED   (0xf1cd)
-
-
-PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
-{
-    HRESULT hr;
-
-    comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;
-
-    /*
-        If COM is already initialized CoInitialize will either return
-        FALSE, or RPC_E_CHANGED_MODE if it was initialised in a different
-        threading mode. In either case we shouldn't consider it an error
-        but we need to be careful to not call CoUninitialize() if 
-        RPC_E_CHANGED_MODE was returned.
-    */
-
-    hr = CoInitialize(0); /* use legacy-safe equivalent to CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) */
-    if( FAILED(hr) && hr != RPC_E_CHANGED_MODE )
-    {
-        PA_DEBUG(("CoInitialize(0) failed. hr=%d\n", hr));
-
-        if( hr == E_OUTOFMEMORY )
-            return paInsufficientMemory;
-
-        {
-            char *lpMsgBuf;
-            FormatMessage(
-                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
-                NULL,
-                hr,
-                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-                (LPTSTR) &lpMsgBuf,
-                0,
-                NULL
-            );
-            PaUtil_SetLastHostErrorInfo( hostApiType, hr, lpMsgBuf );
-            LocalFree( lpMsgBuf );
-        }
-
-        return paUnanticipatedHostError;
-    }
-
-    if( hr != RPC_E_CHANGED_MODE )
-    {
-        comInitializationResult->state = PAWINUTIL_COM_INITIALIZED;
-
-        /*
-            Memorize calling thread id and report warning on Uninitialize if 
-            calling thread is different as CoInitialize must match CoUninitialize 
-            in the same thread.
-        */
-        comInitializationResult->initializingThreadId = GetCurrentThreadId();
-    }
-
-    return paNoError;
-}
-
-
-void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
-{
-    if( comInitializationResult->state != PAWINUTIL_COM_NOT_INITIALIZED
-            && comInitializationResult->state != PAWINUTIL_COM_INITIALIZED ){
-    
-        PA_DEBUG(("ERROR: PaWinUtil_CoUninitialize called without calling PaWinUtil_CoInitialize\n"));
-    }
-
-    if( comInitializationResult->state == PAWINUTIL_COM_INITIALIZED )
-    {
-        DWORD currentThreadId = GetCurrentThreadId();
-		if( comInitializationResult->initializingThreadId != currentThreadId )
-		{
-			PA_DEBUG(("ERROR: failed PaWinUtil_CoUninitialize calling thread[%d] does not match initializing thread[%d]\n",
-				currentThreadId, comInitializationResult->initializingThreadId));
-		}
-		else
-		{
-			CoUninitialize();
-
-            comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;
-		}
-    }
+/*
+ * Microsoft COM initialization routines
+ * Copyright (c) 1999-2011 Ross Bencina, Dmitry Kostjuchenko
+ *
+ * Based on the Open Source API proposed by Ross Bencina
+ * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however,
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also
+ * requested that these non-binding requests be included along with the
+ * license above.
+ */
+
+/** @file
+ @ingroup win_src
+
+ @brief Microsoft COM initialization routines.
+*/
+
+#include <windows.h>
+#include <objbase.h>
+
+#include "portaudio.h"
+#include "pa_util.h"
+#include "pa_debugprint.h"
+
+#include "pa_win_coinitialize.h"
+
+
+#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) && !(defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)) /* MSC version 6 and above */
+#pragma comment( lib, "ole32.lib" )
+#endif
+
+
+/* use some special bit patterns here to try to guard against uninitialized memory errors */
+#define PAWINUTIL_COM_INITIALIZED       (0xb38f)
+#define PAWINUTIL_COM_NOT_INITIALIZED   (0xf1cd)
+
+
+PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
+{
+    HRESULT hr;
+
+    comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;
+
+    /*
+        If COM is already initialized CoInitialize will either return
+        FALSE, or RPC_E_CHANGED_MODE if it was initialised in a different
+        threading mode. In either case we shouldn't consider it an error
+        but we need to be careful to not call CoUninitialize() if 
+        RPC_E_CHANGED_MODE was returned.
+    */
+
+#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY != WINAPI_FAMILY_APP)
+    hr = CoInitialize(0); /* use legacy-safe equivalent to CoInitializeEx(NULL, COINIT_APARTMENTTHREADED) */
+#else
+	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
+#endif
+    if( FAILED(hr) && hr != RPC_E_CHANGED_MODE )
+    {
+        PA_DEBUG(("CoInitialize(0) failed. hr=%d\n", hr));
+
+        if( hr == E_OUTOFMEMORY )
+            return paInsufficientMemory;
+
+        {
+            char *lpMsgBuf;
+            FormatMessage(
+                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+                NULL,
+                hr,
+                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+                (LPTSTR) &lpMsgBuf,
+                0,
+                NULL
+            );
+            PaUtil_SetLastHostErrorInfo( hostApiType, hr, lpMsgBuf );
+            LocalFree( lpMsgBuf );
+        }
+
+        return paUnanticipatedHostError;
+    }
+
+    if( hr != RPC_E_CHANGED_MODE )
+    {
+        comInitializationResult->state = PAWINUTIL_COM_INITIALIZED;
+
+        /*
+            Memorize calling thread id and report warning on Uninitialize if 
+            calling thread is different as CoInitialize must match CoUninitialize 
+            in the same thread.
+        */
+        comInitializationResult->initializingThreadId = GetCurrentThreadId();
+    }
+
+    return paNoError;
+}
+
+
+void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult )
+{
+    if( comInitializationResult->state != PAWINUTIL_COM_NOT_INITIALIZED
+            && comInitializationResult->state != PAWINUTIL_COM_INITIALIZED ){
+    
+        PA_DEBUG(("ERROR: PaWinUtil_CoUninitialize called without calling PaWinUtil_CoInitialize\n"));
+    }
+
+    if( comInitializationResult->state == PAWINUTIL_COM_INITIALIZED )
+    {
+        DWORD currentThreadId = GetCurrentThreadId();
+		if( comInitializationResult->initializingThreadId != currentThreadId )
+		{
+			PA_DEBUG(("ERROR: failed PaWinUtil_CoUninitialize calling thread[%d] does not match initializing thread[%d]\n",
+				currentThreadId, comInitializationResult->initializingThreadId));
+		}
+		else
+		{
+			CoUninitialize();
+
+            comInitializationResult->state = PAWINUTIL_COM_NOT_INITIALIZED;
+		}
+    }
 }
\ No newline at end of file
--- a/src/os/win/pa_win_coinitialize.h
+++ b/src/os/win/pa_win_coinitialize.h
@@ -1,94 +1,94 @@
-/*
- * Microsoft COM initialization routines
- * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however, 
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
- * license above.
- */
-
-/** @file
- @ingroup win_src
-
- @brief Microsoft COM initialization routines.
-*/
-
-#ifndef PA_WIN_COINITIALIZE_H
-#define PA_WIN_COINITIALIZE_H
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /* __cplusplus */
-
-
-/**
- @brief Data type used to hold the result of an attempt to initialize COM
-    using PaWinUtil_CoInitialize. Must be retained between a call to 
-    PaWinUtil_CoInitialize and a matching call to PaWinUtil_CoUninitialize.
-*/
-typedef struct PaWinUtilComInitializationResult{
-    int state;
-    int initializingThreadId;
-} PaWinUtilComInitializationResult;
-
-
-/**
- @brief Initialize Microsoft COM subsystem on the current thread.
-
- @param hostApiType the host API type id of the caller. Used for error reporting.
-
- @param comInitializationResult An output parameter. The value pointed to by 
-        this parameter stores information required by PaWinUtil_CoUninitialize 
-        to correctly uninitialize COM. The value should be retained and later 
-        passed to PaWinUtil_CoUninitialize.
-
- If PaWinUtil_CoInitialize returns paNoError, the caller must later call
- PaWinUtil_CoUninitialize once.
-*/
-PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );
-
-
-/**
- @brief Uninitialize the Microsoft COM subsystem on the current thread using 
- the result of a previous call to PaWinUtil_CoInitialize. Must be called on the same
- thread as PaWinUtil_CoInitialize.
-
- @param hostApiType the host API type id of the caller. Used for error reporting.
-
- @param comInitializationResult An input parameter. A pointer to a value previously
- initialized by a call to PaWinUtil_CoInitialize.
-*/
-void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* PA_WIN_COINITIALIZE_H */
+/*
+ * Microsoft COM initialization routines
+ * Copyright (c) 1999-2011 Ross Bencina, Phil Burk
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however, 
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also 
+ * requested that these non-binding requests be included along with the 
+ * license above.
+ */
+
+/** @file
+ @ingroup win_src
+
+ @brief Microsoft COM initialization routines.
+*/
+
+#ifndef PA_WIN_COINITIALIZE_H
+#define PA_WIN_COINITIALIZE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+
+/**
+ @brief Data type used to hold the result of an attempt to initialize COM
+    using PaWinUtil_CoInitialize. Must be retained between a call to 
+    PaWinUtil_CoInitialize and a matching call to PaWinUtil_CoUninitialize.
+*/
+typedef struct PaWinUtilComInitializationResult{
+    int state;
+    int initializingThreadId;
+} PaWinUtilComInitializationResult;
+
+
+/**
+ @brief Initialize Microsoft COM subsystem on the current thread.
+
+ @param hostApiType the host API type id of the caller. Used for error reporting.
+
+ @param comInitializationResult An output parameter. The value pointed to by 
+        this parameter stores information required by PaWinUtil_CoUninitialize 
+        to correctly uninitialize COM. The value should be retained and later 
+        passed to PaWinUtil_CoUninitialize.
+
+ If PaWinUtil_CoInitialize returns paNoError, the caller must later call
+ PaWinUtil_CoUninitialize once.
+*/
+PaError PaWinUtil_CoInitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );
+
+
+/**
+ @brief Uninitialize the Microsoft COM subsystem on the current thread using 
+ the result of a previous call to PaWinUtil_CoInitialize. Must be called on the same
+ thread as PaWinUtil_CoInitialize.
+
+ @param hostApiType the host API type id of the caller. Used for error reporting.
+
+ @param comInitializationResult An input parameter. A pointer to a value previously
+ initialized by a call to PaWinUtil_CoInitialize.
+*/
+void PaWinUtil_CoUninitialize( PaHostApiTypeId hostApiType, PaWinUtilComInitializationResult *comInitializationResult );
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* PA_WIN_COINITIALIZE_H */
--- a/src/os/win/pa_win_hostapis.c
+++ b/src/os/win/pa_win_hostapis.c
@@ -1,5 +1,5 @@
 /*
- * $Id: pa_win_hostapis.c 1728 2011-08-18 03:31:51Z rossb $
+ * $Id$
  * Portable Audio I/O Library Windows initialization table
  *
  * Based on the Open Source API proposed by Ross Bencina
--- a/src/os/win/pa_win_util.c
+++ b/src/os/win/pa_win_util.c
@@ -1,5 +1,5 @@
 /*
- * $Id: pa_win_util.c 1584 2011-02-02 18:58:17Z rossb $
+ * $Id$
  * Portable Audio I/O Library
  * Win32 platform-specific support functions
  *
@@ -44,14 +44,17 @@
 */
  
 #include <windows.h>
-#include <mmsystem.h> /* for timeGetTime() */
 
-#include "pa_util.h"
-
-#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) /* MSC version 6 and above */
-#pragma comment( lib, "winmm.lib" )
+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
+	#include <sys/timeb.h> /* for _ftime_s() */
+#else
+	#include <mmsystem.h> /* for timeGetTime() */
+	#if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) && !defined(_WIN32_WCE) /* MSC version 6 and above */
+	#pragma comment( lib, "winmm.lib" )
+	#endif
 #endif
 
+#include "pa_util.h"
 
 /*
    Track memory allocations to avoid leaks.
@@ -144,8 +147,12 @@ double PaUtil_GetTime( void )
     }
     else
     {
-#ifndef UNDER_CE    	
+#ifndef UNDER_CE
+	#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
+        return GetTickCount64() * .001;
+	#else
         return timeGetTime() * .001;
+	#endif
 #else
         return GetTickCount() * .001;
 #endif                
--- a/src/os/win/pa_win_waveformat.c
+++ b/src/os/win/pa_win_waveformat.c
@@ -1,158 +1,162 @@
-/*
- * PortAudio Portable Real-Time Audio Library
- * Windows WAVEFORMAT* data structure utilities
- * portaudio.h should be included before this file.
- *
- * Copyright (c) 2007 Ross Bencina
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however, 
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
- * license above.
- */
-
-#include <windows.h>
-#include <mmsystem.h>
-
-#include "portaudio.h"
-#include "pa_win_waveformat.h"
-
-
-#if !defined(WAVE_FORMAT_EXTENSIBLE)
-#define  WAVE_FORMAT_EXTENSIBLE         0xFFFE
-#endif
-
-static GUID pawin_ksDataFormatSubtypeGuidBase = 
-	{ (USHORT)(WAVE_FORMAT_PCM), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 };
-
-
-int PaWin_SampleFormatToLinearWaveFormatTag( PaSampleFormat sampleFormat )
-{
-    if( sampleFormat == paFloat32 )
-        return PAWIN_WAVE_FORMAT_IEEE_FLOAT;
-    
-    return PAWIN_WAVE_FORMAT_PCM;
-}
-
-
-void PaWin_InitializeWaveFormatEx( PaWinWaveFormat *waveFormat, 
-		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate )
-{
-	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
-    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
-	unsigned long bytesPerFrame = numChannels * bytesPerSample;
-	
-    waveFormatEx->wFormatTag = waveFormatTag;
-	waveFormatEx->nChannels = (WORD)numChannels;
-	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
-	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
-	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
-	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
-	waveFormatEx->cbSize = 0;
-}
-
-
-void PaWin_InitializeWaveFormatExtensible( PaWinWaveFormat *waveFormat, 
-		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate,
-		PaWinWaveFormatChannelMask channelMask )
-{
-	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
-    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
-	unsigned long bytesPerFrame = numChannels * bytesPerSample;
-    GUID guid;
-
-	waveFormatEx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
-	waveFormatEx->nChannels = (WORD)numChannels;
-	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
-	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
-	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
-	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
-	waveFormatEx->cbSize = 22;
-
-	*((WORD*)&waveFormat->fields[PAWIN_INDEXOF_WVALIDBITSPERSAMPLE]) =
-			waveFormatEx->wBitsPerSample;
-
-	*((DWORD*)&waveFormat->fields[PAWIN_INDEXOF_DWCHANNELMASK]) = channelMask;
-		
-    guid = pawin_ksDataFormatSubtypeGuidBase;
-    guid.Data1 = (USHORT)waveFormatTag;
-    *((GUID*)&waveFormat->fields[PAWIN_INDEXOF_SUBFORMAT]) = guid;
-}
-
-PaWinWaveFormatChannelMask PaWin_DefaultChannelMask( int numChannels )
-{
-	switch( numChannels ){
-		case 1:
-			return PAWIN_SPEAKER_MONO;
-		case 2:
-			return PAWIN_SPEAKER_STEREO; 
-		case 3:
-            return PAWIN_SPEAKER_FRONT_LEFT | PAWIN_SPEAKER_FRONT_CENTER | PAWIN_SPEAKER_FRONT_RIGHT;
-		case 4:
-			return PAWIN_SPEAKER_QUAD;
-		case 5:
-            return PAWIN_SPEAKER_QUAD | PAWIN_SPEAKER_FRONT_CENTER;
-		case 6:
-            /* The meaning of the PAWIN_SPEAKER_5POINT1 flag has changed over time:
-                http://msdn2.microsoft.com/en-us/library/aa474707.aspx
-               We use PAWIN_SPEAKER_5POINT1 (not PAWIN_SPEAKER_5POINT1_SURROUND)
-               because on some cards (eg Audigy) PAWIN_SPEAKER_5POINT1_SURROUND 
-               results in a virtual mixdown placing the rear output in the 
-               front _and_ rear speakers.
-            */
-			return PAWIN_SPEAKER_5POINT1; 
-        /* case 7: */
-		case 8:
-            /* RoBi: PAWIN_SPEAKER_7POINT1_SURROUND fits normal surround sound setups better than PAWIN_SPEAKER_7POINT1, f.i. NVidia HDMI Audio
-               output is silent on channels 5&6 with NVidia drivers, and channel 7&8 with Micrsoft HD Audio driver using PAWIN_SPEAKER_7POINT1. 
-               With PAWIN_SPEAKER_7POINT1_SURROUND both setups work OK. */
-			return PAWIN_SPEAKER_7POINT1_SURROUND;
-	}
-
-    /* Apparently some Audigy drivers will output silence 
-       if the direct-out constant (0) is used. So this is not ideal.    
-
-       RoBi 2012-12-19: Also, NVidia driver seem to output garbage instead. Again not very ideal.
-    */
-	return  PAWIN_SPEAKER_DIRECTOUT;
-
-    /* Note that Alec Rogers proposed the following as an alternate method to 
-        generate the default channel mask, however it doesn't seem to be an improvement
-        over the above, since some drivers will matrix outputs mapping to non-present
-        speakers accross multiple physical speakers.
-
-        if(nChannels==1) {
-            pwfFormat->dwChannelMask = SPEAKER_FRONT_CENTER;
-        }
-        else {
-            pwfFormat->dwChannelMask = 0;
-            for(i=0; i<nChannels; i++)
-                pwfFormat->dwChannelMask = (pwfFormat->dwChannelMask << 1) | 0x1;
-        }
-    */
-}
+/*
+ * PortAudio Portable Real-Time Audio Library
+ * Windows WAVEFORMAT* data structure utilities
+ * portaudio.h should be included before this file.
+ *
+ * Copyright (c) 2007 Ross Bencina
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however, 
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also 
+ * requested that these non-binding requests be included along with the 
+ * license above.
+ */
+
+#include <windows.h>
+#include <mmsystem.h>
+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
+    #include <mmreg.h> /* for WAVEFORMATEX */
+#endif
+
+#include "portaudio.h"
+#include "pa_win_waveformat.h"
+
+
+#if !defined(WAVE_FORMAT_EXTENSIBLE)
+#define  WAVE_FORMAT_EXTENSIBLE         0xFFFE
+#endif
+
+
+static GUID pawin_ksDataFormatSubtypeGuidBase = 
+	{ (USHORT)(WAVE_FORMAT_PCM), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 };
+
+
+int PaWin_SampleFormatToLinearWaveFormatTag( PaSampleFormat sampleFormat )
+{
+    if( sampleFormat == paFloat32 )
+        return PAWIN_WAVE_FORMAT_IEEE_FLOAT;
+    
+    return PAWIN_WAVE_FORMAT_PCM;
+}
+
+
+void PaWin_InitializeWaveFormatEx( PaWinWaveFormat *waveFormat, 
+		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate )
+{
+	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
+    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
+	unsigned long bytesPerFrame = numChannels * bytesPerSample;
+	
+    waveFormatEx->wFormatTag = waveFormatTag;
+	waveFormatEx->nChannels = (WORD)numChannels;
+	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
+	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
+	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
+	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
+	waveFormatEx->cbSize = 0;
+}
+
+
+void PaWin_InitializeWaveFormatExtensible( PaWinWaveFormat *waveFormat, 
+		int numChannels, PaSampleFormat sampleFormat, int waveFormatTag, double sampleRate,
+		PaWinWaveFormatChannelMask channelMask )
+{
+	WAVEFORMATEX *waveFormatEx = (WAVEFORMATEX*)waveFormat;
+    int bytesPerSample = Pa_GetSampleSize(sampleFormat);
+	unsigned long bytesPerFrame = numChannels * bytesPerSample;
+    GUID guid;
+
+	waveFormatEx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+	waveFormatEx->nChannels = (WORD)numChannels;
+	waveFormatEx->nSamplesPerSec = (DWORD)sampleRate;
+	waveFormatEx->nAvgBytesPerSec = waveFormatEx->nSamplesPerSec * bytesPerFrame;
+	waveFormatEx->nBlockAlign = (WORD)bytesPerFrame;
+	waveFormatEx->wBitsPerSample = bytesPerSample * 8;
+	waveFormatEx->cbSize = 22;
+
+	*((WORD*)&waveFormat->fields[PAWIN_INDEXOF_WVALIDBITSPERSAMPLE]) =
+			waveFormatEx->wBitsPerSample;
+
+	*((DWORD*)&waveFormat->fields[PAWIN_INDEXOF_DWCHANNELMASK]) = channelMask;
+		
+    guid = pawin_ksDataFormatSubtypeGuidBase;
+    guid.Data1 = (USHORT)waveFormatTag;
+    *((GUID*)&waveFormat->fields[PAWIN_INDEXOF_SUBFORMAT]) = guid;
+}
+
+PaWinWaveFormatChannelMask PaWin_DefaultChannelMask( int numChannels )
+{
+	switch( numChannels ){
+		case 1:
+			return PAWIN_SPEAKER_MONO;
+		case 2:
+			return PAWIN_SPEAKER_STEREO; 
+		case 3:
+            return PAWIN_SPEAKER_FRONT_LEFT | PAWIN_SPEAKER_FRONT_CENTER | PAWIN_SPEAKER_FRONT_RIGHT;
+		case 4:
+			return PAWIN_SPEAKER_QUAD;
+		case 5:
+            return PAWIN_SPEAKER_QUAD | PAWIN_SPEAKER_FRONT_CENTER;
+		case 6:
+            /* The meaning of the PAWIN_SPEAKER_5POINT1 flag has changed over time:
+                http://msdn2.microsoft.com/en-us/library/aa474707.aspx
+               We use PAWIN_SPEAKER_5POINT1 (not PAWIN_SPEAKER_5POINT1_SURROUND)
+               because on some cards (eg Audigy) PAWIN_SPEAKER_5POINT1_SURROUND 
+               results in a virtual mixdown placing the rear output in the 
+               front _and_ rear speakers.
+            */
+			return PAWIN_SPEAKER_5POINT1; 
+        /* case 7: */
+		case 8:
+            /* RoBi: PAWIN_SPEAKER_7POINT1_SURROUND fits normal surround sound setups better than PAWIN_SPEAKER_7POINT1, f.i. NVidia HDMI Audio
+               output is silent on channels 5&6 with NVidia drivers, and channel 7&8 with Micrsoft HD Audio driver using PAWIN_SPEAKER_7POINT1. 
+               With PAWIN_SPEAKER_7POINT1_SURROUND both setups work OK. */
+			return PAWIN_SPEAKER_7POINT1_SURROUND;
+	}
+
+    /* Apparently some Audigy drivers will output silence 
+       if the direct-out constant (0) is used. So this is not ideal.    
+
+       RoBi 2012-12-19: Also, NVidia driver seem to output garbage instead. Again not very ideal.
+    */
+	return  PAWIN_SPEAKER_DIRECTOUT;
+
+    /* Note that Alec Rogers proposed the following as an alternate method to 
+        generate the default channel mask, however it doesn't seem to be an improvement
+        over the above, since some drivers will matrix outputs mapping to non-present
+        speakers accross multiple physical speakers.
+
+        if(nChannels==1) {
+            pwfFormat->dwChannelMask = SPEAKER_FRONT_CENTER;
+        }
+        else {
+            pwfFormat->dwChannelMask = 0;
+            for(i=0; i<nChannels; i++)
+                pwfFormat->dwChannelMask = (pwfFormat->dwChannelMask << 1) | 0x1;
+        }
+    */
+}
--- a/src/os/win/pa_win_wdmks_utils.c
+++ b/src/os/win/pa_win_wdmks_utils.c
@@ -1,308 +1,309 @@
-/*
- * PortAudio Portable Real-Time Audio Library
- * Windows WDM KS utilities
- *
- * Copyright (c) 1999 - 2007 Andrew Baldwin, Ross Bencina
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however, 
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
- * license above.
- */
-
-#include <windows.h>
-#include <mmreg.h>
-#ifndef WAVE_FORMAT_IEEE_FLOAT
-    #define WAVE_FORMAT_IEEE_FLOAT 0x0003   // MinGW32 does not define this
-#endif    
-#ifndef _WAVEFORMATEXTENSIBLE_
-    #define _WAVEFORMATEXTENSIBLE_          // MinGW32 does not define this
-#endif
-#ifndef _INC_MMREG
-    #define _INC_MMREG                      // for STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
-#endif
-#include <winioctl.h>						// MinGW32 does not define this automatically
-
-#if defined(__GNUC__)
-
-#include "../../hostapi/wasapi/mingw-include/ks.h"
-#include "../../hostapi/wasapi/mingw-include/ksmedia.h"
-
-#else
-
-#include <ks.h>
-#include <ksmedia.h>
-
-#endif
-
-#include <stdio.h>                          // just for some development printfs
-
-#include "portaudio.h"
-#include "pa_util.h"
-#include "pa_win_wdmks_utils.h"
-
-#if !defined(PA_WDMKS_NO_KSGUID_LIB) && !defined(PAWIN_WDMKS_NO_KSGUID_LIB) && !defined(__GNUC__)
-    #if (defined(WIN32) && (defined(_MSC_VER) && (_MSC_VER >= 1200))) /* MSC version 6 and above */
-        #pragma comment( lib, "ksguid.lib" )
-    #endif
-    #define pa_KSDATAFORMAT_TYPE_AUDIO            KSDATAFORMAT_TYPE_AUDIO
-    #define pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT    KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
-    #define pa_KSDATAFORMAT_SUBTYPE_PCM           KSDATAFORMAT_SUBTYPE_PCM
-    #define pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX  KSDATAFORMAT_SUBTYPE_WAVEFORMATEX
-    #define pa_KSMEDIUMSETID_Standard             KSMEDIUMSETID_Standard
-    #define pa_KSINTERFACESETID_Standard          KSINTERFACESETID_Standard
-    #define pa_KSPROPSETID_Pin                    KSPROPSETID_Pin
-#else
-    static const GUID pa_KSDATAFORMAT_TYPE_AUDIO            = { STATIC_KSDATAFORMAT_TYPE_AUDIO };
-    static const GUID pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT    = { STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT };
-    static const GUID pa_KSDATAFORMAT_SUBTYPE_PCM           = { STATIC_KSDATAFORMAT_SUBTYPE_PCM };
-    static const GUID pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX  = { STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX };
-    static const GUID pa_KSMEDIUMSETID_Standard             = { STATIC_KSMEDIUMSETID_Standard };
-    static const GUID pa_KSINTERFACESETID_Standard          = { STATIC_KSINTERFACESETID_Standard };
-    static const GUID pa_KSPROPSETID_Pin                    = { STATIC_KSPROPSETID_Pin };
-#endif
-
-
-#define pa_IS_VALID_WAVEFORMATEX_GUID(Guid)\
-    (!memcmp(((PUSHORT)&pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))
-
-
-
-static PaError WdmGetPinPropertySimple(
-    HANDLE  handle,
-    unsigned long pinId,
-    unsigned long property,
-    void* value,
-    unsigned long valueSize )
-{
-    DWORD bytesReturned;
-    KSP_PIN ksPProp;
-    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
-    ksPProp.Property.Id = property;
-    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
-    ksPProp.PinId = pinId;
-    ksPProp.Reserved = 0;
-
-    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
-            value, valueSize, &bytesReturned, NULL ) == 0 || bytesReturned != valueSize )
-    {
-        return paUnanticipatedHostError;
-    }
-    else
-    {
-        return paNoError;
-    }
-}
-
-
-static PaError WdmGetPinPropertyMulti(
-    HANDLE handle,
-    unsigned long pinId,
-    unsigned long property,
-    KSMULTIPLE_ITEM** ksMultipleItem)
-{
-    unsigned long multipleItemSize = 0;
-    KSP_PIN ksPProp;
-    DWORD bytesReturned;
-
-    *ksMultipleItem = 0;
-
-    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
-    ksPProp.Property.Id = property;
-    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
-    ksPProp.PinId = pinId;
-    ksPProp.Reserved = 0;
-
-    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp.Property,
-            sizeof(KSP_PIN), NULL, 0, &multipleItemSize, NULL ) == 0 && GetLastError() != ERROR_MORE_DATA )
-    {
-        return paUnanticipatedHostError;
-    }
-
-    *ksMultipleItem = (KSMULTIPLE_ITEM*)PaUtil_AllocateMemory( multipleItemSize );
-    if( !*ksMultipleItem )
-    {
-        return paInsufficientMemory;
-    }
-
-    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
-            (void*)*ksMultipleItem,  multipleItemSize, &bytesReturned, NULL ) == 0 || bytesReturned != multipleItemSize )
-    {
-        PaUtil_FreeMemory( ksMultipleItem );
-        return paUnanticipatedHostError;
-    }
-
-    return paNoError;
-}
-
-
-static int GetKSFilterPinCount( HANDLE deviceHandle )
-{
-    DWORD result;
-
-    if( WdmGetPinPropertySimple( deviceHandle, 0, KSPROPERTY_PIN_CTYPES, &result, sizeof(result) ) == paNoError ){
-        return result;
-    }else{
-        return 0;
-    }
-}
-
-
-static KSPIN_COMMUNICATION GetKSFilterPinPropertyCommunication( HANDLE deviceHandle, int pinId )
-{
-    KSPIN_COMMUNICATION result;
-
-    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_COMMUNICATION, &result, sizeof(result) ) == paNoError ){
-        return result;
-    }else{
-        return KSPIN_COMMUNICATION_NONE;
-    }
-}
-
-
-static KSPIN_DATAFLOW GetKSFilterPinPropertyDataflow( HANDLE deviceHandle, int pinId )
-{
-    KSPIN_DATAFLOW result;
-
-    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_DATAFLOW, &result, sizeof(result) ) == paNoError ){
-        return result;
-    }else{
-        return (KSPIN_DATAFLOW)0;
-    }
-}
-
-
-static int KSFilterPinPropertyIdentifiersInclude( 
-        HANDLE deviceHandle, int pinId, unsigned long property, const GUID *identifierSet, unsigned long identifierId  )
-{
-    KSMULTIPLE_ITEM* item = NULL;
-    KSIDENTIFIER* identifier;
-    int i;
-    int result = 0;
-
-    if( WdmGetPinPropertyMulti( deviceHandle, pinId, property, &item) != paNoError )
-        return 0;
-    
-    identifier = (KSIDENTIFIER*)(item+1);
-
-    for( i = 0; i < (int)item->Count; i++ )
-    {
-        if( !memcmp( (void*)&identifier[i].Set, (void*)identifierSet, sizeof( GUID ) ) &&
-           ( identifier[i].Id == identifierId ) )
-        {
-            result = 1;
-            break;
-        }
-    }
-
-    PaUtil_FreeMemory( item );
-
-    return result;
-}
-
-
-/* return the maximum channel count supported by any pin on the device. 
-   if isInput is non-zero we query input pins, otherwise output pins.
-*/
-int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput )
-{
-    HANDLE deviceHandle;
-	ULONG i;
-    int pinCount, pinId;
-    int result = 0;
-    KSPIN_DATAFLOW requiredDataflowDirection = (isInput ? KSPIN_DATAFLOW_OUT : KSPIN_DATAFLOW_IN );
-    
-    if( !wcharDevicePath )
-        return 0;
-
-    deviceHandle = CreateFileW( (LPCWSTR)wcharDevicePath, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL );
-    if( deviceHandle == INVALID_HANDLE_VALUE )
-        return 0;
-
-    pinCount = GetKSFilterPinCount( deviceHandle );
-    for( pinId = 0; pinId < pinCount; ++pinId )
-    {
-        KSPIN_COMMUNICATION communication = GetKSFilterPinPropertyCommunication( deviceHandle, pinId );
-        KSPIN_DATAFLOW dataflow = GetKSFilterPinPropertyDataflow( deviceHandle, pinId );
-        if( ( dataflow == requiredDataflowDirection ) &&
-                (( communication == KSPIN_COMMUNICATION_SINK) ||
-                 ( communication == KSPIN_COMMUNICATION_BOTH)) 
-             && ( KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
-                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING )
-                || KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
-                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_LOOPED_STREAMING ) )
-             && KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
-                    KSPROPERTY_PIN_MEDIUMS, &pa_KSMEDIUMSETID_Standard, KSMEDIUM_STANDARD_DEVIO ) )
-         {
-            KSMULTIPLE_ITEM* item = NULL;
-            if( WdmGetPinPropertyMulti( deviceHandle, pinId, KSPROPERTY_PIN_DATARANGES, &item ) == paNoError )
-            {
-                KSDATARANGE *dataRange = (KSDATARANGE*)(item+1);
-
-                for( i=0; i < item->Count; ++i ){
-
-                    if( pa_IS_VALID_WAVEFORMATEX_GUID(&dataRange->SubFormat)
-                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_PCM, sizeof(GUID) ) == 0
-                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, sizeof(GUID) ) == 0
-                            || ( ( memcmp( (void*)&dataRange->MajorFormat, (void*)&pa_KSDATAFORMAT_TYPE_AUDIO, sizeof(GUID) ) == 0 )
-                                && ( memcmp( (void*)&dataRange->SubFormat, (void*)&KSDATAFORMAT_SUBTYPE_WILDCARD, sizeof(GUID) ) == 0 ) ) )
-                    {
-                        KSDATARANGE_AUDIO *dataRangeAudio = (KSDATARANGE_AUDIO*)dataRange;
-                        
-                        /*
-                        printf( ">>> %d %d %d %d %S\n", isInput, dataflow, communication, dataRangeAudio->MaximumChannels, devicePath );
-                       
-                        if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WAVEFORMATEX, sizeof(GUID) ) == 0 )
-                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\n" );
-                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_DSOUND, sizeof(GUID) ) == 0 )
-                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_DSOUND\n" );
-                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WILDCARD, sizeof(GUID) ) == 0 )
-                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WILDCARD\n" );
-                        else
-                            printf( "\tspecifier: ?\n" );
-                        */
-
-                        /*
-                            We assume that very high values for MaximumChannels are not useful and indicate
-                            that the driver isn't prepared to tell us the real number of channels which it supports.
-                        */
-                        if( dataRangeAudio->MaximumChannels  < 0xFFFFUL && (int)dataRangeAudio->MaximumChannels > result )
-                            result = (int)dataRangeAudio->MaximumChannels;
-                    }
-                    
-                    dataRange = (KSDATARANGE*)( ((char*)dataRange) + dataRange->FormatSize);
-                }
-
-                PaUtil_FreeMemory( item );
-            }
-        }
-    }
-    
-    CloseHandle( deviceHandle );
-    return result;
-}
+/*
+ * PortAudio Portable Real-Time Audio Library
+ * Windows WDM KS utilities
+ *
+ * Copyright (c) 1999 - 2007 Andrew Baldwin, Ross Bencina
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however, 
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also 
+ * requested that these non-binding requests be included along with the 
+ * license above.
+ */
+
+#include <windows.h>
+#include <mmreg.h>
+#ifndef WAVE_FORMAT_IEEE_FLOAT
+    #define WAVE_FORMAT_IEEE_FLOAT 0x0003   // MinGW32 does not define this
+#endif    
+#ifndef _WAVEFORMATEXTENSIBLE_
+    #define _WAVEFORMATEXTENSIBLE_          // MinGW32 does not define this
+#endif
+#ifndef _INC_MMREG
+    #define _INC_MMREG                      // for STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
+#endif
+#include <winioctl.h>						// MinGW32 does not define this automatically
+
+#if defined(__GNUC__)
+
+#include "../../hostapi/wasapi/mingw-include/ks.h"
+#include "../../hostapi/wasapi/mingw-include/ksmedia.h"
+
+#else
+
+#include <ks.h>
+#include <ksmedia.h>
+
+#endif
+
+#include <stdio.h>                          // just for some development printfs
+
+#include "portaudio.h"
+#include "pa_util.h"
+#include "pa_win_wdmks_utils.h"
+
+
+/* PortAudio-local instances of GUIDs previously sourced from ksguid.lib */
+
+/* GUID KSDATAFORMAT_TYPE_AUDIO */
+static const GUID pa_KSDATAFORMAT_TYPE_AUDIO = { STATIC_KSDATAFORMAT_TYPE_AUDIO };
+
+/* GUID KSDATAFORMAT_SUBTYPE_IEEE_FLOAT */
+static const GUID pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = { STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT };
+
+/* GUID KSDATAFORMAT_SUBTYPE_PCM */
+static const GUID pa_KSDATAFORMAT_SUBTYPE_PCM = { STATIC_KSDATAFORMAT_SUBTYPE_PCM };
+
+/* GUID KSDATAFORMAT_SUBTYPE_WAVEFORMATEX */
+static const GUID pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX = { STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX };
+
+/* GUID KSMEDIUMSETID_Standard */
+static const GUID pa_KSMEDIUMSETID_Standard = { STATIC_KSMEDIUMSETID_Standard };
+
+/* GUID KSINTERFACESETID_Standard */
+static const GUID pa_KSINTERFACESETID_Standard = { STATIC_KSINTERFACESETID_Standard };
+
+/* GUID KSPROPSETID_Pin */
+static const GUID pa_KSPROPSETID_Pin = { STATIC_KSPROPSETID_Pin };
+
+#define pa_IS_VALID_WAVEFORMATEX_GUID(Guid)\
+    (!memcmp(((PUSHORT)&pa_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))
+
+
+static PaError WdmGetPinPropertySimple(
+    HANDLE  handle,
+    unsigned long pinId,
+    unsigned long property,
+    void* value,
+    unsigned long valueSize )
+{
+    DWORD bytesReturned;
+    KSP_PIN ksPProp;
+    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
+    ksPProp.Property.Id = property;
+    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
+    ksPProp.PinId = pinId;
+    ksPProp.Reserved = 0;
+
+    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
+            value, valueSize, &bytesReturned, NULL ) == 0 || bytesReturned != valueSize )
+    {
+        return paUnanticipatedHostError;
+    }
+    else
+    {
+        return paNoError;
+    }
+}
+
+
+static PaError WdmGetPinPropertyMulti(
+    HANDLE handle,
+    unsigned long pinId,
+    unsigned long property,
+    KSMULTIPLE_ITEM** ksMultipleItem)
+{
+    unsigned long multipleItemSize = 0;
+    KSP_PIN ksPProp;
+    DWORD bytesReturned;
+
+    *ksMultipleItem = 0;
+
+    ksPProp.Property.Set = pa_KSPROPSETID_Pin;
+    ksPProp.Property.Id = property;
+    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
+    ksPProp.PinId = pinId;
+    ksPProp.Reserved = 0;
+
+    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp.Property,
+            sizeof(KSP_PIN), NULL, 0, &multipleItemSize, NULL ) == 0 && GetLastError() != ERROR_MORE_DATA )
+    {
+        return paUnanticipatedHostError;
+    }
+
+    *ksMultipleItem = (KSMULTIPLE_ITEM*)PaUtil_AllocateMemory( multipleItemSize );
+    if( !*ksMultipleItem )
+    {
+        return paInsufficientMemory;
+    }
+
+    if( DeviceIoControl( handle, IOCTL_KS_PROPERTY, &ksPProp, sizeof(KSP_PIN),
+            (void*)*ksMultipleItem,  multipleItemSize, &bytesReturned, NULL ) == 0 || bytesReturned != multipleItemSize )
+    {
+        PaUtil_FreeMemory( ksMultipleItem );
+        return paUnanticipatedHostError;
+    }
+
+    return paNoError;
+}
+
+
+static int GetKSFilterPinCount( HANDLE deviceHandle )
+{
+    DWORD result;
+
+    if( WdmGetPinPropertySimple( deviceHandle, 0, KSPROPERTY_PIN_CTYPES, &result, sizeof(result) ) == paNoError ){
+        return result;
+    }else{
+        return 0;
+    }
+}
+
+
+static KSPIN_COMMUNICATION GetKSFilterPinPropertyCommunication( HANDLE deviceHandle, int pinId )
+{
+    KSPIN_COMMUNICATION result;
+
+    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_COMMUNICATION, &result, sizeof(result) ) == paNoError ){
+        return result;
+    }else{
+        return KSPIN_COMMUNICATION_NONE;
+    }
+}
+
+
+static KSPIN_DATAFLOW GetKSFilterPinPropertyDataflow( HANDLE deviceHandle, int pinId )
+{
+    KSPIN_DATAFLOW result;
+
+    if( WdmGetPinPropertySimple( deviceHandle, pinId, KSPROPERTY_PIN_DATAFLOW, &result, sizeof(result) ) == paNoError ){
+        return result;
+    }else{
+        return (KSPIN_DATAFLOW)0;
+    }
+}
+
+
+static int KSFilterPinPropertyIdentifiersInclude( 
+        HANDLE deviceHandle, int pinId, unsigned long property, const GUID *identifierSet, unsigned long identifierId  )
+{
+    KSMULTIPLE_ITEM* item = NULL;
+    KSIDENTIFIER* identifier;
+    int i;
+    int result = 0;
+
+    if( WdmGetPinPropertyMulti( deviceHandle, pinId, property, &item) != paNoError )
+        return 0;
+    
+    identifier = (KSIDENTIFIER*)(item+1);
+
+    for( i = 0; i < (int)item->Count; i++ )
+    {
+        if( !memcmp( (void*)&identifier[i].Set, (void*)identifierSet, sizeof( GUID ) ) &&
+           ( identifier[i].Id == identifierId ) )
+        {
+            result = 1;
+            break;
+        }
+    }
+
+    PaUtil_FreeMemory( item );
+
+    return result;
+}
+
+
+/* return the maximum channel count supported by any pin on the device. 
+   if isInput is non-zero we query input pins, otherwise output pins.
+*/
+int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput )
+{
+    HANDLE deviceHandle;
+	ULONG i;
+    int pinCount, pinId;
+    int result = 0;
+    KSPIN_DATAFLOW requiredDataflowDirection = (isInput ? KSPIN_DATAFLOW_OUT : KSPIN_DATAFLOW_IN );
+    
+    if( !wcharDevicePath )
+        return 0;
+
+    deviceHandle = CreateFileW( (LPCWSTR)wcharDevicePath, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL );
+    if( deviceHandle == INVALID_HANDLE_VALUE )
+        return 0;
+
+    pinCount = GetKSFilterPinCount( deviceHandle );
+    for( pinId = 0; pinId < pinCount; ++pinId )
+    {
+        KSPIN_COMMUNICATION communication = GetKSFilterPinPropertyCommunication( deviceHandle, pinId );
+        KSPIN_DATAFLOW dataflow = GetKSFilterPinPropertyDataflow( deviceHandle, pinId );
+        if( ( dataflow == requiredDataflowDirection ) &&
+                (( communication == KSPIN_COMMUNICATION_SINK) ||
+                 ( communication == KSPIN_COMMUNICATION_BOTH)) 
+             && ( KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
+                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING )
+                || KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
+                    KSPROPERTY_PIN_INTERFACES, &pa_KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_LOOPED_STREAMING ) )
+             && KSFilterPinPropertyIdentifiersInclude( deviceHandle, pinId, 
+                    KSPROPERTY_PIN_MEDIUMS, &pa_KSMEDIUMSETID_Standard, KSMEDIUM_STANDARD_DEVIO ) )
+         {
+            KSMULTIPLE_ITEM* item = NULL;
+            if( WdmGetPinPropertyMulti( deviceHandle, pinId, KSPROPERTY_PIN_DATARANGES, &item ) == paNoError )
+            {
+                KSDATARANGE *dataRange = (KSDATARANGE*)(item+1);
+
+                for( i=0; i < item->Count; ++i ){
+
+                    if( pa_IS_VALID_WAVEFORMATEX_GUID(&dataRange->SubFormat)
+                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_PCM, sizeof(GUID) ) == 0
+                            || memcmp( (void*)&dataRange->SubFormat, (void*)&pa_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT, sizeof(GUID) ) == 0
+                            || ( ( memcmp( (void*)&dataRange->MajorFormat, (void*)&pa_KSDATAFORMAT_TYPE_AUDIO, sizeof(GUID) ) == 0 )
+                                && ( memcmp( (void*)&dataRange->SubFormat, (void*)&KSDATAFORMAT_SUBTYPE_WILDCARD, sizeof(GUID) ) == 0 ) ) )
+                    {
+                        KSDATARANGE_AUDIO *dataRangeAudio = (KSDATARANGE_AUDIO*)dataRange;
+                        
+                        /*
+                        printf( ">>> %d %d %d %d %S\n", isInput, dataflow, communication, dataRangeAudio->MaximumChannels, devicePath );
+                       
+                        if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WAVEFORMATEX, sizeof(GUID) ) == 0 )
+                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\n" );
+                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_DSOUND, sizeof(GUID) ) == 0 )
+                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_DSOUND\n" );
+                        else if( memcmp((void*)&dataRange->Specifier, (void*)&KSDATAFORMAT_SPECIFIER_WILDCARD, sizeof(GUID) ) == 0 )
+                            printf( "\tspecifier: KSDATAFORMAT_SPECIFIER_WILDCARD\n" );
+                        else
+                            printf( "\tspecifier: ?\n" );
+                        */
+
+                        /*
+                            We assume that very high values for MaximumChannels are not useful and indicate
+                            that the driver isn't prepared to tell us the real number of channels which it supports.
+                        */
+                        if( dataRangeAudio->MaximumChannels  < 0xFFFFUL && (int)dataRangeAudio->MaximumChannels > result )
+                            result = (int)dataRangeAudio->MaximumChannels;
+                    }
+                    
+                    dataRange = (KSDATARANGE*)( ((char*)dataRange) + dataRange->FormatSize);
+                }
+
+                PaUtil_FreeMemory( item );
+            }
+        }
+    }
+    
+    CloseHandle( deviceHandle );
+    return result;
+}
--- a/src/os/win/pa_win_wdmks_utils.h
+++ b/src/os/win/pa_win_wdmks_utils.h
@@ -1,65 +1,65 @@
-#ifndef PA_WIN_WDMKS_UTILS_H
-#define PA_WIN_WDMKS_UTILS_H
-
-/*
- * PortAudio Portable Real-Time Audio Library
- * Windows WDM KS utilities
- *
- * Copyright (c) 1999 - 2007 Ross Bencina, Andrew Baldwin
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
- * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * The text above constitutes the entire PortAudio license; however, 
- * the PortAudio community also makes the following non-binding requests:
- *
- * Any person wishing to distribute modifications to the Software is
- * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
- * license above.
- */
-
-/** @file
- @brief Utilities for working with the Windows WDM KS API
-*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
-    Query for the maximum number of channels supported by any pin of the
-    specified device. Returns 0 if the query fails for any reason.
-
-    @param wcharDevicePath A system level PnP interface path, supplied as a WCHAR unicode string.
-    Declard as void* to avoid introducing a dependency on wchar_t here.
-
-    @param isInput A flag specifying whether to query for input (non-zero) or output (zero) channels.
-*/
-int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput );
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
+#ifndef PA_WIN_WDMKS_UTILS_H
+#define PA_WIN_WDMKS_UTILS_H
+
+/*
+ * PortAudio Portable Real-Time Audio Library
+ * Windows WDM KS utilities
+ *
+ * Copyright (c) 1999 - 2007 Ross Bencina, Andrew Baldwin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The text above constitutes the entire PortAudio license; however, 
+ * the PortAudio community also makes the following non-binding requests:
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version. It is also 
+ * requested that these non-binding requests be included along with the 
+ * license above.
+ */
+
+/** @file
+ @brief Utilities for working with the Windows WDM KS API
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    Query for the maximum number of channels supported by any pin of the
+    specified device. Returns 0 if the query fails for any reason.
+
+    @param wcharDevicePath A system level PnP interface path, supplied as a WCHAR unicode string.
+    Declard as void* to avoid introducing a dependency on wchar_t here.
+
+    @param isInput A flag specifying whether to query for input (non-zero) or output (zero) channels.
+*/
+int PaWin_WDMKS_QueryFilterMaximumChannelCount( void *wcharDevicePath, int isInput );
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
 #endif /* PA_WIN_WDMKS_UTILS_H */
\ No newline at end of file
-- 
2.8.1.windows.1