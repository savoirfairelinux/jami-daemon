{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d790951e_4b187a98",
        "filename": "src/logger.cpp",
        "patchSetId": 11
      },
      "lineNbr": 228,
      "author": {
        "id": 5
      },
      "writtenOn": "2021-07-22T16:08:31Z",
      "side": 1,
      "message": "MINOR SonarQube violation:\n\n\nprefer ptr1 \u003d std::move(ptr2) over ptr1.reset(ptr2.release())\n\n\nRead more: https://sonar-jami.savoirfairelinux.net/coding_rules#rule_key\u003dClangTidy%3Amisc-uniqueptr-reset-release",
      "revId": "a5e2a7f23dfafc4220487ef4a70ca4e7c225b804",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01d8f33d_4dfdea27",
        "filename": "src/logger.cpp",
        "patchSetId": 11
      },
      "lineNbr": 248,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-22T16:33:45Z",
      "side": 1,
      "message": "isEnabled() const",
      "range": {
        "startLine": 248,
        "startChar": 9,
        "endLine": 248,
        "endChar": 17
      },
      "revId": "a5e2a7f23dfafc4220487ef4a70ca4e7c225b804",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d422b7ba_00261a68",
        "filename": "src/logger.cpp",
        "patchSetId": 11
      },
      "lineNbr": 448,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-22T16:33:45Z",
      "side": 1,
      "message": "Could be called after enable() and before wait() in std::thread, causing deadlock on thread_.join().\n\nAlso, it\u0027s recommended to use cv with a real mutex that should be locked when calling notify() (because the mutex protects the cv itself), and when changing the condition (enabled or queue not empty).\n\nUse cv with predicate, like:\n\n    std::vector\u003cjami::Logger::Msg\u003e pendingQ_;\n    while (enable()) {\n       {\n           std::unique_lock lk(mtx);\n           cv_.wait(lk, [\u0026]{ return not enable() or not currentQ_.empty(); });\n           if (not enable()) break;\n           std::swap(pendingQ_, currentQ_);\n       }\n       // consume unlocked so the mutex is actually almost never locked.\n       do_consume(pendingQ_);\n       pendingQ.clear();\n    }",
      "range": {
        "startLine": 448,
        "startChar": 11,
        "endLine": 448,
        "endChar": 29
      },
      "revId": "a5e2a7f23dfafc4220487ef4a70ca4e7c225b804",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "376bbe61_8a30461c",
        "filename": "src/logger.cpp",
        "patchSetId": 11
      },
      "lineNbr": 455,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-22T16:33:45Z",
      "side": 1,
      "message": "use c++ automatic destruction (unique_ptr + custom destructor)",
      "range": {
        "startLine": 455,
        "startChar": 16,
        "endLine": 455,
        "endChar": 22
      },
      "revId": "a5e2a7f23dfafc4220487ef4a70ca4e7c225b804",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0d9253f_aa546ef0",
        "filename": "src/logger.cpp",
        "patchSetId": 11
      },
      "lineNbr": 477,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-22T16:33:45Z",
      "side": 1,
      "message": "Could be called after a previous log message have been processed but before the next wait() in std::thread, causing log processing to be delayed.\n\nUnfortunately the clean way is to lock the mutex here.\nBut if implemented clean, the overhead would be minimal because the mutex would almost never be locked.",
      "range": {
        "startLine": 477,
        "startChar": 12,
        "endLine": 477,
        "endChar": 29
      },
      "revId": "a5e2a7f23dfafc4220487ef4a70ca4e7c225b804",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}