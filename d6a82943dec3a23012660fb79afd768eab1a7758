{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "90010f20_2d362d99",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 220
      },
      "writtenOn": "2021-07-27T16:27:46Z",
      "side": 1,
      "message": "some nitpik, also missing ticket",
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a84bc5b2_f3283d79",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 220
      },
      "writtenOn": "2021-07-27T16:27:46Z",
      "side": 1,
      "message": ".reset() should be ok there",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c5229c0_73ff3a2e",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T16:36:47Z",
      "side": 1,
      "message": "No this is the point.  We don\u0027t want to double reset the same pointer.  If icest_ point to something, it\u0027s because it was reset in a callback, which is a bug.  Releasing is the good way of avoiding double pj_ice_strans_destroy",
      "parentUuid": "a84bc5b2_f3283d79",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "222ec1f7_8e989829",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 220
      },
      "writtenOn": "2021-07-27T17:44:11Z",
      "side": 1,
      "message": "icest_ is not checked with iceMutex_ locked here\n\nBut this can\u0027t be the same pointer.\n\nLine 459 you do icest_.reset(); which will pj_ice_strans_destroy and icest_ will be nullptr\n\nIf onComplete goes after icest_ will point to something but nothing here will manages the ice_strans. There is no reason that the up destructor is called twice with the same pointer",
      "parentUuid": "7c5229c0_73ff3a2e",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e58ff4a_f6b72870",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-27T17:52:24Z",
      "side": 1,
      "message": "* reset on a unique or shared pointer calls the destructor and also sets the pointer to null, guaranteeing it won\u0027t be destroyed twice when used properly.\n* If destruction can happen twice, it\u0027s a serious bug, likely caused by a race condition. A quick analysis showed that icest_ must always be protected by iceMutex_ which is not the case here.",
      "parentUuid": "7c5229c0_73ff3a2e",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b0de2f3_aa3c8138",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T19:02:19Z",
      "side": 1,
      "message": "It happened twice sometime yes.  This is why I put this paranoid check, it should even be an assert IMO.  It\u0027s a very rare race condition.\n\nEven with mutex it doesnt matter.  At that point, the only thread owning a reference to the transport is the one executing the destructor.  It calls the handlEvents method to close all TURN socket after reseting the transport.  Then the onComplete callback reset the transport. \n\nIt\u0027s fixed by checking the thread terminated flags in the onComplete callback, but the redundant check is paranoid I agree.\n\nProof: https://pastebin.com/P2RxSTVA\nPassword of proof: HU39fUHvDn",
      "parentUuid": "9e58ff4a_f6b72870",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40031b8e_bc1b217f",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T19:12:57Z",
      "side": 1,
      "message": "Just to be clear on my last comment.  This checks is not necessary because this patch fixes the problem.  But I think we should still put an assertion, or leave the if/release branch for production to catch future race conditions (dues to refactor for example).",
      "parentUuid": "9b0de2f3_aa3c8138",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50db8425_5c789c56",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 481,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-28T14:15:37Z",
      "side": 1,
      "message": "Ok for an assertion. However, the reset logic itself is unnecessary.",
      "parentUuid": "40031b8e_bc1b217f",
      "range": {
        "startLine": 481,
        "startChar": 8,
        "endLine": 481,
        "endChar": 25
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "676ea393_81d0fdd2",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 789,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-27T17:52:24Z",
      "side": 1,
      "message": "This is the only use of getUFragPwd().\nSo getUFragPwd could require to be called with iceMutex_ locked by the caller.",
      "range": {
        "startLine": 789,
        "startChar": 4,
        "endLine": 789,
        "endChar": 18
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bad55e9f_d86e02ed",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 789,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T19:02:19Z",
      "side": 1,
      "message": "I\u0027m not a big fan of this inversion of locking but okay.\n\nI think that locking should be as local as possible, around the data being accessed, not the call site.",
      "parentUuid": "676ea393_81d0fdd2",
      "range": {
        "startLine": 789,
        "startChar": 4,
        "endLine": 789,
        "endChar": 18
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "625ebe72_6b8f1597",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 789,
      "author": {
        "id": 6
      },
      "writtenOn": "2021-07-28T00:32:40Z",
      "side": 1,
      "message": "I agree that locking should be as local as possible, however it\u0027s a useful common pattern to have private methods non-blocking and requiring to be used locked, with public methods actually locking the mutexes. This pattern allows for the whole operation to be atomic instead of unlocking-locking the mutex multiple times, which adds a risk for state changes between locks.",
      "parentUuid": "bad55e9f_d86e02ed",
      "range": {
        "startLine": 789,
        "startChar": 4,
        "endLine": 789,
        "endChar": 18
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d114da7_5c72325a",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 789,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-28T13:02:09Z",
      "side": 1,
      "message": "Yes I get your point.  But this add a risk of forgetting to lock before calling the private method.  I added a comment in my last patchset that says that the function needs the caller to lock the transport mutex, but someone could forget in the future.\n\nWould be nice if we could mark a private method with some attribute that says `requires this lock` and then the compiler needs to prove via static analysis that all call sites indeed have the lock.",
      "parentUuid": "625ebe72_6b8f1597",
      "range": {
        "startLine": 789,
        "startChar": 4,
        "endLine": 789,
        "endChar": 18
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "382b8753_2e0eac26",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1624,
      "author": {
        "id": 220
      },
      "writtenOn": "2021-07-27T16:27:46Z",
      "side": 1,
      "message": "errno should be set for upper layer and useful for IceSocketTransport::write",
      "range": {
        "startLine": 1624,
        "startChar": 12,
        "endLine": 1624,
        "endChar": 22
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f412412_b89be9e2",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1624,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T16:36:47Z",
      "side": 1,
      "message": "What should errno be set to for no transport?\n\nEGAIN, ENXIO, EIO, ENODEV?",
      "parentUuid": "382b8753_2e0eac26",
      "range": {
        "startLine": 1624,
        "startChar": 12,
        "endLine": 1624,
        "endChar": 22
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0a92078_4ec60f69",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1624,
      "author": {
        "id": 220
      },
      "writtenOn": "2021-07-27T17:44:11Z",
      "side": 1,
      "message": "EIO is good for me",
      "parentUuid": "9f412412_b89be9e2",
      "range": {
        "startLine": 1624,
        "startChar": 12,
        "endLine": 1624,
        "endChar": 22
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f6d2812_9f7e8f2e",
        "filename": "src/ice_transport.cpp",
        "patchSetId": 9
      },
      "lineNbr": 1624,
      "author": {
        "id": 919
      },
      "writtenOn": "2021-07-27T19:02:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d0a92078_4ec60f69",
      "range": {
        "startLine": 1624,
        "startChar": 12,
        "endLine": 1624,
        "endChar": 22
      },
      "revId": "d6a82943dec3a23012660fb79afd768eab1a7758",
      "serverId": "1e26b4c1-6b8c-47ff-9df7-501b633d3b5a"
    }
  ]
}